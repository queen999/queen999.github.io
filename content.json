{"meta":{"title":"覃浩的博客","subtitle":"兴趣广泛的小菜鸟","description":"计算机技术与科学专业在读学生，爱好编程，剪辑，调音，鬼畜","author":"覃浩","url":"https://imqinhao.cn","root":"/"},"pages":[{"title":"","date":"2020-06-12T03:16:31.351Z","updated":"2020-06-12T03:16:31.351Z","comments":true,"path":"ByteDanceVerify.html","permalink":"https://imqinhao.cn/ByteDanceVerify.html","excerpt":"","text":"rfNaSas9uI7HA+yt2720"},{"title":"关于","date":"2020-03-09T14:00:15.511Z","updated":"2020-02-06T13:28:27.166Z","comments":true,"path":"about/index.html","permalink":"https://imqinhao.cn/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-02-08T11:26:16.121Z","updated":"2020-02-06T13:56:11.453Z","comments":true,"path":"category/index.html","permalink":"https://imqinhao.cn/category/index.html","excerpt":"","text":""},{"title":"","date":"2021-02-08T11:25:59.618Z","updated":"2020-02-13T05:16:19.330Z","comments":true,"path":"footer/index.html","permalink":"https://imqinhao.cn/footer/index.html","excerpt":"","text":"text-align: center; width: 100%; margin-top: 50px; 您的喜欢是作者写作最大的动力！❤️ &lt;li id=&quot;AliPayOR&quot; title=&quot;支付宝打赏&quot;&gt;AliPay&lt;/li&gt; &lt;li id=&quot;WeChatPayOR&quot; title=&quot;微信打赏&quot;&gt;WeChatPay&lt;/li&gt; &lt;li id=&quot;QQPayOR&quot; title=&quot;QQ打赏&quot;&gt;QQPay&lt;/li&gt; Donate jQuery(document).ready(function () { var QRBox = $('#QRBox'); var MainBox = $('#MainBox'); var AliPayOR = 'https://www.zhengyuanyuan520.cn/images/Alipay.png'; var WeChatPayOR = 'https://www.zhengyuanyuan520.cn/images/Wechat.png'; var QQPayOR = 'https://www.zhengyuanyuan520.cn/images/QQPay.png'; function showQR(QR) { if (QR) { MainBox.css(&apos;background-image&apos;, &apos;url(&apos; + QR + &apos;)&apos;); } $(&apos;#RewardText,#RewardBox,#github&apos;).addClass(&apos;blur&apos;); QRBox.fadeIn(300, function (argument) { MainBox.addClass(&apos;showQR&apos;); }); } $(&apos;#RewardBox&gt;li&apos;).click(function (event) { var thisID = $(this).attr(&apos;id&apos;); if (thisID === &apos;AliPayOR&apos;) { showQR(AliPayOR); } else if (thisID === &apos;WeChatPayOR&apos;) { showQR(WeChatPayOR); } else if (thisID === &apos;QQPayOR&apos;) { showQR(QQPayOR); } }); MainBox.click(function (event) { MainBox.removeClass(&apos;showQR&apos;).addClass(&apos;hideQR&apos;); setTimeout(function (a) { QRBox.fadeOut(300, function (argument) { MainBox.removeClass(&apos;hideQR&apos;); }); $(&apos;#RewardText,#RewardBox,#github&apos;).removeClass(&apos;blur&apos;); }, 600); }); });"},{"title":"我的朋友们","date":"2021-03-14T03:06:43.707Z","updated":"2021-03-14T03:06:43.707Z","comments":true,"path":"friends/index.html","permalink":"https://imqinhao.cn/friends/index.html","excerpt":"","text":""},{"title":"","date":"2021-02-08T11:25:51.795Z","updated":"2020-02-07T03:42:59.299Z","comments":true,"path":"mylist/index.html","permalink":"https://imqinhao.cn/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-03-09T14:00:15.517Z","updated":"2020-02-06T13:56:51.611Z","comments":true,"path":"tags/index.html","permalink":"https://imqinhao.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-09T14:00:15.511Z","updated":"2020-01-25T08:21:13.465Z","comments":true,"path":"archives/categories/技术/HP交换机配置.html","permalink":"https://imqinhao.cn/archives/categories/%E6%8A%80%E6%9C%AF/HP%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AE.html","excerpt":"","text":"HP交换机配置连接交换机的方法：本地连接： 使用配置线连接电脑 查看对应的端口（方法：计算机右键—-&gt;管理—-&gt;系统工具—-&gt;设备管理器—-&gt;端口，查看对应的端口） 打开CRT软件,选择快速连接 弹出的窗口中选择一下配置： 12345协议：Serial端口：COM XX (选择上面查到的端口号)波特率：9600流控：全部不选择其它不需要修改，点击连接即可 远程连接 win + ｒ 输入cmd，回车运行。 远程功能的语法： 1telnet IP地址 输入用户名和密码登录远程交换机 12Username：此处输入用户名Password：此处输入密码 配置命令1.进入管理员模式，默认登录是游客登录，需要使用命令进入管理员模式进行更多操作。#代表进入了管理员模式 1enable 2.进入全局模式。只有进入了全局模式，我们才可以对交换机的配置进行修改。 1configure 3.更换交换机的名称： 1hostname 需要更换的名称 4.重启交换机： 1reload 5.设置交换机远程登录的用户名以及密码： 1设置用户名语法：password manager username 设置的远程登录用户名 6.保存配置命令： 1write memory 7.添加vlan。前提是进入了配置模式。 1vlan 端口号 8.配置管理IP，vlan 2000是管理vlan。 ​ 家属区、西区宿舍区以及办公区：10.10.102段 ​ 东区学生区多为：10.10.101段 ​ vlan一般设置了untagged就必须设置对应的tagged口，否则会出现无法正常通信等故障。 12vlan 2000ip address IP地址 9.查看交换机的配置。既然添加了配置，我们就需要查看配置，看看我们是否添加成功。 1show run 10.静态路由。配置交换机一定要配置静态路由，否则会造成无法远程等故障。 1ip route IP地址 11.修改支持的默认vlan数，修改后需要重启才可使用： 1max-vlans 数字 12.查看端口的连接情况： 1show interface brief 13.tagged与untagged。交换机连接电脑的端口设置为untagged端口，交换机与交换机之间的端口设为tagged端口。设置untagged与tagged需要进入vlan里面进行配置。 1练习：A交换机的25号口上面接的是B交换机(汇聚)的13号口，我应该怎么配置才能保证可以上网呢？ 14.端口隔离。端口隔离是为了实现报文之间的二层隔离，可以将不同的端口加入不同的VLAN，但会浪费有限的VLAN资源。采用端口隔离特性，可以实现同一VLAN内端口之间的隔离。用户只需要将端口加入到隔离组中，就可以实现隔离组内端口之间二层数据的隔离。端口隔离功能为用户提供了更安全、更灵活的组网方案。 1filter source-port &quot;端口号&quot; drop 隔离的端口号 15.查看邻居： 1show lldp info remote-device 16.删除vlan 1no vlan [vlan号码] 17.清空交换机配置： 1erase startup-config"}],"posts":[{"title":"XML基础","slug":"xml","date":"2021-07-14T04:50:11.000Z","updated":"2021-07-17T05:54:24.205Z","comments":true,"path":"2021/07/14/xml/","link":"","permalink":"https://imqinhao.cn/2021/07/14/xml/","excerpt":"概念 语法 解析","text":"概念 语法 解析 XML概念 Extensible Markup Language 可扩展标记语言 可扩展：标签都是自定义的。 XML功能 存储数据 配置文件 在网络中传输 xml与html的区别 xml标签都是自定义的，html标签是预定义。 xml的语法严格，html语法松散 xml是存储数据的，html是展示数据 XML语法基本语法 xml文档的后缀名 .xml xml第一行必须定义为文档声明 xml文档中有且仅有一个根标签 属性值必须使用引号(单双都可)引起来 标签必须正确关闭 xml标签名称区分大小写 快速入门123456789101112131415&lt;?xml version='1.0' ?&gt;&lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt;&lt;/users&gt; 组成部分文档声明格式属性列表指令标签属性文本1&lt;?xml 属性列表 ?&gt; version：版本号，必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 standalone：是否独立 取值： yes：不依赖其他文件 no：依赖其他文件 结合css的 1&lt;?xml-stylesheet type=\"text/css\" href=\"a.css\" ?&gt; 标签名称自定义的 规则 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 id属性值唯一CDATA区：在该区域中的数据会被原样展示 1&lt;![CDATA[ 数据 ]]&gt; 约束 规定xml文档的书写规则 分类 DTD:一种简单的约束技术 内部dtd：将约束规则定义在xml文档中 外部dtd：将约束的规则定义在外部的dtd文件中 12本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; Schema:一种复杂的约束技术 1.填写xml文档的根元素 2.引入xsi前缀. xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 3.引入xsd文件命名空间. xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 4.为每一个xsd约束声明一个前缀,作为标识 xmlns=&quot;http://www.itcast.cn/xml&quot; &lt;students xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.imqinhao.cn/xml&quot; xsi:schemaLocation=&quot;http://www.imqinhao.cn/xml student.xsd&quot;&gt;解析XML操作xml文档，将文档中的数据读取到内存中 操作xml文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式DOM将标记语言文档一次性加载进内存，在内存中形成一颗dom树 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 SAX逐行读取，基于事件驱动的。 优点：不占内存。 缺点：只能读取，不能增删改 ​ xml常见的解析器 JAXP sun公司提供的解析器，支持dom和sax两种思想 DOM4J 一款非常优秀的解析器 Jsoup jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL Android操作系统内置的解析器，sax方式的。 Jsoup jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 第一步 导入jar包 第二步 获取Document对象 第三步 获取对应的标签Element对象 第四步 获取数据 12345678910111213//2.1获取student.xml的path String path = JsoupDemo1.class.getClassLoader().getResource(\"student.xml\").getPath(); //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document Document document = Jsoup.parse(new File(path), \"utf-8\"); //3.获取元素对象 Element Elements elements = document.getElementsByTag(\"name\"); System.out.println(elements.size()); //3.1获取第一个name的Element对象 Element element = elements.get(0); //3.2获取数据 String name = element.text(); System.out.println(name); 对象的使用 parse：解析html或xml文档，返回Document parse​(File in, String charsetName)：解析xml或html文件的。parse​(String html)：解析xml或html字符串parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 获取Element对象 getElementById​(String id)：根据id属性值获取唯一的element对象getElementsByTag​(String tagName)：根据标签名称获取元素对象集合getElementsByAttribute​(String key)：根据属性名称获取元素对象集合getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 Elements 元素Element对象的集合。可以当做 ArrayList来使用 Element：元素对象 获取子元素对象getElementById​(String id)：根据id属性值获取唯一的element对象getElementsByTag​(String tagName)：根据标签名称获取元素对象集合getElementsByAttribute​(String key)：根据属性名称获取元素对象集合getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合获取属性值String attr(String key)：根据属性名称获取属性值获取文本内容String text():获取文本内容String html():获取标签体的所有内容(包括字标签的字符串内容) Node：节点对象 是Document和Element的父类 快捷查询方式selector选择器 使用的方法：Elements select​(String cssQuery) XPath XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言","categories":[{"name":"Java","slug":"Java","permalink":"https://imqinhao.cn/categories/Java/"}],"tags":[]},{"title":"JDBC连接池&JDBCTemplate","slug":"JDBCTemplate","date":"2021-07-12T09:50:11.000Z","updated":"2021-07-17T02:42:33.477Z","comments":true,"path":"2021/07/12/JDBCTemplate/","link":"","permalink":"https://imqinhao.cn/2021/07/12/JDBCTemplate/","excerpt":"数据库连接池 Spring JDBC : JDBC Template","text":"数据库连接池 Spring JDBC : JDBC Template 数据库连接池1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 2. 好处： 1. 节约资源 2. 用户访问高效 3. 实现： 1. 标准接口：DataSource javax.sql包下的 1. 方法： * 获取连接：getConnection() * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 2. 一般我们不去实现它，有数据库厂商来实现 1. C3P0：数据库连接池技术 2. Druid：数据库连接池实现技术，由阿里巴巴提供的 4. C3P0：数据库连接池技术 * 步骤： 1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， * 不要忘记导入数据库驱动jar包 2. 定义配置文件： * 名称： c3p0.properties 或者 c3p0-config.xml * 路径：直接将文件放在src目录下即可。 3. 创建核心对象 数据库连接池对象 ComboPooledDataSource 4. 获取连接： getConnection * 代码： //1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); 5. Druid：数据库连接池实现技术，由阿里巴巴提供的 1. 步骤： 1. 导入jar包 druid-1.0.9.jar 2. 定义配置文件： * 是properties形式的 * 可以叫任意名称，可以放在任意目录下 3. 加载配置文件。Properties 4. 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 5. 获取连接：getConnection * 代码： //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); 2. 定义工具类 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 1. 获取连接方法：通过数据库连接池获取连接 2. 释放资源 3. 获取连接池的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 代码：public class JDBCUtils &#123; //1.定义成员变量 DataSource private static DataSource ds ; static&#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\")); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; /** * 释放资源 */ public static void close(Statement stmt,Connection conn)&#123; /* if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;*/ close(null,stmt,conn); &#125; public static void close(ResultSet rs , Statement stmt, Connection conn)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 获取连接池方法 */ public static DataSource getDataSource()&#123; return ds; &#125;&#125; Spring JDBC* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 * 步骤： 1. 导入jar包 2. 创建JdbcTemplate对象。依赖于数据源DataSource * JdbcTemplate template = new JdbcTemplate(ds); 3. 调用JdbcTemplate的方法来完成CRUD的操作 * update():执行DML语句。增、删、改语句 * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 * 注意：这个方法查询的结果集长度只能是1 * queryForList():查询结果将结果集封装为list集合 * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 * query():查询结果，将结果封装为JavaBean对象 * query的参数：RowMapper * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 * new BeanPropertyRowMapper&lt;类型&gt;(类型.class) * queryForObject：查询结果，将结果封装为对象 * 一般用于聚合函数的查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152// 4. 练习：/* 需求： 1. 修改1号数据的 salary 为 10000 2. 添加一条记录 3. 删除刚才添加的记录 4. 查询id为1的记录，将其封装为Map集合 5. 查询所有记录，将其封装为List 6. 查询所有记录，将其封装为Emp对象的List集合 7. 查询总记录数*/import cn.itcast.domain.Emp;import cn.itcast.utils.JDBCUtils;import org.junit.Test;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import java.sql.Date;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;import java.util.Map;public class JdbcTemplateDemo2 &#123; //Junit单元测试，可以让方法独立执行 //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1()&#123; //2. 定义sql String sql = \"update emp set salary = 10000 where id = 1001\"; //3. 执行sql int count = template.update(sql); System.out.println(count); &#125; /** * 2. 添加一条记录 */ @Test public void test2()&#123; String sql = \"insert into emp(id,ename,dept_id) values(?,?,?)\"; int count = template.update(sql, 1015, \"郭靖\", 10); System.out.println(count); &#125; /** * 3.删除刚才添加的记录 */ @Test public void test3()&#123; String sql = \"delete from emp where id = ?\"; int count = template.update(sql, 1015); System.out.println(count); &#125; /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4()&#123; String sql = \"select * from emp where id = ? or id = ?\"; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125; &#125; /** * 5. 查询所有记录，将其封装为List */ @Test public void test5()&#123; String sql = \"select * from emp\"; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6()&#123; String sql = \"select * from emp\"; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123; @Override public Emp mapRow(ResultSet rs, int i) throws SQLException &#123; Emp emp = new Emp(); int id = rs.getInt(\"id\"); String ename = rs.getString(\"ename\"); int job_id = rs.getInt(\"job_id\"); int mgr = rs.getInt(\"mgr\"); Date joindate = rs.getDate(\"joindate\"); double salary = rs.getDouble(\"salary\"); double bonus = rs.getDouble(\"bonus\"); int dept_id = rs.getInt(\"dept_id\"); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; &#125; &#125;); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2()&#123; String sql = \"select * from emp\"; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 7. 查询总记录数 */ @Test public void test7()&#123; String sql = \"select count(id) from emp\"; Long total = template.queryForObject(sql, Long.class); System.out.println(total); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://imqinhao.cn/categories/Java/"}],"tags":[]},{"title":"JDBC","slug":"JDBC","date":"2021-07-12T04:50:11.000Z","updated":"2021-07-17T02:42:08.929Z","comments":true,"path":"2021/07/12/JDBC/","link":"","permalink":"https://imqinhao.cn/2021/07/12/JDBC/","excerpt":"JDBC基本概念 快速入门 对JDBC中各个接口和类详解","text":"JDBC基本概念 快速入门 对JDBC中各个接口和类详解 JDBC：1. 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 2. 快速入门： * 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2.右键--&gt;Add As Library 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql 5. 获取执行sql语句的对象 Statement 6. 执行sql，接受返回结果 7. 处理结果 8. 释放资源 * 代码实现： //1. 导入驱动jar包 //2.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;); //4.定义sql语句 String sql = &quot;update account set balance = 500 where id = 1&quot;; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); 3. 详解各个对象： 1. DriverManager：驱动管理对象 * 功能： 1. 注册驱动：告诉程序该使用哪一个数据库驱动jar static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); } } 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 2. 获取数据库连接： * 方法：static Connection getConnection(String url, String user, String password) * 参数： * url：指定连接的路径 * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 * 例子：jdbc:mysql://localhost:3306/db3 * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 * user：用户名 * password：密码 2. Connection：数据库连接对象 1. 功能： 1. 获取执行sql 的对象 * Statement createStatement() * PreparedStatement prepareStatement(String sql) 2. 管理事务： * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 提交事务：commit() * 回滚事务：rollback() 3. Statement：执行sql的对象 1. 执行sql 1. boolean execute(String sql) ：可以执行任意的sql 了解 2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 3. ResultSet executeQuery(String sql) ：执行DQL（select)语句 2. 练习： 1. account表 添加一条记录 2. account表 修改记录 3. account表 删除一条记录 代码： Statement stmt = null; Connection conn = null; try { //1. 注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 定义sql String sql = &quot;insert into account values(null,&apos;王五&apos;,3000)&quot;; //3.获取Connection对象 conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;); //4.获取执行sql的对象 Statement stmt = conn.createStatement(); //5.执行sql int count = stmt.executeUpdate(sql);//影响的行数 //6.处理结果 System.out.println(count); if(count &gt; 0){ System.out.println(&quot;添加成功！&quot;); }else{ System.out.println(&quot;添加失败！&quot;); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); }finally { //stmt.close(); //7. 释放资源 //避免空指针异常 if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } 4. ResultSet：结果集对象,封装查询结果 * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true * getXxx(参数):获取数据 * Xxx：代表数据类型 如： int getInt() , String getString() * 参数： 1. int：代表列的编号,从1开始 如： getString(1) 2. String：代表列名称。 如： getDouble(&quot;balance&quot;) * 注意： * 使用步骤： 1. 游标向下移动一行 2. 判断是否有数据 3. 获取数据 //循环判断游标是否是最后一行末尾。 while(rs.next()){ //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(&quot;name&quot;); double balance = rs.getDouble(3); System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance); } * 练习： * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。 1. 定义Emp类 2. 定义方法 public List&lt;Emp&gt; findAll(){} 3. 实现方法 select * from emp; 5. PreparedStatement：执行sql的对象 1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 1. 输入用户随便，输入密码：a&apos; or &apos;a&apos; = &apos;a 2. sql：select * from user where username = &apos;fhdsjkf&apos; and password = &apos;a&apos; or &apos;a&apos; = &apos;a&apos; 2. 解决sql注入问题：使用PreparedStatement对象来解决 3. 预编译的SQL：参数使用?作为占位符 4. 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 5. 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 6. 给？赋值： * 方法： setXxx(参数1,参数2) * 参数1：？的位置编号 从1 开始 * 参数2：？的值 7. 执行sql，接受返回结果，不需要传递sql语句 8. 处理结果 9. 释放资源 5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作 1. 可以防止SQL注入 2. 效率更高抽取JDBC工具类 ： JDBCUtils* 目的：简化书写 * 分析： 1. 注册驱动也抽取 2. 抽取一个方法获取连接对象 * 需求：不想传递参数（麻烦），还得保证工具类的通用性。 * 解决：配置文件 jdbc.properties url= user= password= 3. 抽取一个方法释放资源 * 代码实现： public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static{ //读取资源文件，获取值。 try { //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(&quot;jdbc.properties&quot;); String path = res.getPath(); System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties //2. 加载文件 // pro.load(new FileReader(&quot;D:\\\\IdeaProjects\\\\itcast\\\\day04_jdbc\\\\src\\\\jdbc.properties&quot;)); pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty(&quot;url&quot;); user = pro.getProperty(&quot;user&quot;); password = pro.getProperty(&quot;password&quot;); driver = pro.getProperty(&quot;driver&quot;); //4. 注册驱动 Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url, user, password); } /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt,Connection conn){ if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } /** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn){ if( rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } * 练习： * 需求： 1. 通过键盘录入用户名和密码 2. 判断用户是否登录成功 * select * from user where username = &quot;&quot; and password = &quot;&quot;; * 如果这个sql有查询结果，则成功，反之，则失败 * 步骤： 1. 创建数据库表 user CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32), PASSWORD VARCHAR(32) ); INSERT INTO USER VALUES(NULL,&apos;zhangsan&apos;,&apos;123&apos;); INSERT INTO USER VALUES(NULL,&apos;lisi&apos;,&apos;234&apos;); 2. 代码实现： public class JDBCDemo9 { public static void main(String[] args) { //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名：&quot;); String username = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String password = sc.nextLine(); //2.调用方法 boolean flag = new JDBCDemo9().login(username, password); //3.判断结果，输出不同语句 if(flag){ //登录成功 System.out.println(&quot;登录成功！&quot;); }else{ System.out.println(&quot;用户名或密码错误！&quot;); } } /* * 登录方法 */ public boolean login(String username ,String password){ if(username == null || password == null){ return false; } //连接数据库判断是否登录成功 Connection conn = null; Statement stmt = null; ResultSet rs = null; //1.获取连接 try { conn = JDBCUtils.getConnection(); //2.定义sql String sql = &quot;select * from user where username = &apos;&quot;+username+&quot;&apos; and password = &apos;&quot;+password+&quot;&apos; &quot;; //3.获取执行sql的对象 stmt = conn.createStatement(); //4.执行查询 rs = stmt.executeQuery(sql); //5.判断 /* if(rs.next()){//如果有下一行，则返回true return true; }else{ return false; }*/ return rs.next();//如果有下一行，则返回true } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,stmt,conn); } return false; } } JDBC控制事务：1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 2. 操作： 1. 开启事务 2. 提交事务 3. 回滚事务 3. 使用Connection对象来管理事务 * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 在执行sql之前开启事务 * 提交事务：commit() * 当所有sql都执行完提交事务 * 回滚事务：rollback() * 在catch中回滚事务 4. 代码： public class JDBCDemo10 { public static void main(String[] args) { Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //2.定义sql //2.1 张三 - 500 String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;; //2.2 李四 + 500 String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;; //3.获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); } catch (Exception e) { //事务回滚 try { if(conn != null) { conn.rollback(); } } catch (SQLException e1) { e1.printStackTrace(); } e.printStackTrace(); }finally { JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); } } }​","categories":[{"name":"Java","slug":"Java","permalink":"https://imqinhao.cn/categories/Java/"}],"tags":[]},{"title":"MySQL多表&事务","slug":"MySQL_transaction","date":"2021-07-11T12:50:11.000Z","updated":"2021-07-17T02:45:27.456Z","comments":true,"path":"2021/07/11/MySQL_transaction/","link":"","permalink":"https://imqinhao.cn/2021/07/11/MySQL_transaction/","excerpt":"多表查询 事务 DCL","text":"多表查询 事务 DCL 多表查询* 查询语法： select 列名列表 from 表名列表 where.... * 准备sql # 创建部门表 CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); INSERT INTO dept (NAME) VALUES (&apos;开发部&apos;),(&apos;市场部&apos;),(&apos;财务部&apos;); # 创建员工表 CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键) ); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;孙悟空&apos;,&apos;男&apos;,7200,&apos;2013-02-24&apos;,1); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;猪八戒&apos;,&apos;男&apos;,3600,&apos;2010-12-02&apos;,2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;唐僧&apos;,&apos;男&apos;,9000,&apos;2008-08-08&apos;,2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;白骨精&apos;,&apos;女&apos;,5000,&apos;2015-10-07&apos;,3); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;蜘蛛精&apos;,&apos;女&apos;,4500,&apos;2011-03-14&apos;,1); * 笛卡尔积： * 有两个集合A,B .取这两个集合的所有组成情况。 * 要完成多表查询，需要消除无用的数据 * 多表查询的分类： 1. 内连接查询： 1. 隐式内连接：使用where条件消除无用数据 * 例子： -- 查询所有员工信息和对应的部门信息 SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`; -- 查询员工表的名称，性别。部门表的名称 SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`; SELECT t1.name, -- 员工表的姓名 t1.gender,-- 员工表的性别 t2.name -- 部门表的名称 FROM emp t1, dept t2 WHERE t1.`dept_id` = t2.`id`; 2. 显式内连接： * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 * 例如： * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`; * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; 3. 内连接查询： 1. 从哪些表中查询数据 2. 条件是什么 3. 查询哪些字段 2. 外链接查询： 1. 左外连接： * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； * 查询的是左表所有数据以及其交集部分。 * 例子： -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称 SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 2. 右外连接： * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； * 查询的是右表所有数据以及其交集部分。 * 例子： SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; 3. 子查询： * 概念：查询中嵌套查询，称嵌套查询为子查询。 -- 查询工资最高的员工信息 -- 1 查询最高的工资是多少 9000 SELECT MAX(salary) FROM emp; -- 2 查询员工信息，并且工资等于9000的 SELECT * FROM emp WHERE emp.`salary` = 9000; -- 一条sql就完成这个操作。子查询 SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp); * 子查询不同情况 1. 子查询的结果是单行单列的： * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= = * -- 查询员工工资小于平均工资的人 SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp); 2. 子查询的结果是多行单列的： * 子查询可以作为条件，使用运算符in来判断 -- 查询&apos;财务部&apos;和&apos;市场部&apos;所有的员工信息 SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;; SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2; -- 子查询 SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;); 3. 子查询的结果是多行多列的： * 子查询可以作为一张虚拟表参与查询 -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息 -- 子查询 SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &apos;2011-11-11&apos;) t2 WHERE t1.id = t2.dept_id; -- 普通内连接 SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; &apos;2011-11-11&apos;​​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071* 多表查询练习 -- 部门表 CREATE TABLE dept ( id INT PRIMARY KEY PRIMARY KEY, -- 部门id dname VARCHAR(50), -- 部门名称 loc VARCHAR(50) -- 部门所在地 ); -- 添加4个部门 INSERT INTO dept(id,dname,loc) VALUES (10,'教研部','北京'), (20,'学工部','上海'), (30,'销售部','广州'), (40,'财务部','深圳'); -- 职务表，职务名称，职务描述 CREATE TABLE job ( id INT PRIMARY KEY, jname VARCHAR(20), description VARCHAR(50) ); -- 添加4个职务 INSERT INTO job (id, jname, description) VALUES (1, '董事长', '管理整个公司，接单'), (2, '经理', '管理部门员工'), (3, '销售员', '向客人推销产品'), (4, '文员', '使用办公软件'); -- 员工表 CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT, -- 所在部门编号 CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id), CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id) ); -- 添加员工 INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20), (1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30), (1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30), (1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20), (1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30), (1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30), (1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10), (1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20), (1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10), (1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30), (1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20), (1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30), (1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20), (1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10); -- 工资等级表 CREATE TABLE salarygrade ( grade INT PRIMARY KEY, -- 级别 losalary INT, -- 最低工资 hisalary INT -- 最高工资 ); -- 添加5个工资等级 INSERT INTO salarygrade(grade,losalary,hisalary) VALUES (1,7000,12000), (2,12010,14000), (3,14010,20000), (4,20010,30000), (5,30010,99990); 12345678910111213141516171819-- 需求： -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述 /* 分析： 1.员工编号，员工姓名，工资，需要查询emp表 职务名称，职务描述 需要查询job表 2.查询条件 emp.job_id = job.id */ SELECT t1.`id`, -- 员工编号 t1.`ename`, -- 员工姓名 t1.`salary`,-- 工资 t2.`jname`, -- 职务名称 t2.`description` -- 职务描述 FROM emp t1, job t2 WHERE t1.`job_id` = t2.`id`; 12345678910111213141516171819-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置 /* 分析： 1. 员工编号，员工姓名，工资 emp 职务名称，职务描述 job 部门名称，部门位置 dept 2. 条件： emp.job_id = job.id and emp.dept_id = dept.id */ SELECT t1.`id`, -- 员工编号 t1.`ename`, -- 员工姓名 t1.`salary`,-- 工资 t2.`jname`, -- 职务名称 t2.`description`, -- 职务描述 t3.`dname`, -- 部门名称 t3.`loc` -- 部门位置 FROM emp t1, job t2,dept t3 WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`; 12345678910111213-- 3.查询员工姓名，工资，工资等级 /* 分析： 1.员工姓名，工资 emp 工资等级 salarygrade 2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary */ SELECT t1.ename , t1.`salary`, t2.* FROM emp t1, salarygrade t2 WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`; 123456789101112131415161718192021-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级/* 分析： 1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept 工资等级 salarygrade 2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary */SELECT t1.`ename`, t1.`salary`, t2.`jname`, t2.`description`, t3.`dname`, t3.`loc`, t4.`grade`FROM emp t1,job t2,dept t3,salarygrade t4WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id` AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`; 12345678910111213141516171819-- 5.查询出部门编号、部门名称、部门位置、部门人数/* 分析： 1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表 2.使用分组查询。按照emp.dept_id完成分组，查询count(id) 3.使用子查询将第2步的查询结果和dept表进行关联查询 */SELECT t1.`id`,t1.`dname`,t1.`loc` , t2.totalFROM dept t1, (SELECT dept_id,COUNT(id) total FROM emp GROUP BY dept_id) t2WHERE t1.`id` = t2.dept_id; 123456789101112131415161718192021222324252627282930-- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询/* 分析： 1.姓名 emp， 直接上级的姓名 emp * emp表的id 和 mgr 是自关联 2.条件 emp.id = emp.mgr 3.查询左表的所有数据，和 交集数据 * 使用左外连接查询 *//*select t1.ename, t1.mgr, t2.`id`, t2.enamefrom emp t1, emp t2where t1.mgr = t2.`id`;*/SELECT t1.ename, t1.mgr, t2.`id`, t2.`ename`FROM emp t1LEFT JOIN emp t2ON t1.`mgr` = t2.`id`; 事务123456789101112131415161718192021222324252627282930313233343536373839404142434445461. 事务的基本介绍 1. 概念： * 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 2. 操作： 1. 开启事务： start transaction; 2. 回滚：rollback; 3. 提交：commit; 3. 例子： CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE ); -- 添加数据 INSERT INTO account (NAME, balance) VALUES ('zhangsan', 1000), ('lisi', 1000); SELECT * FROM account; UPDATE account SET balance = 1000; -- 张三给李四转账 500 元 -- 0. 开启事务 START TRANSACTION; -- 1. 张三账户 -500 UPDATE account SET balance = balance - 500 WHERE NAME = 'zhangsan'; -- 2. 李四账户 +500 -- 出错了... UPDATE account SET balance = balance + 500 WHERE NAME = 'lisi'; -- 发现执行没有问题，提交事务 COMMIT; -- 发现出问题了，回滚事务 ROLLBACK; 4. MySQL数据库中事务默认自动提交 * 事务提交的两种方式： * 自动提交： * mysql就是自动提交的 * 一条DML(增删改)语句会自动提交一次事务。 * 手动提交： * Oracle 数据库默认是手动提交事务 * 需要先开启事务，再提交 * 修改事务的默认提交方式： * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交 * 修改默认提交方式： set @@autocommit = 0; 2. 事务的四大特征： 1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 3. 隔离性：多个事务之间。相互独立。 4. 一致性：事务操作前后，数据总量不变 3. 事务的隔离级别（了解） * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 * 存在问题： 1. 脏读：一个事务，读取到另一个事务中没有提交的数据 2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 * 隔离级别： 1. read uncommitted：读未提交 * 产生的问题：脏读、不可重复读、幻读 2. read committed：读已提交 （Oracle） * 产生的问题：不可重复读、幻读 3. repeatable read：可重复读 （MySQL默认） * 产生的问题：幻读 4. serializable：串行化 * 可以解决所有的问题 * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 * 数据库查询隔离级别： * select @@tx_isolation; * 数据库设置隔离级别： * set global transaction isolation level 级别字符串; * 演示： set global transaction isolation level read uncommitted; start transaction; -- 转账操作 update account set balance = balance - 500 where id = 1; update account set balance = balance + 500 where id = 2;DCL* SQL分类： 1. DDL：操作数据库和表 2. DML：增删改表中数据 3. DQL：查询表中数据 4. DCL：管理用户，授权 * DBA：数据库管理员 * DCL：管理用户，授权 1. 管理用户 1. 添加用户： * 语法：CREATE USER &apos;用户名&apos;@&apos;主机名&apos; IDENTIFIED BY &apos;密码&apos;; 2. 删除用户： * 语法：DROP USER &apos;用户名&apos;@&apos;主机名&apos;; 3. 修改用户密码： UPDATE USER SET PASSWORD = PASSWORD(&apos;新密码&apos;) WHERE USER = &apos;用户名&apos;; UPDATE USER SET PASSWORD = PASSWORD(&apos;abc&apos;) WHERE USER = &apos;lisi&apos;; SET PASSWORD FOR &apos;用户名&apos;@&apos;主机名&apos; = PASSWORD(&apos;新密码&apos;); SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123&apos;); * mysql中忘记了root用户的密码？ 1. cmd -- &gt; net stop mysql 停止mysql服务 * 需要管理员运行该cmd 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 4. use mysql; 5. update user set password = password(&apos;你的新密码&apos;) where user = &apos;root&apos;; 6. 关闭两个窗口 7. 打开任务管理器，手动结束mysqld.exe 的进程 8. 启动mysql服务 9. 使用新密码登录。 4. 查询用户： -- 1. 切换到mysql数据库 USE myql; -- 2. 查询user表 SELECT * FROM USER; * 通配符： % 表示可以在任意主机使用用户登录数据库 2. 权限管理： 1. 查询权限： -- 查询权限 SHOW GRANTS FOR &apos;用户名&apos;@&apos;主机名&apos;; SHOW GRANTS FOR &apos;lisi&apos;@&apos;%&apos;; 2. 授予权限： -- 授予权限 grant 权限列表 on 数据库名.表名 to &apos;用户名&apos;@&apos;主机名&apos;; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO &apos;zhangsan&apos;@&apos;localhost&apos;; 3. 撤销权限： -- 撤销权限： revoke 权限列表 on 数据库名.表名 from &apos;用户名&apos;@&apos;主机名&apos;; REVOKE UPDATE ON db3.`account` FROM &apos;lisi&apos;@&apos;%&apos;;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://imqinhao.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"MySQL约束","slug":"MySQL_constraint","date":"2021-07-11T08:50:11.000Z","updated":"2021-07-17T02:44:40.790Z","comments":true,"path":"2021/07/11/MySQL_constraint/","link":"","permalink":"https://imqinhao.cn/2021/07/11/MySQL_constraint/","excerpt":"DQL:查询语句 排序查询 聚合函数 分组查询 分页查询 约束 多表之间的关系 范式 数据库的备份和还原","text":"DQL:查询语句 排序查询 聚合函数 分组查询 分页查询 约束 多表之间的关系 范式 数据库的备份和还原 DQL:查询语句1. 排序查询 * 语法：order by 子句 * order by 排序字段1 排序方式1 ， 排序字段2 排序方式2... * 排序方式： * ASC：升序，默认的。 * DESC：降序。 * 注意： * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。 1. count：计算个数 1. 一般选择非空的列：主键 2. count(*) 2. max：计算最大值 3. min：计算最小值 4. sum：计算和 5. avg：计算平均值 * 注意：聚合函数的计算，排除null值。 解决方案： 1. 选择不包含非空的列进行计算 2. IFNULL函数 3. 分组查询: 1. 语法：group by 分组字段； 2. 注意： 1. 分组之后查询的字段：分组字段、聚合函数 2. where 和 having 的区别？ 1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。 -- 按照性别分组。分别查询男、女同学的平均分 SELECT sex , AVG(math) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2; SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 4. 分页查询 1. 语法：limit 开始的索引,每页查询的条数; 2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 3. limit 是一个MySQL&quot;方言&quot;约束* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。 * 分类： 1. 主键约束：primary key 2. 非空约束：not null 3. 唯一约束：unique 4. 外键约束：foreign key * 非空约束：not null，值不能为null 1. 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); 2. 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); * 唯一约束：unique，值不能重复 1. 创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束 ); * 注意mysql中，唯一约束限定的列的值可以有多个null 2. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 3. 在创建表后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE; * 主键约束：primary key。 1. 注意： 1. 含义：非空且唯一 2. 一张表只能有一个字段为主键 3. 主键就是表中记录的唯一标识 2. 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); 3. 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; 4. 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; 5. 自动增长： 1. 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 2. 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); 3. 删除自动增长 ALTER TABLE stu MODIFY id INT; 4. 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; * 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。 1. 在创建表时，可以添加外键 * 语法： create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 2. 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 3. 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 4. 级联操作 1. 添加级联操作 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ; 2. 分类： 1. 级联更新：ON UPDATE CASCADE 2. 级联删除：ON DELETE CASCADE 数据库的设计1. 多表之间的关系 1. 分类： 1. 一对一(了解)： * 如：人和身份证 * 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： * 如：部门和员工 * 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： * 如：学生和课程 * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： * 如：部门和员工 * 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： * 如：学生和课程 * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： * 如：人和身份证 * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 3. 案例 -- 创建旅游线路分类表 tab_category -- cid 旅游线路分类主键，自动增长 -- cname 旅游线路分类名称非空，唯一，字符串 100 CREATE TABLE tab_category ( cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(100) NOT NULL UNIQUE ); -- 创建旅游线路表 tab_route /* rid 旅游线路主键，自动增长 rname 旅游线路名称非空，唯一，字符串 100 price 价格 rdate 上架时间，日期类型 cid 外键，所属分类 */ CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, rname VARCHAR(100) NOT NULL UNIQUE, price DOUBLE, rdate DATE, cid INT, FOREIGN KEY (cid) REFERENCES tab_category(cid) ); /*创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100 */ CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT &apos;男&apos;, telephone VARCHAR(11), email VARCHAR(100) ); /* 创建收藏表 tab_favorite rid 旅游线路 id，外键 date 收藏时间 uid 用户 id，外键 rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次 */ CREATE TABLE tab_favorite ( rid INT, -- 线路id DATE DATETIME, uid INT, -- 用户id -- 创建复合主键 PRIMARY KEY(rid,uid), -- 联合主键 FOREIGN KEY (rid) REFERENCES tab_route(rid), FOREIGN KEY(uid) REFERENCES tab_user(uid) ); 2. 数据库设计的范式 * 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 * 分类： 1. 第一范式（1NF）：每一列都是不可分割的原子数据项 2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） * 几个概念： 1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号--&gt;姓名。 （学号，课程名称） --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） --&gt; 分数 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） -- &gt; 姓名 4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） * 主属性：码属性组中的所有属性 * 非主属性：除过码属性组的属性 3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）数据库的备份和还原1. 命令行： * 语法： * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 * 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径 2. 图形化工具：","categories":[{"name":"数据库","slug":"数据库","permalink":"https://imqinhao.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"MySQL基础","slug":"MySQL","date":"2021-07-11T04:50:11.000Z","updated":"2021-07-17T02:44:27.716Z","comments":true,"path":"2021/07/11/MySQL/","link":"","permalink":"https://imqinhao.cn/2021/07/11/MySQL/","excerpt":"数据库的基本概念 MySQL数据库软件 安装 卸载 配置 SQL","text":"数据库的基本概念 MySQL数据库软件 安装 卸载 配置 SQL 数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB 2. 什么数据库？ * 用于存储和管理数据的仓库。 3. 数据库的特点： 1. 持久化存储数据的。其实数据库就是一个文件系统 2. 方便存储和管理数据 3. 使用了统一的方式操作数据库 -- SQLSQL分类 MySQL数据库、表、数据的关系 SQL1.什么是SQL？ Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 2.SQL通用语法 1. SQL 语句可以单行或多行书写，以分号结尾。 2. 可使用空格和缩进来增强语句的可读性。 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 4. 3 种注释 * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) * 多行注释: /* 注释 */ 3. SQL分类 1) DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 2) DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 3) DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 4) DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等DDL:操作数据库、表1. 操作数据库：CRUD 1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集:查询某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 2. 操作表 1. C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名; 3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名; 4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ; 客户端图形化工具：SQLYog DML：增删改表中数据1. 添加数据： * 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); * 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2. 删除数据： * 语法： * delete from 表名 [where 条件] * 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3. 修改数据： * 语法： * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。DQL：查询表中的记录* select * from 表名; 1. 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 2. 基础查询 1. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表。 2. 去除重复： * distinct 3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。 4. 起别名： * as：as也可以省略 3. 条件查询 1. where子句后跟条件 2. 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE &apos;___&apos;; -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;;​","categories":[{"name":"数据库","slug":"数据库","permalink":"https://imqinhao.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"JDBC - SQL注入问题","slug":"JDBC_SQL_injection","date":"2021-07-10T04:50:11.000Z","updated":"2021-07-17T02:42:22.460Z","comments":true,"path":"2021/07/10/JDBC_SQL_injection/","link":"","permalink":"https://imqinhao.cn/2021/07/10/JDBC_SQL_injection/","excerpt":"使用Statement创建的对象会有SQL注入风险，使用preparedStatement代替即可解决。","text":"使用Statement创建的对象会有SQL注入风险，使用preparedStatement代替即可解决。 创建JDBCUtils类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package cn.imqinhao.util;import java.io.FileReader;import java.io.IOException;import java.net.URL;import java.sql.*;import java.util.Properties;public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; static &#123; try &#123; // 1.创建Properties集合类 Properties properties = new Properties(); // 获取src路径下的文件的方式 ---&gt; ClassLoader类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL resource = classLoader.getResource(\"env.properties\"); String path = resource.getPath(); // 2.加载文件 properties.load(new FileReader(path)); // 3.获取数据，赋值 url = properties.getProperty(\"url\"); user = properties.getProperty(\"user\"); password = properties.getProperty(\"password\"); driver = properties.getProperty(\"driver\"); Class.forName(url); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; // 获取连接对象 public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, password); &#125; // 关闭资源 public static void close(Statement statement, Connection connection) &#123; if(statement != null) &#123; try &#123; // 关闭sql执行对象 statement.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if(connection != null) &#123; try &#123; // 关闭连接对象 connection.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125; // 关闭资源（重载） public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123; if(resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if(statement != null) &#123; try &#123; statement.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if(connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125;&#125; 编写主要代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.imqinhao.jdbc;import cn.imqinhao.util.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Scanner;public class JDBCDemo10 &#123; public static void main(String[] args) &#123; boolean isSuccess = new JDBCDemo10().login(); new JDBCDemo10().isSuccess(isSuccess); &#125; // 用户登录 public boolean login() &#123; Scanner scanner = new Scanner(System.in); System.out.print(\"请输入用户名：\"); String username = scanner.nextLine(); System.out.print(\"请输入密码：\"); String password = scanner.nextLine(); Connection connection = null; Statement statement = null; ResultSet resultSet = null; try &#123; // 1.获取连接对象 connection = JDBCUtils.getConnection(); // 2.定义sql语句 String sql = \"select * from user where username = '\" + username + \"'and password = '\" + password + \"'\"; // 3.获取sql执行对象 statement = connection.createStatement(); // 4.执行sql resultSet = statement.executeQuery(sql);// if(resultSet.next()) &#123;// return true;// &#125; else &#123;// return false;// &#125; return resultSet.next(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; JDBCUtils.close(resultSet, statement, connection); &#125; return false; &#125; // 判断登录是否成功 public void isSuccess(boolean b) &#123; if(b) &#123; System.out.println(\"登录成功！\"); &#125; else &#123; System.out.println(\"账号或密码错误！\"); &#125; &#125;&#125; 运行结果 请输入用户名：qinhao 请输入密码：lareina520 登录成功！ SQL注入问题 请输入用户名：gjlkahgka 请输入密码：a’ or ‘a’ = ‘a 登录成功！ 解决方案解决方案是使用preparedStatement代替Statement。 修改后的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.imqinhao.jdbc;import cn.imqinhao.util.JDBCUtils;import com.mysql.cj.protocol.Resultset;import java.sql.*;import java.util.Scanner;public class JDBCDemo11 &#123; public static void main(String[] args) &#123; boolean isSuccess = new JDBCDemo11().login(username, password); if (isSuccess) &#123; System.out.println(\"登录成功！\"); &#125; else &#123; System.out.println(\"用户名或密码错误！\"); &#125; &#125; public boolean login() &#123; Scanner scanner = new Scanner(System.in); System.out.print(\"请输入用户名：\"); String username = scanner.nextLine(); System.out.print(\"请输入密码：\"); String password = scanner.nextLine(); Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultset = null; try &#123; // 1.获取连接对象 connection = JDBCUtils.getConnection(); // 2.定义sql String sql = \"select * from user where username = ? and password = ?\"; // 3.获取sql执行对象 preparedStatement = connection.prepareStatement(sql); // 4.给sql赋值 preparedStatement.setString(1, username); preparedStatement.setString(2, password); // 5.执行sql resultset = preparedStatement.executeQuery(); // 6.处理结果 return resultset.next(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; JDBCUtils.close(resultset, preparedStatement, connection); &#125; return false; &#125;&#125; 运行结果 请输入用户名：gjlkahgka 请输入密码：a’ or ‘a’ = ‘a 用户名或密码错误！","categories":[{"name":"数据库","slug":"数据库","permalink":"https://imqinhao.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"MySQL中忘记了root用户的密码解决方法","slug":"mysql_forget_root_password","date":"2021-07-08T04:50:11.000Z","updated":"2021-07-17T02:45:02.702Z","comments":true,"path":"2021/07/08/mysql_forget_root_password/","link":"","permalink":"https://imqinhao.cn/2021/07/08/mysql_forget_root_password/","excerpt":"MySQL中忘记了root用户的密码解决方法","text":"MySQL中忘记了root用户的密码解决方法 停止MySQL服务以管理员身份运行cmd命令行 停止MySQL服务1net stop mysql 使用无验证方式启动MySQL服务1mysqld --skip-grant-tables 此时光标闪烁，不要关闭cmd窗口，新打开一个cmd窗口。 打开新的cmd窗口登录数据库1mysql 修改密码12USE mysql;UPDATE user SET PASSWORD = PASSWORD(\"新的密码\") where user = \"root\"; 关掉两个cmd窗口将两个cmd窗口全部关掉，特别是执行了mysqld --skip-grant-tables命令的cmd窗口。 打开任务管理器找到mysql.exe的进程，将其强制结束。 启动MySQL服务 使用新密码登录数据库 登录成功！！！","categories":[{"name":"数据库","slug":"数据库","permalink":"https://imqinhao.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"MySQL DQL语句-1","slug":"mysql_dql_1","date":"2021-07-07T04:50:11.000Z","updated":"2021-07-17T02:44:51.199Z","comments":true,"path":"2021/07/07/mysql_dql_1/","link":"","permalink":"https://imqinhao.cn/2021/07/07/mysql_dql_1/","excerpt":"语法 基础查询 多个字段的查询 去除重复 计算列 起别名","text":"语法 基础查询 多个字段的查询 去除重复 计算列 起别名 创建表123456789CREATE TABLE student3 ( id INT, -- 编号 NAME VARCHAR(20), -- 姓名 age INT, -- 年龄 sex VARCHAR(5), -- 性别 address VARCHAR(100), -- 地址 math INT, -- 数学 english INT -- 英语); 插入数据1234567891011INSERT INTO student3(id,NAME,age,sex,address,math,english) VALUES (1,'马云',55,'男','杭州',66,78), (2,'马化腾',45,'男','深圳',98,87), (3,'马景涛',55,'男','香港',56,77), (4,'柳岩',20,'女','湖南',76,65), (5,'柳青',20,'男','湖南',86,NULL), (6,'刘德华',57,'男','香港',99,99), (7,'马德',22,'女','香港',99,99), (8,'德玛西亚',18,'男','南京',56,65); 查看所有数据1SELECT * FROM student3; 查询年龄和姓名123456-- 查询 姓名 和 年龄SELECT NAME, -- 姓名 age # 年龄FROM student3; 查询所有的地址12-- 查询所有的地址SELECT address FROM student3; 去除重复的结果集 使用distinct关键字去除重复的结果集。 1SELECT DISTINCT address FROM student3; 计算英语和数学的分数之和无null参与运算1SELECT NAME,math,english,math + english FROM student3; 有null参与运算1SELECT NAME,math,english,math + IFNULL(english,0) FROM student3; 如果有null参与的运算，计算结果都为null 起别名1SELECT NAME 姓名,math 数学,english 英语, math+IFNULL(english,0) AS 总分 FROM student3; 查询年龄大于20岁的人12-- 查询年龄大于20SELECT * FROM student3 WHERE age &gt; 20; 查询年龄大于等于20的人12-- 查询年龄大于等于20SELECT * FROM student3 WHERE age &gt;= 20; 查询年龄等于20的人12-- 查询年龄等于20SELECT * FROM student3 WHERE age = 20; 查询年龄不等于20的人123-- 查询年龄不等于20SELECT * FROM student3 WHERE age &lt;&gt; 20; # 方式1SELECT * FROM student3 WHERE age != 20; # 方式2 查询年龄大于等于20小于等于30的人1234-- 查询年龄大于等于20 小于等于30SELECT * FROM student3 WHERE age &gt;= 20 &amp;&amp; age &lt;= 30; # 方式1SELECT * FROM student3 WHERE age &gt;= 20 AND age &lt;= 30; # 方式2SELECT * FROM student3 WHERE age BETWEEN 20 AND 30; # 方式3，推荐 查询年龄为22岁，18岁，25岁的人123-- 查询年龄22岁，18岁，25岁的信息SELECT * FROM student3 WHERE age = 22 OR age = 18 OR age = 25; # 方式1SELECT * FROM student3 WHERE age IN (22,18,25); # 方式2 查询英语成绩为null的人12-- 查询英语成绩为nullSELECT * FROM student3 WHERE english IS NULL; 查询英语成绩不为null的人12-- 查询英语成绩不为nullSELECT * FROM student3 WHERE english IS NOT NULL; 查询姓马的有哪些12-- 查询姓马的有哪些SELECT * FROM student3 WHERE NAME LIKE \"马%\"; 查询姓名第二个字是化的人12-- 查询姓名第二个字是化的人SELECT * FROM student3 WHERE NAME LIKE \"_化%\"; 查询姓名是三个字的人12-- 查询姓名是三个字的人SELECT * FROM student3 WHERE NAME LIKE \"___\"; 查询姓名中包含德的人12-- 查询姓名中包含德的人SELECT * FROM student3 WHERE NAME LIKE \"%德%\";","categories":[{"name":"数据库","slug":"数据库","permalink":"https://imqinhao.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"MySQL 8解决timestamp类型插入数据不自动添加时间戳","slug":"mysql_question_1","date":"2021-07-06T04:50:11.000Z","updated":"2021-07-17T02:45:12.115Z","comments":true,"path":"2021/07/06/mysql_question_1/","link":"","permalink":"https://imqinhao.cn/2021/07/06/mysql_question_1/","excerpt":"解决MySQL 8创建表使用timestamp类型插入数据不自动添加时间戳的问题。","text":"解决MySQL 8创建表使用timestamp类型插入数据不自动添加时间戳的问题。 今天，创建表的时候使用以下语句： 12345678CREATE TABLE student( id int, stu_name varchar(32), age int, score double(4,1), birthday date, insert_time timestamp); 创建成功之后我们尝试插入数据： 1INSERT INTO student(id,stu_name,age) VALUES(1,&quot;宋祖儿&quot;,23); 接下来我们查询以下student表中的内容： 1SELECT * from student; 我们惊奇的发现，结果竟然是这样： 为什么我们的insert_time设置的是timestamp类型，但是却没有自动添加时间戳呢？ 原来是因为timestamp的默认中没有CURRENT_TIMESTAMP选项。 那么我们如何解决呢？ 那么我想到的方法就是在创建表的时候直接指定不就好了吗，说干就干。 接下来我们先删除表： 1DROP TABLE student; 紧接着，我们重新来创建表： 12345678CREATE TABLE student( id int, stu_name varchar(32), age int, score double(4,1), birthday date, insert_time timestamp(0) DEFAULT CURRENT_TIMESTAMP(0);); 我们先检查一下表： 1DESC student; 可以看到： 这次应该就没问题了，那么我们来插入一条数据看看： ok，完美解决！","categories":[{"name":"数据库","slug":"数据库","permalink":"https://imqinhao.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"Java - 判断方法的正确重载","slug":"OverLoad_1","date":"2021-06-24T12:40:00.000Z","updated":"2021-07-17T02:47:59.450Z","comments":true,"path":"2021/06/24/OverLoad_1/","link":"","permalink":"https://imqinhao.cn/2021/06/24/OverLoad_1/","excerpt":"判断哪些方法是重载关系","text":"判断哪些方法是重载关系 12345678public static void open()&#123;&#125; // 正确重载public static void open(int a)&#123;&#125; // 正确重载static void open(int a,int b)&#123;&#125; // 代码报错：和第8行冲突public static void open(double a, int b)&#123;&#125; // 正确重载public static void open(int a, double b)&#123;&#125; // 代码报错：和第6行冲突public void open(int i, double d)&#123;&#125; // 代码报错：和第5行冲突public static void OPEN()&#123;&#125; // 代码正确不会报错，但是并不是有效重载public static void open(int i, int j)&#123;&#125; // 代码报错：和第3行冲突","categories":[{"name":"Java","slug":"Java","permalink":"https://imqinhao.cn/categories/Java/"}],"tags":[]},{"title":"计算机内存数值存储方式","slug":"memory_save_number","date":"2021-05-22T09:02:14.000Z","updated":"2021-07-17T02:43:51.399Z","comments":true,"path":"2021/05/22/memory_save_number/","link":"","permalink":"https://imqinhao.cn/2021/05/22/memory_save_number/","excerpt":"计算机内存数值存储方式： 原码 反码 补码 补码的意义 数值溢出","text":"计算机内存数值存储方式： 原码 反码 补码 补码的意义 数值溢出 计算机内存数值存储方式原码一个数的原码(原始的二进制码)有如下特点： 最高位做为符号位，0表示正,为1表示负 其它数值部分就是数值本身绝对值的二进制数 负数的原码是在其绝对值的基础上，最高位变为1 下面数值以1字节的大小描述： 十进制数 原码 +15 0000 1111 -15 1000 1111 +0 0000 0000 -0 1000 0000 原码表示法简单易懂，与带符号数本身转换方便，只要符号还原即可，但当两个正数相减或不同符号数相加时，必须比较两个数哪个绝对值大，才能决定谁减谁，才能确定结果是正还是负，所以原码不便于加减运算。 反码 对于正数，反码与原码相同 对于负数，符号位不变，其它部分取反(1变0,0变1) 十进制数 反码 +15 0000 1111 -15 1111 0000 +0 0000 0000 -0 1111 1111 反码运算也不方便，通常用来作为求补码的中间过渡。 补码在计算机系统中，数值一律用补码来存储。 补码特点： 对于正数，原码、反码、补码相同 对于负数，其补码为它的反码加1 补码符号位不动，其他位求反，最后整个数加1，得到原码 十进制数 补码 +15 0000 1111 -15 1111 0001 +0 0000 0000 -0 0000 0000 1234567891011121314#include &lt;stdio.h&gt;int main()&#123; int a = -15; printf(\"%x\\n\", a); //结果为 fffffff1 //fffffff1对应的二进制：1111 1111 1111 1111 1111 1111 1111 0001 //符号位不变，其它取反：1000 0000 0000 0000 0000 0000 0000 1110 //上面加1：1000 0000 0000 0000 0000 0000 0000 1111 最高位1代表负数，就是-15 return 0;&#125; 补码的意义示例1：用8位二进制数分别表示+0和-0 十进制数 原码 +0 0000 0000 -0 1000 0000 十进制数 反码 +0 0000 0000 -0 1111 1111 不管以原码方式存储，还是以反码方式存储，0也有两种表示形式。为什么同样一个0有两种不同的表示方法呢？ 但是如果以补码方式存储，补码统一了零的编码： 十进制数 补码 +0 0000 0000 -0 10000 0000由于只用8位描述，最高位1丢弃，变为0000 0000 示例2：计算9-6的结果 以原码方式相加： 十进制数 原码 9 0000 1001 -6 1000 0110 结果为-15，不正确。 以补码方式相加： 十进制数 补码 9 0000 1001 -6 1111 1010 最高位的1溢出 在计算机系统中，数值一律用补码来存储，主要原因是： 统一了零的编码 将符号位和其它位统一处理 将减法运算转变为加法运算 两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃 数值溢出当超过一个数据类型能够存放最大的范围时，数值会溢出。 有符号位最高位溢出的区别：符号位溢出会导致数的正负发生改变，但最高位的溢出会导致最高位丢失。 数据类型 占用空间 取值范围 char 1字节 -128到 127(-27 ~ 27-1) unsigned char 1字节 0 到 255(0 ~ 28-1) 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main()&#123; char ch; //符号位溢出会导致数的正负发生改变 ch = 0x7f + 2; //127+2 printf(\"%d\\n\", ch); // 0111 1111 //+2后 1000 0001，这是负数补码，其原码为 1111 1111，结果为-127 //最高位的溢出会导致最高位丢失 unsigned char ch2; ch2 = 0xff+1; //255+1 printf(\"%u\\n\", ch2); // 1111 1111 //+1后 10000 0000， char只有8位最高位的溢出，结果为0000 0000，十进制为0 ch2 = 0xff + 2; //255+1 printf(\"%u\\n\", ch2); // 1111 1111 //+1后 10000 0001， char只有8位最高位的溢出，结果为0000 0001，十进制为1 return 0;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"进制","slug":"Base","date":"2021-05-21T08:02:14.000Z","updated":"2021-07-17T02:35:04.676Z","comments":true,"path":"2021/05/21/Base/","link":"","permalink":"https://imqinhao.cn/2021/05/21/Base/","excerpt":"进制 二进制 八进制 十六进制 C语言如何表示相应进制数","text":"进制 二进制 八进制 十六进制 C语言如何表示相应进制数 进制进制也就是进位制，是人们规定的一种进位方法。 对于任何一种进制—X进制，就表示某一位置上的数运算时是逢X进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位。 十进制 二进制 八进制 十六进制 0 0 0 0 1 1 1 1 2 10 2 2 3 11 3 3 4 100 4 4 5 101 5 5 6 110 6 6 7 111 7 7 8 1000 10 8 9 1001 11 9 10 1010 12 A 11 1011 13 B 12 1100 14 C 13 1101 15 D 14 1110 16 E 15 1111 17 F 16 10000 20 10 二进制二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。 当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以补码的形式存储的。 术语 含义 bit(比特) 一个二进制代表一位，一个位只能表示0或1两种状态。数据传输是习惯以“位”（bit）为单位。 Byte(字节) 一个字节为8个二进制，称为8位，计算机中存储的最小单位是字节。数据存储是习惯以“字节”（Byte）为单位。 WORD(双字节) 2个字节，16位 DWORD 两个WORD，4个字节，32位 1b 1bit，1位 1B 1Byte,1字节，8位 1k，1K 1024 1M(1兆) 1024k, 1024*1024 1G 1024M 1T 1024G 1Kb(千位) 1024bit,1024位 1KB(千字节) 1024Byte，1024字节 1Mb(兆位) 1024Kb = 1024 * 1024bit 1MB(兆字节) 1024KB = 1024 * 1024Byte 十进制转化二进制的方法用十进制数除以2，分别取余数和商数，商数为0的时候，将余数倒着数就是转化后的结果。 十进制的小数转换成二进制小数部分和2相乘，取整数，不足1取0，每次相乘都是小数部分，顺序看取整后的数就是转化后的结果。 八进制八进制，Octal，缩写OCT或O，一种以8为基数的计数法，采用0，1，2，3，4，5，6，7八个数字，逢八进1。一些编程语言中常常以数字0开始表明该数字是八进制。 八进制的数和二进制数可以按位对应（八进制一位对应二进制三位），因此常应用在计算机语言中。 十进制转化八进制的方法用十进制数除以8，分别取余数和商数，商数为0的时候，将余数倒着数就是转化后的结果。 十六进制十六进制（英文名称：Hexadecimal），同我们日常生活中的表示法不一样，它由0-9，A-F组成，字母不区分大小写。与10进制的对应关系是：0-9对应0-9，A-F对应10-15。 十六进制的数和二进制数可以按位对应（十六进制一位对应二进制四位），因此常应用在计算机语言中。 十进制转化十六进制的方法用十进制数除以16，分别取余数和商数，商数为0的时候，将余数倒着数就是转化后的结果。 C语言如何表示相应进制数 十进制 以正常数字1-9开头，如123 八进制 以数字0开头，如0123 十六进制 以0x开头，如0x123 二进制 C语言不能直接书写二进制数 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; int a = 123; //十进制方式赋值 int b = 0123; //八进制方式赋值， 以数字0开头 int c = 0xABC; //十六进制方式赋值 //如果在printf中输出一个十进制数那么用%d，八进制用%o，十六进制是%x printf(\"十进制：%d\\n\",a ); printf(\"八进制：%o\\n\", b); //%o,为字母o,不是数字 printf(\"十六进制：%x\\n\", c); return 0;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"时间复杂度和空间复杂度","slug":"Algorithm_1","date":"2021-05-20T09:02:14.000Z","updated":"2021-07-17T02:31:51.748Z","comments":true,"path":"2021/05/20/Algorithm_1/","link":"","permalink":"https://imqinhao.cn/2021/05/20/Algorithm_1/","excerpt":"算法效率的度量方式 算法时间复杂度 推导大O阶方法 线性阶 平方阶 函数调用的时间复杂度分析","text":"算法效率的度量方式 算法时间复杂度 推导大O阶方法 线性阶 平方阶 函数调用的时间复杂度分析 时间复杂度和空间复杂度算法效率的度量方式事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同的算法编制的程序的运行时间进行比较，从而确定算法效率的高低。 事前分析估算方法：在计算机程序编写前，依据统计方法对算法进行估算。 经过总结，我们发现一个高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素： 算法采用的策略，方案 编译产生的代码质量 问题的输入规模 机器执行指令的速度 由此可见，抛开这些与计算机硬件，软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。（所谓的问题输入规模是指输入量的多少） 不同算法运行时间比较第一种算法： 123456789101112131415package 算法与数据结构;public class Test1 &#123; public static void main(String[] args) &#123; int sum = 0; long begin_time = System.currentTimeMillis(); for (int i = 1; i &lt;= 100000000; i++) &#123; sum += i; &#125; long end_time = System.currentTimeMillis(); System.out.println(\"sum = \" + sum); System.out.println(\"运行时间：\" + (end_time-begin_time)); &#125;&#125; 运行结果： 第二种算法： 123456789101112package 算法与数据结构;public class Test2 &#123; public static void main(String[] args) &#123; int sum; long begin = System.currentTimeMillis(); sum = (1 + 1000000000) * 100000000 / 2 ; long end = System.currentTimeMillis(); System.out.println(\"sum = \" + sum); System.out.println(\"运行时间：\" + (end - begin)); &#125;&#125; 运行结果： 第一种算法执行了1 + (n + 1) + n = 2n + 2次。 第二种算法，是1 + 1 = 2次 如果我们把循环看作一个整体，忽略头尾判断的开销，那么这两个算法其实就是n和1的差距。 我们研究算法的复杂度，侧重的是研究算法随着输入规模扩大增长量的一个抽象，而不是精确地定位需要执行多少次，因为如果这样的话，我们就又得考虑回编译器优化等问题。 函数的渐进增长函数的渐进增长：给定两个函数f(n)和g(n)，如果存在一个整数 N ，使得对于所有的n > N，f(n) 总是比 g(n) 大，那么，我们说 f(n) 的增长渐进快于 g(n) 。 与最高次项相乘的常数并不重要，也可以忽略。 判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高项）的阶数。 注意：判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，很容易以偏概全。 算法时间复杂度算法时间复杂度的定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况而确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。它表示问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。 用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。 一般情况下，随着输入规模 n 的增大，T(n) 增长最慢的算法为最优算法。 推导大O阶方法如何分析一个算法的时间复杂度呢？即如何推导大O阶呢？ 用常数1取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是1，则去掉与这个项相乘的常数。 得到的足后结果就是大O阶。 线性阶一般含有非嵌套循环涉及线性阶，线性阶就是随着问题的规模n的扩大，对应计算次数呈直线增长。 123456789101112package 算法与数据结构;public class Test3 &#123; public static void main(String[] args) &#123; int sum = 0; for(int i = 1;i &lt;= 100;i ++) &#123; sum += i; &#125; System.out.println(\"sum = \" + sum); &#125;&#125; 上面这段代码，他的循环的时间复杂度为O(n)，因为循环体中的代码需要执行n次。 平方阶12345678910111213package 算法与数据结构;public class Demo4 &#123; public static void main(String[] args) &#123; for(int i = 0;i &lt; 100;i ++) &#123; for(int j = 0;j &lt; 100;j ++) &#123; System.out.println(\"I love lareina!\"); &#125; &#125; &#125;&#125; n等于100， 也就是说外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环出来，需要执行100*100次，也就是n的平方。所以这段代码的时间复杂度为O(n^2)。 循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。 12345678910111213package 算法与数据结构;public class Demo5 &#123; public static void main(String[] args) &#123; for(int i = 0;i &lt; 100;i ++) &#123; for(int j = i;j &lt; 100;j ++) &#123; System.out.println(\"I love lareina!\"); &#125; &#125; &#125;&#125; 由于当 i = 0 时，内循环执行了 n 次，当 i = 1时，内循环则执行 n - 1 次，当 i = n - 1时，内循环执行1次，所以总的执行次数应该是：$$-n + (n-1)+(n-2)+…+1 = \\frac{n(n + 1)}{2}$$即：$$\\frac{n(n+1)}{2}=\\frac{n^2}{2}+\\frac{n}{2}$$用推导大O的攻略，第一条忽略，因为没有常数相加。第二条只保留最高项，所以n/2这项去掉。第三条，去除与最高项相乘的常数，最终得O(n^2) 123456789101112package 算法与数据结构;public class Demo6 &#123; public static void main(String[] args) &#123; int i = 1; int n = 100; while(i &lt; n) &#123; i *= 2; &#125; &#125;&#125; 由2^n = n得到：$$x = log_2n$$所以这个循环的时间复杂度为O(logn)。 函数调用的时间复杂度分析123456789101112131415package 算法与数据结构;public class Demo7 &#123; static void function(int n)&#123; System.out.println(n); &#125; public static void main(String[] args) &#123; for(int i = 1;i &lt;= 520;i ++) &#123; function(i); &#125; &#125;&#125; function函数的时间复杂度是O(1)，所以整体的时间复杂度就是循环的次数O(n)。 1234567891011121314151617package 算法与数据结构;public class Demo8 &#123; public static void function(int count)&#123; for(int i = count;i &lt;= 520;i ++) &#123; System.out.println(i); &#125; &#125; public static void main(String[] args) &#123; for(int i = 1;i &lt;= 520;i ++) &#123; function(i); &#125; &#125;&#125; function内部的循环次数随count的增加（接近n）而减少，所以根据推导大O阶方法可得出算法的时间复杂度为O(n^2)。","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://imqinhao.cn/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"程序设计与C语言-1","slug":"C_Programming_1","date":"2021-05-20T03:02:14.000Z","updated":"2021-07-17T02:37:47.376Z","comments":true,"path":"2021/05/20/C_Programming_1/","link":"","permalink":"https://imqinhao.cn/2021/05/20/C_Programming_1/","excerpt":"什么是程序？什么是程序设计？ 为什么需要计算机语言？高级语言的特点？ 正确理解各名词及其含义","text":"什么是程序？什么是程序设计？ 为什么需要计算机语言？高级语言的特点？ 正确理解各名词及其含义 什么是程序？什么是程序设计？所谓程序，就是一组计算机能够识别和执行的指令。 程序设计是指从确定任务到得到结果，写出文档的全过程。一般需要经历以下几个工作阶段： 问题分析 设计算法 编写程序 对源程序进行编辑，编译和连接 运行程序，分析结果 编写程序文档 为什么需要计算机语言？高级语言的特点？人与计算机交流信息，需要解决语言问题。需要一种计算机和人都能识别的语言，即计算机语言。 高级语言的特点： 功能强大 不依赖于具体机器 与具体机器距离较远 可移植性好 正确理解以下名次及其含义（1） 源程序 目标程序 可执行程序 源程序：程序可以用高级语言或汇编语言编写，用高级语言或汇编语言编写的程序称为源程序。Ｃ语言源程序的扩展名为“．ｃ”。源程序不能直接在计算机上执行，需要用“编译程序”将源程序编译为二进制形式的代码。 目标程序：源程序经过“编译程序”编译所得到的二进制代码称为目标程序。目标程序的扩展名为“．ｏｂｊ”。目标代码尽管已经是机器指令，但是还不能运行，因为目标程序还没有解决函数调用问题，需要将各个目标程序与库函数连接，才能形成完整的可执行程序。 可执行文件：把所有的编译后得到的目标模块连接装配起来，再与函数库相连接成一个整体，生成一个可供计算机执行的目标程序，称为可执行程序。 (2) 程序编辑 程序编译 程序连接 程序编辑：通过键盘想计算机输入程序，如发现有错误，要及时改正。最后将此源程序以文件形式存放在自己指定的文件夹内，文件以.c作为后缀，生成源程序文件。 程序编译：先用C编译系统提供的“预处理器”对程序中的预处理指令进行编译预处理。由预处理得到的信息与程序其他部分一起，组成一个完整的，可以用来进行正式编译的源程序，然后由编译系统对该程序进行编译。编译的作用首先对源程序进行检查，判断有无语法方面的错误，无语法错误之后编译程序自动把源程序转换为二进制形式的目标程序。 程序连接：把所有的编译后得到的目标模块连接装配起来，再与函数库相连接成一个整体，生成一个可供计算机执行的目标程序，称为可执行程序。即使一个程序只包含一个源程序文件，编译后得到的目标程序也不能直接运行，也要经过连接阶段，因为要与函数库进行连接，才能生成可执行文件。 (3) 程序 程序模块 程序文件 编写程序输出以下信息： 123*************************Very Good!************************* 1234567#include &lt;stdio.h&gt;int main(void)&#123; printf(\"*************************\\n\"); printf(\"Very Good!\\n\"); printf(\"*************************\\n\");&#125; 编写一个程序，输入a,b,c三个值，输出其中最大值。 12345678910111213141516171819#include &lt;stdio.h&gt;int main(void)&#123; int a, b, c, max; scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); if(a &gt; b &amp;&amp; a &gt; c) &#123; max = a; &#125; if(b &gt; a &amp;&amp; b &gt; c) &#123; max = b; &#125; if(c &gt; a &amp;&amp; c &gt; b) &#123; max = c; &#125; printf(\"max = %d\\n\", max);&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"CPU内部结构与寄存器","slug":"CPU_Register","date":"2021-05-14T10:02:14.000Z","updated":"2021-07-17T02:38:51.773Z","comments":true,"path":"2021/05/14/CPU_Register/","link":"","permalink":"https://imqinhao.cn/2021/05/14/CPU_Register/","excerpt":"64位和32位系统区别 寄存器名称 寄存器、缓存、内存三者关系","text":"64位和32位系统区别 寄存器名称 寄存器、缓存、内存三者关系 64位和32位系统区别 寄存器是CPU内部最基本的存储单元。 CPU对外是通过总线（地址、控制、数据）来和外部设备交互的，总线的宽度是8位，同时CPU的寄存器也是8位，那么这个CPU就叫8位CPU。 如果总线是32位，寄存器也是32位，那么这个CPU就是32位CPU。 有一种CPU内部的寄存器是32位的，但总线是16位，准32位CPU。 所有的64位CPU兼容32位的指令，32位也兼容16位的指令，所以在64位的CPU上是可以识别32位的指令的。 在64位的CPU架构上运行了64位的软件操作系统，那么这个系统是64位。 在64位的CPU架构上，运行了32位的软件操作系统，那么这个系统就是32位。 64位的软件不能运行在32位的CPU之上。 寄存器名称 8位 16 位 32位 64位 A AX EAX RAX B BX EBX RBX C CX ECX RCX D DX EDX RDX 寄存器、缓存、内存三者关系按与CPU远近来分，离得最近的是寄存器，然后缓存（CPU缓存），最后内存。 CPU计算时，先预先把要用的数据从硬盘读到内存，然后再把即将要用到的数据读到寄存器，于是CPU 寄存器 内存，这就是它们之间的信息交换。 那为什么没有缓存呢？因为如果经常操作内存中的同一地址的数据，就会影响速度。于是就在寄存器和内存之间设置一个缓存。 因为从缓存提取的速度远高于内存。当然缓存的价格肯定也远远高于内存，不然的话，机器里就没有内存的存在。 由此可以看出，从远近来看：CPU 寄存器 缓存 内存。","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"C语言编译过程","slug":"gcc","date":"2021-05-14T09:02:14.000Z","updated":"2021-07-17T02:40:18.503Z","comments":true,"path":"2021/05/14/gcc/","link":"","permalink":"https://imqinhao.cn/2021/05/14/gcc/","excerpt":"C语言编译过程 ​ C程序编译步骤 ​ gcc编译过程 ​ 分步编译 ​ 常见代码问题","text":"C语言编译过程 ​ C程序编译步骤 ​ gcc编译过程 ​ 分步编译 ​ 常见代码问题 C语言编译过程C程序编译步骤C代码编译成可执行程序经过4步： 预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法。 编译：检查语法，将预处理后文件编译生成汇编文件。 汇编：将汇编文件生成目标文件（二进制文件） 链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去。 gcc编译过程分步编译1234预处理: gcc -E hello.c -o hello.i编 译: gcc -S hello.i -o hello.s汇 编: gcc -c hello.s -o hello.o链 接: gcc hello.o -o hello 选项 含义 -E 只进行预处理 -S（大写） 只进行预处理和编译 -c（小写） 只进行预处理、编译和汇编 -o file 指定生成的输出文件名为file 文件后缀 含义 .c C语言文件 .i 预处理后的C语言文件 .s 编译后的汇编文件 .o 编译后的目标文件 常见代码问题 编辑时异常 编译时异常 运行时异常","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"Python网络编程-文件下载器","slug":"FileDownload","date":"2021-04-25T10:40:14.000Z","updated":"2021-07-17T02:39:31.678Z","comments":true,"path":"2021/04/25/FileDownload/","link":"","permalink":"https://imqinhao.cn/2021/04/25/FileDownload/","excerpt":"文件下载器小案例","text":"文件下载器小案例 服务器1234567891011121314151617181920212223242526272829303132333435363738import socketdef send_file(client_socket, client_addr): file_content = None # 接收消息 recv_data = client_socket.recv(1024).decode(\"gbk\") print(\"%s 需要下载 %s\" % (str(client_addr), recv_data)) # 打开文件 try: f = open(recv_data, \"rb\") file_content = f.read() f.close() except Exception as res: print(\"没有需要下载的文件(%s)\" % recv_data) # 处理消息 if file_content: client_socket.send(file_content)def main(): # 创建socket server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 绑定本地信息 server_socket.bind((\"\", 8080)) # 设主动为被动 server_socket.listen(128) while True: # 监听 client_socket, client_addr = server_socket.accept() # 调用函数 send_file(client_socket, client_addr) client_socket.close() server_socket.close() if __name__ == \"__main__\": main() 客户端123456789101112131415161718192021222324import socketdef main(): # 创建socket client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 链接服务器 client_socket.connect((\"10.198.207.67\", 8080)) # 获取下载的文件名称 download_file_name = input(\"请输入下载的文件名：\") # 将文件名发送给服务器 client_socket.send(download_file_name.encode(\"gbk\")) # 接收文件中的数据 recv_data = client_socket.recv(1024) # 保存接收到的数据到同一个文件中 if recv_data: with open(\"[下载]\" + download_file_name, \"wb\") as f: f.write(recv_data) # 关闭socket client_socket.close()if __name__ == \"__main__\": main()","categories":[{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"}],"tags":[]},{"title":"Python网络编程-TCP服务器","slug":"TCP_server","date":"2021-04-25T07:40:14.000Z","updated":"2021-07-17T02:51:18.275Z","comments":true,"path":"2021/04/25/TCP_server/","link":"","permalink":"https://imqinhao.cn/2021/04/25/TCP_server/","excerpt":"TCP服务器功能的创建 循环为多个客户端服务 循环为多个客户端服务(升级版)","text":"TCP服务器功能的创建 循环为多个客户端服务 循环为多个客户端服务(升级版) TCP服务器如果需要创建一个TCP服务器的功能，需要的流程如下： socket创建一个套接字 bind绑定ip和port listen使套接字变为可以被动连接 accept等待客户端的链接 recv/send接收发送数据 12345678910111213141516171819202122232425262728import socketdef main(): # 1. socket创建一个套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 2. bind绑定ip和port local_addr = (\"\", 9999) tcp_server_socket.bind(local_addr) # 3. listen使套接字变为可以被动连接 tcp_server_socket.listen(128) # 4. accept等待客户端的链接 print(\"等待客户端的接入...\") new_client_socket, client_addr = tcp_server_socket.accept() print(\"有新的客户端接入...\") print(\"%s:%s已与服务器建立连接...\" % (client_addr[0], client_addr[1])) # 5. recv/send接收发送数据 recv_data = new_client_socket.recv(1024) print(\"%s\" % recv_data.decode(\"gbk\")) # 回送数据 new_client_socket.send(\"ok\".encode(\"gbk\")) # 关闭套接字 new_client_socket.close() tcp_server_socket.close()if __name__ == \"__main__\": main() 循环为多个客户端服务123456789101112131415161718192021222324252627282930import socketdef main(): # 创建socket server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 绑定本地信息 server_socket.bind((\"\", 8888)) # 变主动为被动 server_socket.listen(128) # 等待客户机的链接 while True: print(\"等待客户端的链接...\") new_client_socket, client_addr = server_socket.accept() print(\"%s:%s已经链接到服务器\" % (client_addr[0], client_addr[1])) # 接收数据 recv_data = new_client_socket.recv(1024) # 打印接收到的数据 print(recv_data.decode(\"gbk\")) # 发送数据 new_client_socket.send(\"connect ok!\".encode(\"gbk\")) # 关闭新socket new_client_socket.close() print(\"为%s:%s服务完毕\" % (client_addr[0], client_addr[1])) # 关闭socket server_socket.close()if __name__ == \"__main__\": main() 循环为多个客户端服务(升级版)1234567891011121314151617181920212223242526272829303132333435import socketdef main(): # 创建socket server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 绑定本地信息 server_socket.bind((\"\", 8888)) # 设置主动为被动 server_socket.listen(128) # 监听 while True: print(\"等待客户端的链接...\") new_client_socket, client_addr = server_socket.accept() print(\"%s已经链接到服务器\" % str(client_addr)) while True: # 接收数据 recv_data = new_client_socket.recv(1024) if recv_data: # 打印接收到的数据 print(recv_data.decode(\"gbk\")) # 发送数据 new_client_socket.send(\"ok\".encode(\"gbk\")) else: break # 关闭新链接的socket new_client_socket.close() print(\"已经服务完成...\") # 关闭socket server_socket.close()if __name__ == \"__main__\": main()","categories":[{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"}],"tags":[]},{"title":"Python网络编程-TCP构建流程","slug":"TCP_client","date":"2021-04-25T04:40:14.000Z","updated":"2021-07-17T02:51:05.698Z","comments":true,"path":"2021/04/25/TCP_client/","link":"","permalink":"https://imqinhao.cn/2021/04/25/TCP_client/","excerpt":"TCP构建流程示例","text":"TCP构建流程示例 TCP构建流程12345678910111213141516171819202122232425import socketdef main(): # 创建TCP套接字 tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 建立连接 tcp_socket.connect((\"127.0.0.1\", 8888)) # 发送数据/接收数据 while True: # 发送数据 send_content = input(\"请输入要发送的消息：\") if(send_content == \"exit\"): break tcp_socket.send(send_content.encode(\"gbk\")) # 接收数据 recv_data = tcp_socket.recv(1024) # 打印接收到的数据 print(recv_data.decode(\"gbk\")) # 关闭连接 tcp_socket.close()if __name__ == \"__main__\": main()","categories":[{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"}],"tags":[]},{"title":"Python网络编程-TCP简介","slug":"TCP","date":"2021-04-25T04:02:14.000Z","updated":"2021-07-17T02:50:55.389Z","comments":true,"path":"2021/04/25/TCP/","link":"","permalink":"https://imqinhao.cn/2021/04/25/TCP/","excerpt":"TCP介绍 TCP特点 UDP/TCP通信模型 UDP与TCP的不同点","text":"TCP介绍 TCP特点 UDP/TCP通信模型 UDP与TCP的不同点 TCP简介TCP介绍TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 TCP通信需要经过创建连接、数据传送、终止连接三个步骤。 TCP特点通信双方必须先建立连接才能进行数据的传输 双方都必须为该连接分配必要的系统内核资源,以管理连接的状态和连接上的传输双方间的数据传输都可以通过这一个连接进行 完成数据交换后双方必须断开此连接,以释放系统资源 这种连接是一对一的,因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。 UDP通信模型UDP通信模型中，在通信开始之前，不需要建立相关的连接，只需要发送数据即可。 TCP通信模型TCP通信模型中，在通信开始之前，一定要先建立相关的连接，才能发送数据。 TCP与UDP的不同点 面向连接(确认有创建三方交握，连接已创建才作传输) 有序数据传输 重发丢失的数据包 舍弃重复的数据包 无差错的数据传输 阻塞/流量控制","categories":[{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"}],"tags":[]},{"title":"Python网络编程-UDP","slug":"PythonUdp","date":"2021-04-25T02:02:14.000Z","updated":"2021-07-17T02:49:19.176Z","comments":true,"path":"2021/04/25/PythonUdp/","link":"","permalink":"https://imqinhao.cn/2021/04/25/PythonUdp/","excerpt":"发送数据的流程 接收数据的流程 案例：UDP聊天器","text":"发送数据的流程 接收数据的流程 案例：UDP聊天器 发送数据的流程 创建套接字 发送数据 关闭套接字 12345678910111213141516171819202122import socketdef main(): # 创建udp套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 绑定本地信息 local_addr = (\"\", 7890) udp_socket.bind(local_addr) # 目的地主机信息 desc_addr = (\"10.197.36.81\", 8080) # 发送数据 while True: sent_content = input(\"请输入要发送的消息：\") if(sent_content == \"exit\"): break udp_socket.sendto(sent_content.encode(\"gbk\"), desc_addr) # 关闭套接字 udp_socket.close()if __name__ == \"__main__\": main() 接收数据的流程 创建套接字 绑定本地自己的信息（ip及port） 接收数据 关闭套接字 12345678910111213141516171819202122import socketimport datetimedef main(): # 创建udp套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 绑定本地地址信息 local_addr = (\"\", 8088) udp_socket.bind(local_addr) times = datetime.datetime.now().strftime('%F %T') while True: # 接收数据 recv = udp_socket.recvfrom(1024) recv_data = recv[0].decode(\"gbk\") recv_addr = recv[1][0]; # 打印接收到的数据 print(\"【%s】 接收到来自%s的消息：\\n%s\" % (times, recv_addr, recv_data)) # 关闭udp套接字 udp_socket.close()if __name__ == \"__main__\": main() 同一个端口不允许同一时刻被使用两次 Question recvfrom 在没有数据到来时，会怎样？ 会阻塞。 套接字是可以同时收发数据的。 socket套接字是全双工。 单工：单工数据传输只支持数据在一个方向上传输。 半双工： 半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信。 全双工：全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。 案例：UDP聊天器123456789101112131415161718192021222324252627282930313233343536373839404142434445import socketdef send_msg(udp_socket): desc_ip = input(\"请输入对方的IP地址：\") desc_port = int(input(\"请输入对方的端口号：\")) desc_addr = (desc_ip, desc_port) send_content = input(\"请输入需要发送的消息：\") udp_socket.sendto(send_content.encode(\"gbk\"), desc_addr)def recv_msg(udp_socket): recv_data = udp_socket.recvfrom(1024) recv_msg = recv_data[0].decode(\"gbk\") recv_addr = recv_data[1][0] print(\"您收到了来自【%s】的消息：\\n%s\" % (recv_addr, recv_msg)) def main(): # 创建套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) local_addr = (\"\", 8888) udp_socket.bind(local_addr) # 发送和接收 while True: print(\"------------- UDP聊天器 -------------\") print(\"1. 发送数据\") print(\"2. 接收数据\") print(\"0. 退出系统\") choice = input(\"请输入功能选项：\") if choice == \"1\": # 发送数据 send_msg(udp_socket) elif choice == \"2\": # 接收数据 recv_msg(udp_socket) elif choice == \"0\": break else: print(\"输入有误，请重新输入！\\n\")if __name__ == \"__main__\": main()","categories":[{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"}],"tags":[]},{"title":"文件操作","slug":"c-11","date":"2021-03-17T09:02:14.000Z","updated":"2021-07-17T02:37:58.590Z","comments":true,"path":"2021/03/17/c-11/","link":"","permalink":"https://imqinhao.cn/2021/03/17/c-11/","excerpt":"文件指针 打开和关闭文件 文件的读写操作","text":"文件指针 打开和关闭文件 文件的读写操作 文件指针用一个称为文件指针的指针变量指向文件，通过文件指针就可对它所指向的文件进行各种操作。 声明文件指针的简单形式： 1FILE *变量名; FILE是结构体类型struct _iobuf的同义词，结构体类型struct _iobuf在头文件stdio.h中声明，用于描述文件的相关信息。 打开和关闭文件文件在进行读写操作之前要先打开，使用完毕要关闭。所谓打开文件，实际上是获取文件的有关信息，并使文件指针指向该文件，以便进行相关操作。关闭文件则断开指针与文件之间的联系。 打开文件库函数fopen用来打开一个文件，要使用库函数fopen，需包含头文件stdio.h。函数调用的形式： 1文件指针名 = fopen(文件名, 使用文件方式); 例如： 1fp1 = (\"data.txt\", \"r\"); 功能：打开当前目录下的文件data.txt，只允许进行“读”操作，并使文件指针fp1指向文件data.txt。 1FILE *fp2 = fopen(\"C:\\\\info.dat\", \"rb\"); 功能：打开C驱动器磁盘的根目录下的文件info.dat，按二进制方式进行读操作，并使文件指针fp2指向文件info.dat。 字符 含义 r 读（read） w 写（write） a 追加（append） t 文本文件（text），可省略不写 b 二进制文件（banary） + 读和写 组合 含义 rt 或 r 只读打开一个文本文件，只允许读数据 wt 或 w 打开或创立一个文件文件，只允许写数据 at 或 a 追加打开一个文本文件，并在文件末尾写数据 rb 只读打开一个二进制文件，只允许读数据 wb 打开或建立一个二进制文件，只允许写数据 ab 追加打开一个二进制文件，并在文件末尾写数据 关于使用文件方式有以下几点说明 用r打开文件时，该文件必须已经存在。 用w打开文件时，如果文件不存在，则以指定的文件名建立文件；否则，将文件删除，重建一个新文件。 要向一个已存在的文件追加新的信息，应该用a打开文件。 打开文件时，如果出错，库函数fopen 将返回NULL。 关闭文件文件一旦使用完毕，应调用库函数fclose关闭文件，以避免数据丢失等错误。要使用库函数fclose，需包含头文件stdio.h。函数调用的形式： 1fclose (文件指针); 文件的读写操作字符读写库函数 库函数fputc 函数调用的形式： 1fputc(字符数据, 文件指针); 功能：将一个字符写入文件指针指向的文件中。例如： 1fputc('?', fp); 将“?”写入fp指向的文件中。 库函数fgetc 函数调用的形式： 1fgetc(文件指针); 功能：从文件指针指向的文件中读取一个字符并返回，如果文件已结束，则返回EOF。 例题输入一行字符，写入文件 data.txt ，读取并输出文件 data.txt 的内容。 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; FILE *fp; char ch; fp = fopen(\"data.txt\", \"w\"); printf(\"Input a string: \"); scanf(\"%c\", &amp;ch); while(ch != '\\n') &#123; fputc(ch, fp); scanf(\"%c\", &amp;ch); &#125; fclose(fp); fp = fopen(\"data.txt\", \"r\"); ch = fgetc(fp); while(ch != EOF) &#123; printf(\"%c\", ch); ch = fgetc(fp); &#125; printf(\"\\n\"); fclose(fp); return 0;&#125; 运行结果： 12Input a string: Programming Language CProgramming Language C 写入文件完成，文件的当前位置移到文件尾，关闭文件，读取文件之前再重新打开文件，使文件的当前位置移到文件头，以读取数据。 字符串读写库函数 库函数fputs 函数调用的形式： 1fputs(字符串, 文件指针); 功能：将字符串写入文件指针所指向的文件中，不写入’\\0’。 库函数 fgets 函数调用的形式： 1fgets(数组元素的类型为char的数组名, 整数n, 文件指针); 功能：从文件指针指向的文件中读取最多n - 1个字符，并存储到数组中，遇到换行符（读取并存入数组）或文件结束标志，读取结束。在最后一个字符存入数组后，还要向数组中存入一个’\\0’，以构成一个字符串。 编程练习1输入一行字符，将其中的小写字母转换为大写字母，其他字符保持不变，将转换后的内容写入文件 data1.txt 。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main(void)&#123; // 输入一行字符，将其中的小写字母转换为大写字母，其他字符不变 // 将转换后的内容写入文件 data1.txt FILE *fp; char ch; fp = fopen(\"data1.txt\", \"w\"); printf(\"请输入一行字符：\"); scanf(\"%c\", &amp;ch); while(ch != '\\n') &#123; if(ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') &#123; ch -= 32; &#125; fputc(ch, fp); scanf(\"%c\", &amp;ch); &#125; fclose(fp); fp = fopen(\"data1.txt\", \"r\"); ch = fgetc(fp); while(ch != EOF) &#123; printf(\"%c\", ch); ch = fgetc(fp); &#125; printf(\"\\n\"); fclose(fp); return 0;&#125; 运行结果： 编程练习2读取文件data1.txt 的内容，将其中的大写字母转换为小写字母，其他的字符不变，将转换后的内容输出。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(void)&#123; FILE *fp; fp = fopen(\"data1.txt\", \"r\"); char ch; ch = fgetc(fp); while(ch != EOF) &#123; if(ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; printf(\"%c\", ch + 32); &#125; else &#123; printf(\"%c\", ch); &#125; ch = fgetc(fp); &#125; printf(\"\\n\"); fclose(fp); return 0;&#125; 运行结果： 1hello123.com 编程练习3描述学生的结构体类型 struct student 的声明如下： 12345678struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125;; 输入这五个学生的信息，并写入文件 data2.txt 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125;;int main(void)&#123; FILE *fp; struct student s[5]; struct student t[5]; int i; for(i = 0;i &lt; 5;i ++) &#123; printf(\"请输入第%d个学生的信息：\\n\", i + 1); if(i != 0) &#123; getchar(); &#125; printf(\"性别(男：M 女：F）：\"); scanf(\"%c\", &amp;s[i].sex); printf(\"学号：\"); scanf(\"%s\", s[i].sno); printf(\"姓名：\"); scanf(\"%s\", s[i].name); printf(\"年龄：\"); scanf(\"%d\", &amp;s[i].age); printf(\"分数：\"); scanf(\"%lf\", &amp;s[i].score); &#125; fp = fopen(\"data2.txt\", \"w\"); for(i = 0;i &lt; 5;i ++) &#123; fprintf(fp, \"%c %s %s %d %lf\\n\", s[i].sex, s[i].sno, s[i].name, s[i].age, s[i].score); &#125; fclose(fp); fp = fopen(\"data2.txt\", \"r\"); printf(\" sno\\t\\tname\\t\\tsex\\t\\tage\\t\\tscore\\n\"); for(i = 0;i &lt; 5;i ++) &#123; fscanf(fp, \"%c%s%s%d%lf\", &amp;t[i].sex, t[i].sno, t[i].name, &amp;t[i].age, &amp;t[i].score); fgetc(fp); // 读入并丢弃空格 printf(\"%s\\t\\t%s\\t\\t%c\\t\\t%d\\t\\t%.1lf\\n\", t[i].sno, t[i].name, t[i].sex, t[i].age, t[i].score); &#125; fclose(fp); return 0;&#125; 运行结果： 123456789101112131415161718192021222324252627282930请输入第1个学生的信息：性别(男：M 女：F）：M学号：2018001姓名：猫七年龄：24分数：96请输入第2个学生的信息：性别(男：M 女：F）：F学号：2018002姓名：老六年龄：25分数：99请输入第3个学生的信息：性别(男：M 女：F）：M学号：2018003姓名：苏晗年龄：28分数：94请输入第4个学生的信息：性别(男：M 女：F）：M学号：2018004姓名：韩星星年龄：23分数：92请输入第5个学生的信息：性别(男：M 女：F）：F学号：2018005姓名：阿么年龄：25分数：89 编程练习4读取文件 data2.txt 的内容，计算平均分并输出。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125;;int main(void)&#123; FILE *fp; struct student s[5]; fp = fopen(\"data2.txt\", \"r\"); double sum = 0.0, average = 0.0; int i; for(i = 0;i &lt; 5;i ++) &#123; fscanf(fp, \"%c %s %s %d %lf\", &amp;s[i].sex, s[i].sno, s[i].name, &amp;s[i].age, &amp;s[i].score); fgetc(fp); sum += s[i].score; &#125; fclose(fp); average = sum / 5; printf(\"average = %.2lf\\n\", average); return 0;&#125; 运行结果： 1average &#x3D; 94.00","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"结构体、共同体和枚举类型","slug":"c_10","date":"2021-03-16T09:02:14.000Z","updated":"2021-07-17T02:37:33.862Z","comments":true,"path":"2021/03/16/c_10/","link":"","permalink":"https://imqinhao.cn/2021/03/16/c_10/","excerpt":"结构体类型 结构体类型与数组 结构体类型与函数 单链表 共同体声明 枚举类型 typedef声明","text":"结构体类型 结构体类型与数组 结构体类型与函数 单链表 共同体声明 枚举类型 typedef声明 结构体类型​ 在程序设计中，有时需要将不同类型的数据组合成一个有机的整体，以便于引用。例如，学生的信息包括学号、姓名、性别、年龄和成绩。如果用独立的变量：学号（sno）、姓名（name）、性别（sex）、年龄（age）和成绩（score）来表示。如图所示，变量之间是孤立的，很难体现数据之间的内在联系。 使用结构体类型，可以把多个数据项合成一个整体。学生信息可用结构体类型来描述。 结构体类型声明为描述学生信息，可声明一个结构体类型： 12345678struct student&#123; char sno[8]; //学号 char name[20]; //姓名 char sex; //性别 int age; //年龄 double score[3]; //三门课程的成绩&#125; 结构体类型 struct student ，包括 sno 、name 、 sex 、 age 和 score 共五个成员。struct student 是一个类型说明符，它和 int 、char 、 float 、 double 等一样，都可以用来指定变量的类型，只不过结构体类型 struct student 需要由程序员自行声明一样。 结构体类型声明的一般形式： 1234struct [标记名称]&#123; 成员列表&#125;; 标记名称是一个标识符，也可以省略标记名称，表示匿名结构体类型。 结构体类型声明既可以放在函数之外，被其作用范围内的所有函数使用；也可以放在某个函数的函数体内，只能在该函数的函数体内使用。 如果 sizeof 运算符的运算对象是结构体类型，运算结果是所有成员占内存大小(按字节计算)再加上内部和尾部填充所占内存大小(按字节计算)的总和。 结构体类型的变量声明 先声明结构体类型再声明变量 12345struct 标记名称&#123; 成员列表&#125;;struct 标记名称 变量名1 [, 变量名2, 变量名3, …]; 例如： 123456789struct student&#123; char sno[8]; char name[20]; char sex; int age; double score[3];&#125;;struct student s; 点击查看更多 struct student 才是类型说明符，以下两种声明变量的方法都是错误的。 struct s； //错误 student s； //错误 在声明结构体类型的同时声明变量 1234struct 标记名称&#123; 成员列表&#125; 变量名1 [, 变量名2, 变量名3, …]; 例如： 12345678struct student&#123; char sno[8]; char name[20]; char sex; int age; double score[3];&#125; s1, s2; 使用匿名结构体类型声明变量 1234struct&#123; 成员列表&#125; 变量名1 [, 变量名2, 变量名3, …]; 例如： 12345678struct&#123; char sno[8]; char name[20]; char sex; int age; double score[3];&#125; s1, s2; 结构体类型的成员，其类型也可以是结构体类型。例如，结构体类型 struct student 中的成员 age（年龄），由于年龄总是随着时间变化，比较好的方法是用生日代替年龄，生日是一个日期（由年、月、日组成），可以声明一个结构体类型来描述日期： 123456struct date&#123; int year; int month; int day;&#125;; 于是，描述学生信息的结构体类型声明可改为： 12345678struct student&#123; char sno[8]; char name[20]; char sex; struct date birthday; //birthday的类型是struct date double score[3];&#125;; 初始化结构体类型的变量在结构体类型的变量声明时给变量赋值，称为初始化。例如： 12345678910struct student&#123; char sno[8]; char name[20]; char sex; int age; double score[3];&#125;;struct student s = &#123;\"2015001\", \"LiMing\", 'M', 18, &#123;85.0, 92.5, 95.5&#125;&#125;; 在初始化结构体类型的变量时，大括号内的数据顺序必须与结构体类型中成员的声明顺序一致；否则，就会产生混乱。 如果某个成员的类型是结构体类型，其初始化方式如下： 1234567891011121314151617struct date&#123; int year; int month; int day;&#125;;struct student&#123; char sno[8]; char name[20]; char sex; struct date birthday; //birthday的类型是struct date double score[3];&#125;;struct student t = &#123;\"2015001\", \"LiMing\", 'M', &#123;1997, 11, 18&#125;, &#123;85.0, 92.5, 95.5&#125;&#125;; 引用结构体类型的变量 不能将结构体类型的变量作为一个整体进行输入或输出 12345678910struct student&#123; char sno[8]; char name[20]; char sex; int age; double score[3];&#125;;struct student s = &#123;\"2015001\", \"LiMing\", 'M', 18, &#123;85.0, 92.5, 95.5&#125;&#125;;printf(\"%s, %s, %c, %d, %f, %f, %f\", s); // 错误 引用结构体类型的变量中的成员要使用成员选择运算符 “ . ”，其一般形式： 1结构体类型的变量名.成员名 例如： 123s.age = 20; //将20赋值给变量s中的成员ages.age++; //使变量s中的成员age加1sum = s.score[0] + s.score[1] + s.score[2]; 如果成员本身又是一个结构体类型的变量，则要用若干成员运算符，一级一级地找到最低一级的成员 12t.sno t.birthday.year 除了初始化，在其他位置只能用同类型的变量为结构体类型的变量赋值，或者为其成员赋值 1234567891011121314151617struct student&#123; char sno[8]; char name[20]; char sex; int age; double score[3];&#125; s1, s2;// 对s1的各个成员逐一赋值strcpy(s1.sno, \"2015001\");strcpy(s1.name, \" LiMing\");s1.sex = 'M';s1.age = 18;s1.score[0] = 85.0;s1.score[1] = 92.5;s1.score[2] = 95.5;s2 = s1; // 用同类型的变量 s1 为 s2 赋值 例题1初始化结构体类型的变量，然后输出该变量。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main(void)&#123; struct student &#123; char sno[9]; char name[20]; char sex; int age; double score[3]; &#125;; struct student s = &#123;\"2018001\", \"QinHao\", 'M', 21, &#123;100, 95, 98&#125;&#125;; int i; printf(\"sno: %s\\n\", s.sno); printf(\"name: %s\\n\", s.name); printf(\"sno: %c\\n\", s.sex); printf(\"sno: %d\\n\", s.age); printf(\"score: \"); for(i = 0;i &lt; 3;i ++) &#123; printf(\"%5.lf\", s.score[i]); &#125; printf(\"\\n\"); return 0;&#125; 运行结果： 12345sno: 2018001name: QinHaosno: Msno: 21score: 100 95 98 结构体类型 struct student 的声明放在 main 函数的函数体内，只能在 main 函数的函数体内使用 struct student 。 例题2输入结构体类型的变量中各成员的值，为结构体类型的变量赋值。 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;struct student&#123; char sno[8]; char name[20]; char sex; int age; double score[3];&#125;;int main(void)&#123; struct student s1, s2; int i; printf(\"Input the student's information: \"); scanf(\"%c%s%s%d\", &amp;s1.sex,s1.sno, s1.name, &amp;s1.age); for(i = 0;i &lt; 3;i ++) &#123; scanf(\"%lf\", &amp;s1.score[i]); &#125; s2 = s1; printf(\"sno: %s\\n\", s2.sno); printf(\"name: %s\\n\", s2.name); printf(\"sex: %c\\n\", s2.sex); printf(\"age: %d\\n\", s2.age); printf(\"score: \"); for(i = 0;i &lt; 3;i ++) &#123; printf(\"%6.1lf\", s2.score[i]); &#125; printf(\"\\n\"); return 0;&#125; 运行结果： 123456Input the student&#39;s information: M 2018001 QinHao 21 85.0 92.5 95.5sno: 2018001name: QinHaosex: Mage: 21score: 85.0 92.5 95.5 结构体函数 struct student 的声明放在 main 函数之前，struct student 可以被其作用范围内的所有函数使用。通常，将结构体、共同体或枚举类型的声明放在 main 函数之前。 指向结构体类型的指针变量使用成员间接选择运算符“-&gt;”，可以直观、方便地通过指向结构体类型的指针变量访问该结构体类型变量的成员，其一般形式： 1指向结构体类型的指针变量名-&gt;成员名 例题3使用指向结构体类型的指针变量访问该结构体类型变量的成员。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125;;int main(void)&#123; struct student s; struct student *p; // 声明指向结构体类型的指针变量 strcpy(s.sno, \"2018001\"); strcpy(s.name, \"QinHao\"); s.sex = 'M'; s.age = 21; s.score = 92.5; puts(\"s.sno\\t\\ts.name\\t\\ts.sex\\t\\ts.age\\t\\ts.score\"); printf(\"%s\\t\\t%s\\t\\t%c\\t\\t%d\\t\\t%.1lf\\n\\n\", s.sno, s.name, s.sex, s.age, s.score); p = &amp;s; // 使指针变量 p 指向变量s puts(\"(*p).sno\\t(*p).name\\t(*p).sex\\t(*p).age\\t(*p).score\"); printf(\"%s\\t\\t%s\\t\\t%c\\t\\t%d\\t\\t%.1lf\\n\\n\", (*p).sno, (*p).name, (*p).sex, (*p).age, (*p).score); puts(\"p-&gt;sno\\t\\tp-&gt;name\\t\\tp-&gt;sex\\t\\tp-&gt;age\\t\\tp-&gt;score\"); printf(\"%s\\t\\t%s\\t\\t%c\\t\\t%d\\t\\t%.1lf\\n\", p-&gt;sno, p-&gt;name, p-&gt;sex, p-&gt;age, p-&gt;score); return 0;&#125; 运行结果： 12345678s.sno s.name s.sex s.age s.score2018001 QinHao M 21 92.5(*p).sno (*p).name (*p).sex (*p).age (*p).score2018001 QinHao M 21 92.5p-&gt;sno p-&gt;name p-&gt;sex p-&gt;age p-&gt;score2018001 QinHao M 21 92.5 编程练习1声明结构体类型 struct book，描述图书信息：书名（title）、作者（author）、出版社（press）、价格（price）、数量（amount）。输入一本图书的信息，采用例题3的三种方式输出图书的信息。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct book&#123; char title[30]; char author[20]; char press[30]; double price; int amount;&#125;;int main(void)&#123; struct book b; struct book *p; strcpy(b.title, \"疯狂Java讲义\"); strcpy(b.author, \"李刚\"); strcpy(b.press, \"电子工业出版社\"); b.price = 79.0; b.amount = 100; puts(\"b.title\\t\\t\\tb.author\\t\\tb.press\\t\\t\\tb.price\\t\\t\\tb.amount\"); printf(\"%s\\t\\t%s\\t\\t\\t%s\\t\\t%.1lf%\\t\\t\\t%d\\n\\n\", b.title, b.author, b.press, b.price, b.amount); p = &amp;b; puts(\"(*p).title\\t\\t(*p).author\\t\\t(*p).press\\t\\t(*p).price\\t\\t(*p).amount\"); printf(\"%s\\t\\t%s\\t\\t\\t%s\\t\\t%.1lf\\t\\t\\t%d\\n\\n\", (*p).title, (*p).author, (*p).press, (*p).price, (*p).amount); puts(\"(*p-&gt;title\\t\\t(*p-&gt;author\\t\\t(*p-&gt;press\\t\\t(*p-&gt;price\\t\\t(*p-&gt;amount\"); printf(\"%s\\t\\t%s\\t\\t\\t%s\\t\\t%.1lf\\t\\t\\t%d\\n\", p-&gt;title, p-&gt;author, p-&gt;press, p-&gt;price, p-&gt;amount); return 0;&#125; 运行结果： 编程练习2声明结构体类型 struct date ，描述日期信息：年（year）、月（month）、日（day）。输入一个日期，计算并输出是这一年的第几天，注意判断是不是闰年。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;struct date&#123; int year; int month; int day;&#125;;int main(void)&#123; struct date d; int sum = 0, i; int leapyear[13] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; int commonyear[13] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; printf(\"请输入年：\"); scanf(\"%d\", &amp;d.year); printf(\"请输入月：\"); scanf(\"%d\", &amp;d.month); printf(\"请输入日：\"); scanf(\"%d\", &amp;d.day); if(d.year % 400 == 0 || (d.year % 4 == 0 &amp;&amp; d.year % 100 != 0)) &#123; for(i = 0;i &lt; d.month;i ++) &#123; sum += leapyear[i]; &#125; sum += d.day; &#125; else &#123; for(i = 0;i &lt; d.month;i ++) &#123; sum += commonyear[i]; &#125; sum += d.day; &#125; printf(\"%d年%d月%d日是%d年的第%d天\\n\", d.year, d.month, d.day, d.year, sum); return 0;&#125; 运行结果： 1234请输入年：2020请输入月：12请输入日：312020年12月31日是2020年的第366天 1234请输入年：2021请输入月：12请输入日：312021年12月31日是2021年的第365天 结构体类型与数组数组声明 先声明结构体类型再声明数组 123456789struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125;;struct student s[10]; 在声明结构体类型的同时声明数组 12345678struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125; s[10]; 使用匿名结构体类型声明数组 12345678struct&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125; s[10]; 引用数组元素的成员数组元素的类型是结构体类型，可使用成员选择运算符引用数组元素的成员。 初始化数组例题1初始化数组，输出数组中的每一个数组元素。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125;;int main(void)&#123; struct student s[3] = &#123; &#123;\"2018001\", \"Zhangsan\", 'M', 18, 92.5&#125;, &#123;\"2018002\", \"Lisi\", 'F', 18, 95.5&#125;, &#123;\"2018003\", \"Wangwu\", 'M', 19, 85.0&#125; &#125;; int i; puts(\" sno name sex age score\"); for(i = 0;i &lt; 3;i ++) &#123; printf(\"%s%20s%5c%8d%12.1lf\\n\", s[i].sno, s[i].name, s[i].sex, s[i].age, s[i].score); &#125; return 0;&#125; 运行结果： 例题2输入三个学生的信息，输出成绩（score）高于平均成绩的学生信息。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125;;int main(void)&#123; struct student s[3]; int i; double sum = 0, avg = 0.0; puts(\"Input three students' information (sex, sno, name, age, score):\"); for(i = 0;i &lt; 3;i ++) &#123; // 先输入字符数据 scanf(\"%c%s%s%d%lf\", &amp;s[i].sex, &amp;s[i].sno, &amp;s[i].name, &amp;s[i].age, &amp;s[i].score); getchar(); sum += s[i].score; &#125; avg = sum / 3.0; printf(\"The average score is %4.1lf\\n\", avg); puts(\" sno name sex age score\"); for(i = 0;i &lt; 3;i ++) &#123; if(s[i].score &gt; avg) &#123; printf(\"%s%20s%5c%5d%8.1lf\\n\", s[i].sno, s[i].name, s[i].sex, s[i].age, s[i].score); &#125; &#125; return 0;&#125; 运行结果： 编程练习声明结构体类型 struct book，描述图书信息：书名（title）、作者（author）、出版社（press）、价格（price）、数量（amount）。输入五本图书的信息，按价格升序的方式对五本图书排序，输出排序后的图书信息。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;struct book&#123; char title[40]; char author[20]; char press[40]; double price; int amount;&#125;;int main(void)&#123; int i, j; struct book b[5], temp; printf(\"请输入5本书的资料（书名，作者，出版社，价格，数量）:\\n\"); for(i = 0;i &lt; 5;i ++) &#123; scanf(\"%s%s%s%lf%d\", &amp;b[i].title, &amp;b[i].author, &amp;b[i].press, &amp;b[i].price, &amp;b[i].amount); &#125; for(i = 0;i &lt; 5;i ++) &#123; for(j = 0;j &lt; 4 - i;j ++) &#123; if(b[j].price &gt; b[j + 1].price) &#123; temp = b[j]; b[j] = b[j + 1]; b[j + 1] = temp; &#125; &#125; &#125; for(i = 0;i &lt; 5;i ++) &#123; printf(\"%s\\t\\t%s\\t\\t%s\\t\\t%.1lf\\t\\t%d\\n\", b[i].title, b[i].author, b[i].press, b[i].price, b[i].amount); &#125; return 0;&#125; 运行结果： 结构体类型与函数形参是结构体类型的变量例题1输入两个学生中成绩（score）较高的学生信息。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125;;struct student max(struct student t1, struct student t2);int main(void)&#123; struct student s1 = &#123;\"2018001\", \"Liming\", 'M', 18, 92.5&#125;; struct student s2 = &#123;\"2018002\", \"Wangfang\", 'F', 18, 95.5&#125;; struct student s; s = max(s1, s2); printf(\"sno: %s\\n\", s.sno); printf(\"name: %s\\n\", s.name); printf(\"sex: %c\\n\", s.sex); printf(\"age: %d\\n\", s.age); printf(\"score: %.1lf\\n\", s.score); return 0;&#125;struct student max(struct student t1, struct student t2)&#123; if(t1.score &gt; t2.score) &#123; return t1; &#125; else &#123; return t2; &#125;&#125; 运行结果： 12345sno: 2018002name: Wangfangsex: Fage: 18score: 95.5 例题2修改学生的年龄。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125;;void change(struct student t);int main(void)&#123; struct student s = &#123;\"2015001\", \"Liming\", 'M', 18, 92.5&#125;; puts(\"\\t\\t\\tsno\\t\\tname\\t\\tsex\\t\\tage\\t\\tscore\"); printf(\"Before modifying\\t%s\\t\\t%s\\t\\t%c\\t\\t%d\\t\\t%.1lf\\n\", s.sno, s.name, s.sex, s.age, s.score); change(s); printf(\"After modifying\\t\\t%s\\t\\t%s\\t\\t%c\\t\\t%d\\t\\t%.1lf\\n\", s.sno, s.name, s.sex, s.age, s.score); return 0;&#125;void change(struct student t)&#123; t.age ++;&#125; 运行结果 实参向形参的传递是单向的，在被调函数 change 中改变形参 t 的值并不影响实参 s 的值。因此，调用函数 change 后，学生的年龄依旧是 18 岁。 形参是指向结构体类型的指针变量例题1输出两个学生中成绩（score）较高的学生信息。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125;;struct student *max(struct student *p1, struct student *p2);int main(void)&#123; struct student s1 = &#123;\"2015001\", \"LiMing\", 'M', 18, 92.5&#125;; struct student s2 = &#123;\"2015002\", \"WangFang\", 'F', 18, 95.5&#125;; struct student *q; q = max(&amp;s1, &amp;s2); //实参是结构体类型变量的地址 printf(\"sno: %s\\n\", q-&gt;sno); printf(\"name: %s\\n\", q-&gt;name); printf(\"sex: %c\\n\", q-&gt;sex); printf(\"age: %d\\n\", q-&gt;age); printf(\"score: %.1lf\\n\", q-&gt;score); return 0;&#125;// 形参是指向结构体类型的指针变量struct student *max(struct student *p1, struct student *p2)&#123; if(p1-&gt;score &gt; p2-&gt;score) &#123; return p1; &#125; else &#123; return p2; &#125;&#125; 运行结果： 12345sno: 2015002name: WangFangsex: Fage: 18score: 95.5 例题2修改学生的年龄。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125;;void change(struct student *p);int main(void)&#123; struct student s = &#123;\"2015001\", \"LiMing\", 'M', 18, 92.5&#125;; struct student *q = &amp;s; puts(\"\\t\\t\\tsno\\t\\tname\\t\\tsex\\t\\tage\\t\\tscore\"); printf(\"Before modifying\\t%s\\t\\t%s\\t\\t%c\\t\\t%d\\t\\t%.1lf\\n\", s.sno, s.name, s.sex, s.age, s.score); change(q); printf(\"After modifying\\t\\t%s\\t\\t%s\\t\\t%c\\t\\t%d\\t\\t%.1lf\\n\", s.sno, s.name, s.sex, s.age, s.score); return 0;&#125;void change(struct student *p)&#123; p-&gt;age ++;&#125; 运行结果： 形参是数组元素为结构体类型的数组例题1输入三个学生的信息并输出。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125;;void input(int n, struct student t[ ]);void output(int n, struct student *t);int main(void)&#123; struct student s[3]; input(3, s); output(3, s); return 0;&#125;void input(int n, struct student t[ ])&#123; int i; printf(\"请输入%d位同学的信息（性别，学号，姓名，年龄，成绩）\\n\", n); for(i = 0;i &lt; n;i ++) &#123; scanf(\"%c%s%s%d%lf\", &amp;t[i].sex, t[i].sno, t[i].name, &amp;t[i].age, &amp;t[i].score); getchar(); &#125;&#125;void output(int n, struct student *t)&#123; int i; puts(\" sno name sex age score\"); for(i = 0;i &lt; n;i ++) &#123; printf(\"%s%20s%5c%5d%8.1lf\\n\", t[i].sno, t[i].name, t[i].sex, t[i].age, t[i].score); &#125;&#125; 运行结果： 编程练习1声明结构体类型 struct book，描述图书信息：书名（title）、作者（author）、出版社（press）、价格（price）、数量（amount）。已知函数头及功能如下： 123void input(int n, struct book t[ ]); // 输入n本图书的信息到一维数组t中void sort(int n, struct book t[ ]); // 对长度为n的一维数组t中的数组元素按价格升序排序void output(int n, struct book t[[ ]); // 输出长度为n的一维数组t中的数组元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;struct book&#123; char title[30]; char author[20]; char press[30]; double price; int amount;&#125;;void input(int n, struct book t[ ]);void sort(int n, struct book t[ ]);void output(int n, struct book t[ ]);int main(void)&#123; struct book b[5]; input(5, b); sort(5, b); output(5, b);&#125;void input(int n, struct book t[ ])&#123; int i; printf(\"请输入%d本图书的资料（书名，作者，出版社，价格，数量）\\n\", n); for(i = 0;i &lt; n;i ++) &#123; scanf(\"%s%s%s%lf%d\", t[i].title, t[i].author, t[i].press, &amp;t[i].price, &amp;t[i].amount); getchar(); &#125;&#125;void sort(int n, struct book t[ ])&#123; // 按照价格升序顺序排列 int i,j; struct book temp; for(i = 0;i &lt; n;i ++) &#123; for(j = 0;j &lt; (n - 1) - i;j ++) &#123; if(t[j].price &gt; t[j + 1].price) &#123; temp = t[j]; t[j] = t[j + 1]; t[j + 1] = temp; &#125; &#125; &#125;&#125;void output(int n, struct book t[ ])&#123; int i; puts(\"title\\t\\tauthor\\t\\tpress\\t\\tprice\\t\\tamount\"); for(i = 0;i &lt; n;i ++) &#123; printf(\"%s\\t\\t%s\\t\\t%s\\t\\t%.1lf\\t\\t%d\\n\", t[i].title, t[i].author, t[i].press, t[i].price, t[i].amount); &#125;&#125; 运行结果： 编程练习2struct mycomplex 是表示复数的结构体类型，成员 real 表示实部，成员 image 表示虚部。已知函数头及功能如下： 123456789struct mycomplex&#123; double real; double image;&#125;;struct mycomplex input(void); // 输入并返回一个复数struct mycomplex add(struct mycomplex c1, struct mycomplex c2); // 计算并返回两个复数的和struct mycomplex mul(struct mycomplex c1, struct mycomplex c2); // 计算并返回两个复数的乘积void output(struct mycomplex c); // 输出一个复数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;struct mycomplex&#123; double real; double image;&#125;;struct mycomplex input(void); // 输入并返回一个复数struct mycomplex add(struct mycomplex c1, struct mycomplex c2); // 计算并返回两个复数的和struct mycomplex mul(struct mycomplex c1, struct mycomplex c2); // 计算并返回两个复数的乘积void output(struct mycomplex c); // 输出一个复数int main(void)&#123; struct mycomplex c1, c2, c3, c4; c1 = input(); c2 = input(); c3 = add(c1, c2); c4 = mul(c1, c2); output(c3); output(c4);&#125;struct mycomplex input(void)&#123; struct mycomplex c; printf(\"请输入复数的实部和虚部：\"); scanf(\"%lf%lf\", &amp;c.real, &amp;c.image); return c;&#125;struct mycomplex add(struct mycomplex c1, struct mycomplex c2)&#123; int i, j; struct mycomplex c; i = c1.real + c2.real; j = c1.image + c2.image; c.real = i; c.image = j; return c;&#125;struct mycomplex mul(struct mycomplex c1, struct mycomplex c2)&#123; struct mycomplex c; int i, j; i = c1.real * c2.real - c1.image * c2.image; j = c1.image * c2.real + c1.real * c2.image; c.real = i; c.image = j; return c;&#125;void output(struct mycomplex c)&#123; printf(\"%.lf + %.lfi\\n\", c.real, c.image);&#125; 运行结果： 1234请输入复数的实部和虚部：1 2请输入复数的实部和虚部：3 44 + 6i-5 + 10i 单链表单链表的元素称为结点，每个结点包括两个域：存储实际数据的域称为数据域；存储下一个结点地址的域称为指针域。 为了在编程时方便处理，往往在单链表的第一个结点之前附设一个结点，称为头结点 头结点的数据域不存储任何信息，头结点的指针域存储第一个结点的地址 动态存储库函数 库函数 malloc 所需包含的头文件：stdlib.h。 函数原型： 1void *malloc(unsigned int size); 功能：分配长度为size个字节的存储单元，当执行成功时，返回一个指向所分配存储单元起始地址的指针；否则，返回NULL 库函数 free 所需包含的头文件：stdlib.h。 函数原型： 1void free(void *ptr); 功能：释放指针变量 ptr 指向的存储单元 例题1调用库函数 malloc 和 free ，分配 、释放存储单元。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct student&#123; char sno[8]; char name[20]; char sex; int age; double score;&#125;;int main(void)&#123; struct student *p; puts(\"Input the students' information(sex, sno, name, age, score)\"); p = (struct student *)malloc(sizeof(struct student)); scanf(\"%c%s%s%d%lf\", &amp;p-&gt;sex, p-&gt;sno, p-&gt;name, &amp;p-&gt;age, &amp;p-&gt;score); printf(\"sno: %s\\n\", p-&gt;sno); printf(\"name: %s\\n\", p-&gt;name); printf(\"sex: %c\\n\", p-&gt;sex); printf(\"age: %d\\n\", p-&gt;age); printf(\"score: %.1lf\\n\", p-&gt;score); free(p); p = NULL; return 0;&#125; 运行结果： 1234567Input the students&#39; information(sex, sno, name, age, score)M 2015001 LiMing 18 92.5sno: 2015001name: LiMingsex: Mage: 18score: 92.5 单链表的基本操作通常用结构体类型的变量来表示单链表中的结点，一个结构体类型的变量包含若干成员，用指针类型的成员存储下一个结点的地址。 123456789struct student&#123; char sno[8]; char name[20]; char sex; int age; double score; struct student *next;&#125; 其中，成员 sno、name、sex、age 和 score 一起作为数据域，存储实际数据；成员next 是指向结构体类型 struct student 的指针变量，将成员next 作为指针域，存储下一个节点的地址。 实例1建立一个学生信息的单链表，输出单链表中的学生信息，然后销毁单链表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct student&#123; char sno[8]; char name[20]; char sex; int age; double score; struct student *next;&#125;;// 将p 指向的节点作为第一个节点插入到以head为头指针的单链表中void insert_node(struct student *head, struct student *p);// 输出以 head 为头指针的单链表中所有学生的信息void traverse(struct student *head);// 删除以head为头指针的单链表的第一个节点void delete_node(struct student *head);int main(void)&#123; struct student *h, *q; int i, n; printf(\"Input the number of students:\"); scanf(\"%d\", &amp;n); getchar(); // 读入并丢弃“回车符” // 创建头节点，并设置头结点的指针域为空 h = (struct student *)malloc(sizeof(struct student)); h -&gt; next = NULL; printf(\"Input %d students' information(sex, sno, name, age, score):\\n\", n); for(i = 0;i &lt; n;i ++) &#123; // 创建新节点 q = (struct student *)malloc(sizeof(struct student)); // 读入学生信息 scanf(\"%c%s%s%d%lf\", &amp;q-&gt;sex, q-&gt;sno, q-&gt;name, &amp;q-&gt;age, &amp;q-&gt;score); getchar(); // 读入并丢弃“回车符” // 将新节点作为第一个节点插入到单链表中 insert_node(h, q); &#125; traverse(h); while(h-&gt;next) &#123; delete_node(h); &#125; free(h); h = NULL; return 0;&#125;void insert_node(struct student *head, struct student *p)&#123; p -&gt; next = head -&gt; next; head -&gt; next = p;&#125;void traverse(struct student *head)&#123; struct student *p; puts(\" sno name sex age score\"); p = head -&gt; next; // 将p指向单链表的第一个结点 // 当p等于NULL时，整个链表输出完成，while语句结束 while(p) &#123; // 输出p所指结点的数据域，即学生信息 printf(\"%s%20s%5c%5d%8.1lf\\n\", p-&gt;sno, p-&gt;name, p-&gt;sex, p-&gt;age, p-&gt;score); p = p -&gt; next; // 使p指向下一个结点 &#125;&#125;void delete_node(struct student *head)&#123; struct student *p; p = head -&gt; next; head -&gt; next = p -&gt; next; printf(\"Deleting the student %s ...\\n\", p-&gt;sno); free(p); p = NULL;&#125; 运行结果： 共同体声明共同体类型声明共同体声明的一般形式： 1234union [标记名称]&#123; 成员列表&#125;; 共同体类型的变量声明 先声明共同体类型再声明变量 12345union 标记名称&#123; 成员列表&#125;;union 标记名称 变量名1 [, 变量名2, 变量名3, ...]; 例如： 1234567union data&#123; char ch; int i; double d;&#125;;union data x; 在声明共同体类型的同时声明变量 1234union 标记名称&#123; 成员列表&#125; 变量名1 [, 变量名2, 变量名3, ...]; 例如： 123456union data&#123; char ch; int i; double d;&#125; x1, x2; 使用匿名共同体类型声明变量 1234union&#123; 成员变量&#125; 变量名1 [, 变量名2, 变量名3, ...]; 例如： 123456union&#123; char ch; int i; double d;&#125; x1, x2; 初始化共同体类型的变量在共同体类型的变量声明时给变量赋值，称为初始化。只能对共同体类型变量的第一个成员赋值，不能像结构体类型的变量那样对所有的成员赋值。例如： 123456789union data&#123; char ch; int i; double d;&#125;;union data x1, x2;union data x1 = &#123;'s'&#125;; //正确，为第一个成员ch赋值's'union data x2 = &#123;'s', 100, 95.5&#125;; //错误 引用共同体类型的变量引用共同体类型的变量应遵守以下规则： 不能将共同体类型的变量作为一个整体进行输入和输出。 除了初始化，在其他位置只能用同类型的变量为共同体类型的变量赋值，或者为其他成员赋值。 共同体类型的变量中起作用的成员是最后一次赋值的成员，在给一个成员赋值后原有的成员就会失去作用。 例题建立如表所示的成绩单，输入各科成绩，然后再输出。 课程名 评分方式 分数 等级 C Language Programming 百分制 90 College Chinese 五级分制 excellent Advanced Mathematics 百分制 88 Introduction to Computers 五级分制 good 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;string.h&gt;union method&#123; int hundred; // 百分制成绩 char five[10]; // 五级分制成绩&#125;;struct course&#123; char name[30]; // 课程名称 char mode; // 评分方式（h：百分制，f：五级制） union method grade; // 共同体类型的成员表示不同类型的成绩&#125;;int main(void)&#123; struct course report[4]; int i; // 将课程名称存入结构体类型 strcpy(report[0].name, \"C Language Programming\"); strcpy(report[1].name, \"College Chinese\"); strcpy(report[2].name, \"Advanced Mathematics\"); strcpy(report[3].name, \"Introduction to Computers\"); // 输入各门课程的评分方式、考试成绩 for(i = 0;i &lt; 4;i ++) &#123; printf(\"Input the mode(h/f) of course \\\"%s\\\": \", report[i].name); scanf(\"%c\", &amp;report[i].mode); printf(\"Examination Result: \"); // 根据评分方式输入不同类型的考试成绩 if('h' == report[i].mode) &#123; scanf(\"%d\", &amp;report[i].grade.hundred); &#125; else &#123; scanf(\"%s\", report[i].grade.five); &#125; getchar(); // 读入并丢弃回车符 &#125; puts(\"\\nname mode grade\"); for(i = 0;i &lt; 4;i ++) &#123; printf(\"%-30s%-16c\", report[i].name, report[i].mode); // 根据评分方式输出不同类型的考试成绩 if('h' == report[i].mode) &#123; printf(\"%d\\n\", report[i].grade.hundred); &#125; else &#123; printf(\"%s\\n\", report[i].grade.five); &#125; &#125; return 0;&#125; 运行结果： 枚举类型所谓”枚举”，就是将变量的可取值一一列举出来，变量只能存、取其中的某个值，存、取其他值是错误的 枚举类型声明枚举类型声明的一般形式： 1enum [标记名称] &#123;枚举常量1[, 枚举常量2, 枚举常量3, ...]&#125;; 标记名称是一个标识符，也可以省略标记名称，表示匿名枚举类型 枚举常量是类型为 int 的标识符 枚举类型声明既可以放在函数之外，被其作用范围内的所有函数使用；也可以放在某个函数的函数体内，只能在该函数的函数体内使用 枚举常量的值*在枚举类型声明中，枚举常量的值从 0 开始，依次加 1 * 1enum weekday &#123;sun, mon, tue, wed, thu, fri, sat&#125;; 枚举常量 sun mon tue wed thu fri sat 枚举常量的值 0 1 2 3 4 5 6 例题输出枚举常量的值。 12345678910111213#include &lt;stdio.h&gt;enum weekday &#123;sun, mon, tue, wed, thu = 10, fri, sat&#125;;int main(void)&#123; printf(\"sun: %d\\n\", sun); printf(\"mon: %d\\n\", mon); printf(\"tue: %d\\n\", tue); printf(\"wed: %d\\n\", wed); printf(\"thu: %d\\n\", thu); printf(\"fri: %d\\n\", fri); printf(\"sat: %d\\n\", sat); return 0;&#125; 运行结果： 1234567sun: 0mon: 1tue: 2wed: 3thu: 10fri: 11sat: 12 枚举类型的变量声明 先声明枚举类型再声明变量 12enum 标记名称 &#123;枚举常量1[, 枚举常量2, 枚举常量3, ...]&#125;;enum 标记名称 变量名1 [, 变量名2, 变量名3, ...]; 在声明枚举类型的同时声明变量 1enum 标记名称 &#123;枚举常量1[, 枚举常量2, ...]&#125; 变量名1 [, 变量名2, ...]; 使用匿名枚举类型声明变量 1enum &#123;枚举变量1[, 枚举变量2, ...]&#125; 变量名1 [, 变量名2, ...]; 例题1枚举类型的变量。 1234567891011#include &lt;stdio.h&gt;enum weekday &#123;sun, mon, tue, wed, thu, fri, sat&#125;;int main(void)&#123; enum weekday today, tomorrow; today = mon; tomorrow = (enum weekday)(today + 1); printf(\"today: %d\\n\", today); printf(\"tomorrow: %d\\n\", tomorrow); return 0;&#125; 运行结果： 12today: 1tomorrow: 2 例题2间接输入、输出枚举类型的变量。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;enum weekday &#123;sun, mon, tue, wed, thu, fri, sat&#125;;int main(void)&#123; enum weekday today, tomorrow; char *s[ ] = &#123;\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\"&#125;; int day; printf(\"What day is today:\\n\"); printf(\"0--sun,1--mon,2--tue,3--wed,4--thu,5--fri,6--sat： \"); scanf(\"%d\", &amp;day); // 通过输入一个整数获知今天是星期几 today = (enum weekday)day; // 根据today计算tomorrow if(sat == today) &#123; tomorrow = sun; &#125; else &#123; tomorrow = (enum weekday)(today + 1); &#125; printf(\"Tomorrow is %s.\\n\", s[tomorrow]); return 0;&#125; 运行结果： 123What day is today:0--sun,1--mon,2--tue,3--wed,4--thu,5--fri,6--sat: 5Tomorrow is sat. 编程练习输入五个学生的信息到数组 s 中，查找并输出平均成绩最高的学生的信息。 123456789struct student&#123; char sno[8]; //学号 char name[20]; //姓名 enum &#123;male, female&#125; sex; // 性别 int age; // 年龄 double score[3]; //成绩&#125;;struct student s[5]; typedef 声明 typedef声明(typedef declaration)并没有引入新类型，只是为已有类型引入一个同义词 为已有类型引入一个同义词的方法： 1234①声明变量②将变量名换成新类型名③在最前面加上typedef④使用新类型名声明变量","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"变量的属性和编译预处理","slug":"c_9","date":"2021-03-15T09:02:14.000Z","updated":"2021-07-17T02:37:16.116Z","comments":true,"path":"2021/03/15/c_9/","link":"","permalink":"https://imqinhao.cn/2021/03/15/c_9/","excerpt":"变量的作用域 变量的存储类别 宏定义 文件包含 条件编译","text":"变量的作用域 变量的存储类别 宏定义 文件包含 条件编译 变量的作用域 变量都有自己的作用域，按照作用域的范围可分为两种：局部变量和全局变量。 局部变量在函数内声明的变量是局部变量，它只在本函数内有效。 关于局部变量的说明如下 main 函数内申明的变量也只在 main 函数内有效，main 函数不能使用其他函数中声明的局部变量。 不同函数内可以声明同名的局部变量，他们代表不同的对象，互不干扰。 形参也是局部变量。 全局变量在函数之外声明的变量称为全局变量。全局变量的作用范围是从声明变量的位置到本源文件的末尾。 关于全局变量的说明如下 全局变量增加了函数间数据联系的渠道。 如果全局变量与局部变量同名，则在局部变量的作用范围内，全局变量被屏蔽，不起作用。 编程练习1编写并调用函数 exchange ，用于交换 int 类型全局变量 x 、 y 的值。 123456789101112131415161718192021#include &lt;stdio.h&gt;int x, y;void exchange(void);int main(void)&#123; printf(\"请输入x的值：\"); scanf(\"%d\", &amp;x); printf(\"请输入y的值：\"); scanf(\"%d\", &amp;y); printf(\"x = %d , y = %d\\n\", x, y); exchange(); printf(\"now x = %d , y = %d\\n\", x, y); return 0;&#125;void exchange(void)&#123; int temp; temp = x; x = y; y = temp;&#125; 变量的存储类别变量的存储类别分为六种：自动的（auto）、静态的（static）、寄存器的（register）、外部的（extern）、typedef、_Thread_local。 静态存储变量：是指在程序运行期间分配固定的存储空间的方式。 动态存储变量：是指在程序运行期间根据需要进行动态的分配空间的方式。 内存中供用户使用的存储空间的情况分为三部分：程序区；静态存储区；动态存储区。 全局变量存放在静态存储区中，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。在程序执行过程中它们占据固定的存储单元，而不是动态地分配和释放的。 局部变量的存储类别 函数中的局部变量，如不做专门的说明，都是动态的分配存储空间的，存储在动态存储区中。对它们分配和释放存储空间的工作是由编译系统自动处理的，因此这类局部变量称为自动变量。 自动变量用关键字auto作存储类型的说明。 如果声明局部变量时没有指定存储类别，默认为auto，通常称为自动变量。例如：int n; // 等价于 auto int n; 有时希望函数中的局部变量的值在函数调用结束后不消失而保留原值，即其占用的存储单元不释放，在下一次该函数调用时，该变量的值是上一次函数调用结束时的值。这时就可以指定该局部变量为“静态局部变量”，用static指定存储类别。 静态局部变量的说明： 静态局部变量占用的存储单元在程序整个运行期间都不释放；而自动变量在函数调用时分配存储单元，函数调用结束，存储单元被释放。 静态局部变量在编译时赋初值，即只赋初值一次；而对自动变量赋初值是在函数调用时进行，每调用一次函数重新赋一次初值。 声明静态局部变量时没有初始化，静态局部变量的值是0（对数值型变量）或空字符（对char类型变量）；声明自动变量时没有初始化，自动变量的值是不确定的。 例题1静态局部变量实例。 1234567891011121314151617181920#include &lt;stdio.h&gt;int f(int a);int main(void)&#123; int i, a = 2; for(i = 0;i &lt; 3;i ++) &#123; printf(\"%6d\", f(a)); &#125; printf(\"\\n\"); return 0;&#125;int f(int a)&#123; int b = 0; static int c = 3; b = b + 1; c = c + 1; return a + b + c;&#125; 运行结果 17 8 9 先后三次调用函数 f 时，变量 b 、 c 的值如图所示： 例题2输出1 ~ 5 的阶乘值。 1234567891011121314151617#include &lt;stdio.h&gt;double factorial(int n);int main(void)&#123; int i; for(i = 1;i &lt;= 5;i ++) &#123; printf(\"%d! = %.0lf\\n\", i, factorial(i)); &#125; return 0;&#125;double factorial(int n)&#123; static double f = 1.0; f *= n; return f;&#125; 运行结果 123451! &#x3D; 12! &#x3D; 23! &#x3D; 64! &#x3D; 245! &#x3D; 120 如果有一些变量使用频繁，为提高执行效率，C 语言允许将局部变量的值存储在寄存器中，以提高执行效率。这种变量叫寄存器变量，用register指定存储类别。 全局变量的存储类别 全局变量有 extern 和 static 两种存储类别。如果声明全局变量时没有指定存储类别，默认为 extern 。 如果全局变量不在文件的开头声明，其作用域只限于声明点到源文件末尾。如果在声明点之前的函数想使用该全局变量，则应该在使用之前用关键字extern对该变量声明，表示该变量是一个已经声明的全局变量，以扩展全局变量的作用域。 例题1用 extern 声明全局变量，扩展全局变量的作用域。 123456789101112131415#include &lt;stdio.h&gt;int max(int x, int y);int main(void)&#123; extern int a, b; printf(\"max = %d\\n\", max(a, b)); return 0;&#125;int max(int x, int y)&#123; int z; z = x &gt; y ? x : y; return z;&#125;int a = 15, b = 8; 该程序的运行结果： 1max &#x3D; 15 原本 main 函数不在全局变量 a 、 b 的作用范围内，用 extern 对使用全局变量 a 、 b 进行声明，就可以在 main 函数内使用全局变量 a 、 b 。 宏定义编译预处理是在编译前对源程序进行的一些预加工。它是 C 语言与其他高级语言的一个重要区别，有助于编写易移植、易调试的程序。 不带参数的宏定义一般形式： 1#define 宏名 宏体 例题1计算圆的面积。 1234567891011#include &lt;stdio.h&gt;#define PI 3.1415926int main(void)&#123; double r, s; printf(\"Input the radius: \"); scanf(\"%lf\", &amp;r); s = PI * r * r; printf(\"s = %.2lf\\n\", s); return 0;&#125; 点击查看说明 宏名的替换过程其实是一种简单的复制工作，它不做任何计算，也不做任何错误检查，错误的检查工作要等到编译过程中才会进行。 宏名通常用大写字母表示。 例题2计算圆的周长。 123456789#include &lt;stdio.h&gt;#define R 3.0#define PI 3.1415926#define L 2 * PI * Rint main(void)&#123; printf(\"L = %.2lf\\n\", L); return 0;&#125; 运行结果 1L &#x3D; 18.85 带参数的宏定义一般形式： 1#define 宏名(参数表) 宏体 点击查看注意 宏名与参数表的括号之间不可有空格符；否则，系统将把程序中的宏名替换成空格后的字符串，变成不带参数的宏定义。 例题1计算长方形的面积。 1234567891011#include &lt;stdio.h&gt;#define S(a, b) a * bint main(void)&#123; double x, y; printf(\"Input the length and the width: \"); scanf(\"%lf%lf\", &amp;x, &amp;y); printf(\"S = %.2lf\\n\", S(x, y)); return 0;&#125; 运行结果 12Input the length and the width: 3 4S &#x3D; 12.00 带参数的宏定义与带形参的函数，他们从形式上与特征上都很相似，但他们在本质上是不同的： 函数调用时是在程序的执行过程中进行的，而宏调用是在预处理中进行的，宏名被替换后，宏体将是程序的一部分。 在函数调用时，要先求实参的值，然后将这个值赋给形参，而宏调用时，只是简单地用实参替换宏体中的形参。 例题2宏调用是简单的替换。 1234567#include &lt;stdio.h&gt;#define SUM(a, b) a * bint main(void)&#123; printf(\"SUM = %d\\n\", SUM(1 + 2, 3 + 4)); return 0;&#125; 运行结果 1SUM &#x3D; 11 宏调用 SUM(1 + 2 编程练习定义并调用带参数的宏，交换两个参数的值。 12345678910#include &lt;stdio.h&gt;#define EXCHANGE(a, b) b,aint main(void)&#123; int x = 5, y = 3; printf(\"x = %d , y = %d\\n\", x, y); printf(\"now, x = %d , y = %d\\n\", EXCHANGE(x, y)); return 0;&#125; 运行结果 12x &#x3D; 5 , y &#x3D; 3now, x &#x3D; 3 , y &#x3D; 5 文件包含文件包含也叫宏包含，是编译预处理的一个重要功能，通过预处理命令#include把另一个文件的整个内容嵌入进来。文件包含有以下两种方式： 第一种形式 1#include \"文件名\" 首先在源文件所在目录中检索指定的文件；如果没有找到，则按系统规定的标准方式检索文件目录，直至找到文件为止。 第二种形式 1#include &lt;文件名&gt; 只按系统规定的标准方式检索文件目录，直至找到文件为止。 条件编译编译预处理提供了条件编译的功能，可以根据条件编译程序的不同部分，从而产生不同的目标代码文件。 第一种形式 12345#ifdef 标识符 程序段1#else 程序段2#endif 功能：如果标识符已被 #define命令定义过，则对程序段1进行编译；否则，对程序段2进行编译。 第二种形式 12345#ifndef 标识符 程序段1#else 程序段2#endif 功能：如果标识符没有被 #define命令定义过，则对程序段1进行编译；否则，对程序段2进行编译。这与第一种形式的功能正好相反。 第三种形式 12345#if 常量表达式 程序段1#else 程序段2#endif 功能：如果常量表达式的值不等于0，则对程序段1进行编译；否则，对程序段2进行编译。 例题1条件编译示例。 1234567891011121314151617#include &lt;stdio.h&gt;#define PI 3.1415926#define R 1int main(void)&#123; double r, c, s; printf(\"Input the radius: \"); scanf(\"%lf\", &amp;r);#if R s = PI * r * r; printf(\"s = %.2lf\\n\", s);#else c = 2 * PI * r; printf(\"c = %.2lf\\n\", c);#endif return 0;&#125; 运行结果 12Input the radius: 5s &#x3D; 78.54","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"函数","slug":"c_8","date":"2021-03-08T09:02:14.000Z","updated":"2021-07-17T02:37:04.962Z","comments":true,"path":"2021/03/08/c_8/","link":"","permalink":"https://imqinhao.cn/2021/03/08/c_8/","excerpt":"函数编程练习题","text":"函数编程练习题 编程练习1已知函数头为 void avg(void) ，写出函数定义。函数 avg 的功能：输入10个分数，去掉最高分和最低分后求平均分，保留一位小数。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;void avg(void);int main(void)&#123; printf(\"******************************** 编程练习8.1 ********************************\\n\"); avg( );&#125;void avg(void)&#123; double score[10], max, min, average, sum = 0.0; int i; for(i = 0;i &lt; 10;i ++) &#123; printf(\"请输入第%d个分数：\", i + 1); scanf(\"%lf\", &amp;score[i]); &#125; max = score[0]; min = score[0]; for(i = 0;i &lt; 10;i ++) &#123; sum += score[i]; if(max &lt; score[i]) &#123; max = score[i]; &#125; if(min &gt; score[i]) &#123; min = score[i]; &#125; &#125; average = (sum - max - min) / 8; printf(\"平均分：%.1lf\\n\", average);&#125; 运行结果： 123456789101112******************************** 编程练习8.1 ********************************请输入第1个分数：95请输入第2个分数：88请输入第3个分数：77请输入第4个分数：86请输入第5个分数：93请输入第6个分数：86请输入第7个分数：79请输入第8个分数：83请输入第9个分数：92请输入第10个分数：99平均分：87.8 编程练习2$$已知函数头为 void calroot(double a, double b, double c) ，写出函数定义。函数calroot的功能：求一元二次方程ax^2+bx+c=0的根。形参a、b、c是一元二次方程的系数。$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;math.h&gt;void calroot(double a, double b, double c);int main(void)&#123; double a1,b1,c1; printf(\"********************************* 编程练习8.2 *********************************\\n\"); printf(\"请输入a的值：\"); scanf(\"%lf\", &amp;a1); printf(\"请输入b的值：\"); scanf(\"%lf\", &amp;b1); printf(\"请输入c的值：\"); scanf(\"%lf\", &amp;c1); calroot(a1, b1, c1);&#125;void calroot(double a, double b, double c)&#123; double x1, x2, d, e, real, imaginarys; d = b * b - 4 * a * c; if ( 0 == a) &#123; if( 0 == b) &#123; printf(\"error!\\n\"); &#125; else &#123; printf(\"x = %f\\n\", -c / b); &#125; &#125; else if(0 == d) &#123; x1 = x2 = -b / (2 * a); printf(\"x1 = x2 = %f\\n\", x1); &#125; else if(d &gt; 0) &#123; e = sqrt(d); x1 = (-b + e) / (2 * a); x2 = (-b - e) / (2 * a); printf(\"x1 = %f\\n\", x1); printf(\"x2 = %f\\n\", x2); &#125; else &#123; e = sqrt(-d); real = -b / (2 * a); imaginarys = e / (2 * a); printf(\"x1 = %f + %fi\\n\", real, imaginarys); printf(\"x2 = %f - %fi\\n\", real, imaginarys); &#125;&#125; 运行结果： 12345********************************* 编程练习8.2 *********************************请输入a的值：0请输入b的值：1.5请输入c的值：-5.4x &#x3D; 3.600000 编程练习3$$已知函数头为 double sum(int n) ，写出函数定义。函数sum的功能：返回1-\\frac{1}{2}+\\frac{1}{3}-\\frac{1}{4}+…+\\frac{(-1)^{n+1}}{n}的值，其中n即为形参n。$$ 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;double sum(int n);int main(void)&#123; int n; printf(\"请输入n的值：\"); scanf(\"%d\", &amp;n); double result = sum(n); printf(\"********************************* 编程练习8.3 *********************************\\n\"); printf(\"result = %.2lf\\n\", result);&#125;double sum(int n)&#123; int i; double sum = 0.0; for(i = 1;i &lt;= n;i ++) &#123; if(i % 2 == 0) &#123; sum -= 1.0 / i; &#125; else &#123; sum += 1.0 / i; &#125; &#125; return sum;&#125; 运行结果： 123请输入n的值：4********************************* 编程练习8.3 *********************************result &#x3D; 0.58 编程练习4已知函数头为 int getgcd(int m, int n) ，写出函数定义。函数 getgcd 的功能：返回形参m 、 n 的最大公约数。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int getgcd(int m, int n);int main(void)&#123; int a, b; printf(\"********************************* 编程练习8.4 *********************************\\n\"); printf(\"请输入m的值：\"); scanf(\"%d\", &amp;a); printf(\"请输入n的值：\"); scanf(\"%d\", &amp;b); int result = getgcd(a, b); printf(\"最大公约数为：%d\\n\", result);&#125;int getgcd(int m, int n)&#123; int gcd; if(m &gt; n) &#123; gcd = n; &#125; else &#123; gcd = m; &#125; while(m % gcd || n % gcd) &#123; gcd --; &#125; return gcd;&#125; 运行结果： 1234********************************* 编程练习8.4 *********************************请输入m的值：9请输入n的值：3最大公约数为：3 编程练习5已知函数头为 int prime(int n) ， 写出函数定义。函数 prime 的功能，如果 n 是质数，返回1；否则，返回0 。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;math.h&gt;int prime(int n);int main(void)&#123; int a; printf(\"请输入n的值：\"); scanf(\"%d\", &amp;a); int result = prime(a); printf(\"%d\\n\", result);&#125;int prime(int n)&#123; int i; if(n == 2) &#123; return 1; &#125; else if(n &gt; 2) &#123; for(i = 2;i &lt; sqrt(n) + 1;i ++) &#123; if(n % i == 0) &#123; return 0; break; &#125; &#125; return 1; &#125; else &#123; printf(\"error\\n\"); return 0; &#125;&#125; 运行结果： 12请输入n的值：51 12请输入n的值：40 函数练习6已知函数头为 void avg(void) ，函数 avg 的功能：输入10个分数，去掉最高分和最低分，求平均分，保留一位小数。编写并调用函数avg。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;void avg(void);int main(void)&#123; avg( ); return 0;&#125;void avg(void)&#123; int i; double max, min, sum = 0.0, average, score[10]; for(i = 0;i &lt; 10;i ++) &#123; printf(\"请输入第%d个成绩：\", i + 1); scanf(\"%lf\", &amp;score[i]); &#125; max = score[0]; min = score[0]; for(i = 0;i &lt; 10;i ++) &#123; sum += score[i]; if(max &lt; score[i]) &#123; max = score[i]; &#125; if(min &gt; score[i]) &#123; min = score[i]; &#125; &#125; average = (sum - max - min) / 8; printf(\"去掉最高分：%.1lf 分\\n\", max); printf(\"去掉最低分：%.1lf 分\\n\", min); printf(\"平均分为：%.1lf\\n\", average);&#125; 运行结果： 12345678910111213请输入第1个成绩：95请输入第2个成绩：99请输入第3个成绩：78请输入第4个成绩：85请输入第5个成绩：93请输入第6个成绩：85请输入第7个成绩：86请输入第8个成绩：91请输入第9个成绩：87请输入第10个成绩：91去掉最高分：99.0 分去掉最低分：78.0 分平均分为：89.1 编程练习7$$已知函数头为 void calroot(double a, double b, double c) ，函数 calroot 的功能：求一元二次方程ax^2+bx+c=0的根。形参a、b、c是一元二次方程的系数，编写并调用函数 calroot。$$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;math.h&gt;void calroot(double a, double b, double c);int main(void)&#123; double a1, b1, c1; printf(\"请输入a的值：\"); scanf(\"%lf\", &amp;a1); printf(\"请输入b的值：\"); scanf(\"%lf\", &amp;b1); printf(\"请输入c的值：\"); scanf(\"%lf\", &amp;c1); calroot(a1, b1, c1); return 0;&#125;void calroot(double a, double b, double c)&#123; double d, e, x1, x2, real, imaginarys; d = b * b - 4 * a * c; if(0 == a) &#123; if(0 == b) &#123; printf(\"error\\n\"); &#125; else &#123; printf(\"x = %lf\\n\", -c / b); &#125; &#125; else if( 0 == d) &#123; x1 = x2 = -b / (2 * a); printf(\"x1 = x2 = %lf\\n\", x1); &#125; else if(d &gt; 0) &#123; e = sqrt(d); x1 = (-b + e) / (2 * a); x2 = (-b - e) / (2 * a); printf(\"x1 = %lf\\n\", x1); printf(\"x2 = %lf\\n\", x2); &#125; else &#123; e = sqrt(-d); real = -b / (2 * a); imaginarys = e / (2 * a); printf(\"x1 = %lf + %lfi\\n\", real, imaginarys); printf(\"x2 = %lf - %lfi\\n\", real, imaginarys); &#125; &#125; 运行结果： 1234请输入a的值：0请输入b的值：1.5请输入c的值：-5.4x &#x3D; 3.600000 编程练习8$$已知函数头为 double sum(int n) ，写出函数定义。函数sum的功能：返回1-\\frac{1}{2}+\\frac{1}{3}-\\frac{1}{4}+…+\\frac{(-1)^{n+1}}{n}的值，其中n即为形参n。编写并调用函数sum。$$ 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;double sum(int n);int main(void)&#123; int a; double result; printf(\"Please input value of n: \"); scanf(\"%d\", &amp;a); result = sum(a); printf(\"result = %.2lf\\n\", result); return 0;&#125;double sum(int n)&#123; int i; double s; for(i = 1;i &lt;= n;i ++) &#123; if(i % 2 == 0) &#123; s -= 1.0 / i; &#125; else &#123; s += 1.0 / i; &#125; &#125; return s;&#125; 运行结果： 12Please input value of n: 4result &#x3D; 0.58 编程练习9已知函数头为 int getgcd(int m, int n) ，写出函数定义。函数 getgcd 的功能：返回形参m 、 n 的最大公约数。编写并调用函数 getgcd 。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int getgcd(int m, int n);int main(void)&#123; int a, b, result; printf(\"请输入m的值：\"); scanf(\"%d\", &amp;a); printf(\"请输入n的值：\"); scanf(\"%d\", &amp;b); result = getgcd(a, b); printf(\"%d 和 %d 的最大公约数为：%d\\n\", a, b, result); return 0;&#125;int getgcd(int m, int n)&#123; int gcd; if(m &gt; n) &#123; gcd = m; &#125; else &#123; gcd = n; &#125; while(gcd % m || gcd % n) &#123; gcd ++; &#125; return gcd;&#125; 运行结果： 123请输入m的值：9请输入n的值：69 和 6 的最大公约数为：18 编程练习10已知函数头为 int prime(int n) ， 写出函数定义。函数 prime 的功能，如果 n 是质数，返回1；否则，返回0 。编写并调用函数 prime 输出 100 以内所有的质数，每行输出5个 。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;math.h&gt;int prime(int n);int main(void)&#123; int i, res, times = 0; for(i = 2;i &lt; 100;i ++) &#123; res = prime(i); if(res == 1) &#123; times ++; if(times % 5 == 0) &#123; printf(\"%d\\n\", i); &#125; else &#123; printf(\"%d\\t\", i); &#125; &#125; &#125; return 0;&#125;int prime(int n)&#123; int j, flag = 1; if(n == 2) &#123; return 1; &#125; for(j = 2;j &lt; sqrt(n) + 1;j ++) &#123; if(n % j == 0) &#123; flag = 0; break; &#125; &#125; return flag;&#125; 运行结果： 123452 3 5 7 1113 17 19 23 2931 37 41 43 4753 59 61 67 7173 79 83 89 97 编程练习11定义两个函数分别计算球体的表面积和体积，在main函数中输入球体的半径，调用这两个函数，在 main 函数中输出球体的表面积和体积。 12345678910111213141516171819202122#include &lt;stdio.h&gt;double get_ball_s(double r);double get_ball_v(double r);int main(void)&#123; double a, s, v; printf(\"请输入球体的半径：\"); scanf(\"%lf\", &amp;a); s = get_ball_s(a); v = get_ball_v(a); printf(\"球体的表面积为：%.2lf\\n\", s); printf(\"球体的体积为：%.2lf\\n\", v); return 0;&#125;double get_ball_s(double r)&#123; return 4 * 3.14 * r * r;&#125;double get_ball_v(double r)&#123; return (4 / 3.0) * 3.14 * r * r * r;&#125; 运行结果： 123请输入球体的半径：5球体的表面积为：314.00球体的体积为：523.33 编程练习12已知函数头为 int avg(int n, int t[ ]) ，函数avg的功能：去掉长度为 n 的一维数组 t 中的最大值和最小值，计算并返回平均值。编写并调用函数avg。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int avg(int n,int t[ ]);int main(void)&#123; int s[9] = &#123;52, 99, 33, 44, 20, 13, 14, 9, 101&#125;; int average; average = avg(9, s); printf(\"average = %d\\n\", average); return 0;&#125;int avg(int n, int t[ ])&#123; int max, min, i, sum; max = t[0]; min = t[0]; for(i = 0;i &lt; n;i ++) &#123; sum += t[i]; if(max &lt; t[i]) &#123; max = t[i]; &#125; if(min &gt; t[i]) &#123; min = t[i]; &#125; &#125; return (sum - max - min) / (n - 2);&#125; 运行结果： 1average &#x3D; 39 编程练习13已知函数头为 int str_cmp(char s1[ ], char s2[ ]) ，函数 str_cmp 的功能：比较数组 s1 和 s2 中字符串的大小，如果 s1 中的字符串大于 s2 中的字符串，返回一个正整数；如果 s1 中的字符串等于 s2 中的字符串，返回0；如果 s1 中的字符串小于 s2 中的字符串，返回一个负整数。输入两个字符串，编写并调用函数 str_cmp，比较两个字符串的大小（要求不调用库函数 strcmp)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;int str_cmp(char s1[ ], char s2[ ]);int main(void)&#123; char ch1[100], ch2[100]; int result; printf(\"请输入第一段字符：\"); scanf(\"%s\", ch1); printf(\"请输入第二段字符：\"); scanf(\"%s\", ch2); result = str_cmp(ch1, ch2); if(result &gt; 0) &#123; printf(\"%s &gt; %s\\n\", ch1, ch2); &#125; else if(result == 0) &#123; printf(\"%s == %s\\n\", ch1, ch2); &#125; else &#123; printf(\"%s &lt; %s\\n\", ch1, ch2); &#125; return 0;&#125; int str_cmp(char s1[ ], char s2[ ])&#123; int i = 0, length1 = 0, length2 = 0; // 计算s1数组长度 while(s1[length1] != '\\0') &#123; length1 ++; &#125; while(s2[length2] != '\\0') &#123; length2 ++; &#125; while(s1[i] != '\\0' || s2[i] != '\\0') &#123; if(s1[i] &gt; s2[i]) &#123; return 1; &#125; else if(s1[i] &lt; s2[i]) &#123; return -1; &#125; else &#123; if(length1 &gt; length2) &#123; return 1; &#125; else if(length1 == length2) &#123; return 0; &#125; else &#123; return -1; &#125; &#125; i ++; &#125;&#125; 运行结果： 123请输入第一段字符：com请输入第二段字符：computercom &lt; computer 编程练习14已知函数头为 void output(int row, int t[ ][5])，函数output 的功能：输出行数为row，列数为5的二维数组 t 中所有的数组元素。编写并调用函数 output，输出 3 行 5 列的二位数组，再次调用 output，输出 4 行 5 列的二维数组。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;void output(int row, int t[ ][5]);int main(void)&#123; int i, j, r = 3; int t1[][5] = &#123;&#123;1, 2, 3, 4, 5&#125;, &#123;6, 7, 8, 9, 10&#125;, &#123;11, 12, 13, 14, 15&#125;&#125;; int t2[][5] = &#123;&#123;1, 2, 3, 4, 5&#125;, &#123;6, 7, 8, 9, 10&#125;, &#123;11, 12, 13, 14, 15&#125;, &#123;16, 17, 18, 19, 20&#125;&#125;; output(3, t1); printf(\"\\n\"); output(4, t2);&#125;void output(int row, int t[ ][5])&#123; int i, j; for(i = 0;i &lt; row;i ++) &#123; for(j = 0;j &lt; 5;j ++) &#123; printf(\"%6d\", t[i][j]); &#125; printf(\"\\n\"); &#125;&#125; 运行结果： 123456781 2 3 4 56 7 8 9 1011 12 13 14 151 2 3 4 56 7 8 9 1011 12 13 14 1516 17 18 19 20 编程练习15已知函数头为 int getmin(int n, int r[ ][3])，函数 getmin 的功能：计算并返回行数为 n 列数为 3 的二维数组 t 中的最小值。编写并调用函数 getmin 。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;int getmin(int n, int r[ ][3]);void copyright(void);int main(void)&#123; int a[4][3] = &#123;&#123;2, 1, 3&#125;, &#123;4, 6, 5&#125;, &#123;7, 8,9&#125; ,&#123; 10, 12, 11&#125;&#125;; int min; copyright( ); min = getmin(4, a); printf(\"最小值为：%d\\n\", min); return 0;&#125;int getmin(int n, int r[ ][3])&#123; int i,j, min, b[n]; for(i = 0;i &lt; n;i ++) &#123; for(j = 0;j &lt; 3;j ++) &#123; b[i] = r[i][2]; &#125; &#125; min = b[0]; for(i = 1;i &lt; n;i ++) &#123; if(min &gt; b[i]) &#123; min = b[i]; &#125; &#125; return min; &#125;void copyright(void)&#123; printf(\"******************************* 编程练习8.15 *******************************\\n\"); printf(\"2\\t1\\t3\\n\"); printf(\"4\\t6\\t5\\n\"); printf(\"7\\t8\\t9\\n\"); printf(\"10\\t12\\t11\\n\");&#125; 运行结果： 123456******************************* 编程练习8.15 *******************************2 1 34 6 57 8 910 12 11最小值为：3 编程练习16在 main 函数中输入两个整数 m 和 n ，调用函数 change，要求函数 change 调用完成后，整数 m 的值加 5，整数 n 的值减 3，在主函数中输出改变后的 m 和 n。 12345678910111213141516171819#include &lt;stdio.h&gt;void change(int *x, int *y);int main(void)&#123; int m, n; printf(\"请输入m的值：\"); scanf(\"%d\", &amp;m); printf(\"请输入n的值：\"); scanf(\"%d\", &amp;n); printf(\"Before function call:\\tm = %d , n = %d\\n\", m , n); change(&amp;m, &amp;n); printf(\"After function call:\\tm = %d , n = %d\\n\", m, n); return 0;&#125;void change(int *x, int *y)&#123; *x += 5; *y -= 3;&#125; 运行结果： 12Before function call: m &#x3D; 5 , n &#x3D; 3After function call: m &#x3D; 10 , n &#x3D; 0 编程练习17已知函数头及功能如下： 123void input(int n1, int t1[ ]); // 输入n1个整数到一维数组t1中void sort(int n2, int t2[ ]); // 对长度为n2的一维数组t2中的数组元素按升序排序void output(int n3, int t3[ ]); // 输出长度为n3的一维数组t3中的数组元素 编写并调用函数输入10个整数，对这10个整数按升序排序，输出排序后的10个整数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;void input(int n1, int t1[ ]);void sort(int n2, int t2[ ]);void output(int n3, int t3[ ]);int main(void)&#123; int i,s1[10]; input(10, s1); sort(10, s1); output(10, s1); return 0;&#125;void input(int n1, int t1[ ])&#123; int i; printf(\"请输入10个整数：\\n\", i); for(i = 0;i &lt; n1;i ++) &#123; scanf(\"%d\", &amp;t1[i]); &#125;&#125;void sort(int n2, int t2[ ])&#123; int i, j, temp; for(i = 0;i &lt; n2;i ++) &#123; for(j = 0;j &lt; 9 - i;j ++) &#123; if(t2[j] &gt; t2[j + 1]) &#123; temp = t2[j]; t2[j] = t2[j + 1]; t2[j + 1] = temp; &#125; &#125; &#125;&#125;void output(int n3, int t3[ ])&#123; int i; for(i = 0;i &lt; n3;i ++) &#123; printf(\"%d\\t\", t3[i]); &#125; printf(\"\\n\");&#125; 运行结果： 123456789101112请输入10个整数：9577993656851974698819 36 56 69 74 77 85 88 95 99 编程练习18已知函数头及功能如下： 1234void input(int n1, int t1[ ]); // 输入n1个整数到一维数组t1中void swapmin(int n2, int t2[ ]); // 将数组t2中最小数组元素与t2[0]交换void swapmax(int n3, int t3[ ]); // 将数组t3中最大数组元素与t3[n3 - 1]交换void output(int n4, int t4[ ]); // 输出长度为n4的一维数组t4中的数组元素 编写并调用函数输入10个整数，完成数据交换，输出交换后的10个整数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;void input(int n1, int t1[ ]);void swapmin(int n2, int t2[ ]);void swapmax(int n3, int t3[ ]);void output(int n4, int t4[ ]);int main(void)&#123; int i, s[10]; input(10, s); swapmin(10, s); swapmax(10, s); output(10, s); return 0;&#125;void input(int n1, int t1[ ])&#123; int i; for(i = 0;i &lt; n1; i ++) &#123; printf(\"请输入第%d个整数：\", i + 1); scanf(\"%d\", &amp;t1[i]); &#125;&#125;void swapmin(int n2, int t2[ ])&#123; int min = 0; int i, temp; for(i = 0;i &lt; n2;i ++) &#123; if(t2[min] &gt; t2[i]) &#123; min = i; &#125; &#125; if(min != 0) &#123; temp = t2[0]; t2[0] = t2[min]; t2[min] = temp; &#125;&#125;void swapmax(int n3, int t3[ ])&#123; int max = 0; int i, temp; for(i = 0;i &lt; n3;i ++) &#123; if(t3[max] &lt; t3[i]) &#123; max = i; &#125; &#125; if(max != n3 - 1) &#123; temp = t3[n3 - 1]; t3[n3 - 1] = t3[max]; t3[max] = temp; &#125;&#125;void output(int n4, int t4[ ])&#123; int i; for(i = 0;i &lt; n4;i ++) &#123; printf(\"%d\\t\", t4[i]); &#125; printf(\"\\n\");&#125; 运行结果： 1234567891011请输入第1个整数：74请输入第2个整数：20请输入第3个整数：99请输入第4个整数：13请输入第5个整数：14请输入第6个整数：52请输入第7个整数：33请输入第8个整数：44请输入第9个整数：66请输入第10个整数：9913 20 99 74 14 52 33 44 66 99 编程练习19已知函数头及功能如下： 123void input(int row1, int t1[ ][3]); // 输入row1 * 3个整数到二维数组t1中void change(int row2, int t2[ ][3]); // 使数组t2中每个元素的值增1void output(int row3, int t3[ ][3]); // 输出二维数组t3中的数组元素 编写并调用函数输入6个整数，完成数据处理，输出处理后的6个整数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;void input(int row1, int t1[ ][3]);void change(int row2, int t2[ ][3]);void output(int row3, int t3[ ][3]);int main(void)&#123; int t[2][3]; input(2, t); change(2, t); output(2, t); return 0;&#125;void input(int row1, int t1[ ][3])&#123; int i, j; for(i = 0;i &lt; row1;i ++) &#123; for(j = 0;j &lt; 3;j ++) &#123; scanf(\"%d\", &amp;t1[i][j]); &#125; &#125;&#125;void change(int row2, int t2[ ][3])&#123; int i, j; for(i = 0;i &lt; row2;i ++) &#123; for(j = 0;j &lt; 3;j ++) &#123; t2[i][j] += 1; &#125; &#125;&#125;void output(int row3, int t3[ ][3])&#123; int i, j; for(i = 0;i &lt; row3;i ++) &#123; for(j = 0;j &lt; 3;j ++) &#123; printf(\"%d\\t\", t3[i][j]); &#125; printf(\"\\n\"); &#125;&#125; 运行结果： 1231 2 3 4 5 62 3 4 5 6 7 编程练习20此题略 编程练习21输入长方形的长和宽，调用同一个函数，第一次调用求长方形的面积，第二次调用求长方形的周长。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int get_s(int x1, int y1);int get_l(int x2, int y2);int get(int x3, int y3, int (*p)(int m, int n));int main(void)&#123; int a, b, s, l; printf(\"请输入长方形的长：\"); scanf(\"%d\", &amp;a); printf(\"请输入长方形的宽：\"); scanf(\"%d\", &amp;b); s = get(a, b, get_s); l = get(a, b, get_l); printf(\"长方形的面积为：%d\\n\", s); printf(\"长方形的周长为：%d\\n\", l); return 0;&#125;int get_s(int x1, int y1)&#123; return x1 * y1;&#125;int get_l(int x2, int y2)&#123; return 2 * (x2 + y2);&#125;int get(int x3, int y3, int (*p)(int m, int n))&#123; return (*p)(x3, y3);&#125; 运行结果： 1234请输入长方形的长：5请输入长方形的宽：6长方形的面积为：30长方形的周长为：22 编程练习22采用递归的函数调用求 1 + 2 + 3 + … + n 的值。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;double factorial(int n);int main(void)&#123; int a; double sum; printf(\"请输入n的值：\"); scanf(\"%d\", &amp;a); sum = factorial(a); printf(\"sum = %.0lf\\n\", sum); return 0;&#125;double factorial(int n)&#123; double sum; if(n &gt; 1) &#123; sum = n + factorial(n - 1); &#125; else &#123; sum = 1; &#125; return sum; &#125; 运行结果： 12请输入n的值：20sum &#x3D; 210 编程练习23$$采用递归的函数调用求x^n的值，x的类型是double，n的类型是int，且n≥0 。$$ 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;math.h&gt;double power(double x, int n);int main(void)&#123; int a; double b, result; printf(\"请输入x的值：\"); scanf(\"%lf\", &amp;b); printf(\"请输入n的值：\"); scanf(\"%d\", &amp;a); result = power(b, a); printf(\"result = %.2lf\\n\", result); return 0;&#125;double power(double x, int n)&#123; double s; if(n &gt; 0) &#123; s = x * power(x, n - 1); &#125; else &#123; s = 1; &#125; return s;&#125; 运行结果： 123请输入x的值：2请输入n的值：10result &#x3D; 1024.00 编程练习24已知函数头为 int hanoi(int n, char first, char second, char third) ， 函数 hanoi 的功能：输出汉诺塔问题中圆盘的移动步骤，计算并返回圆盘移动的总次数。编写并调用函数 hanoi 。 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;math.h&gt;int hanoi(int n, char first, char second, char third);int main(void)&#123; int m, times; printf(\"请输入圆盘的个数：\"); scanf(\"%d\", &amp;m); times = hanoi(m, 'A', 'B', 'C'); printf(\"共移动了%d次\\n\", times); return 0;&#125;int hanoi(int n, char first, char second, char third)&#123; if(n &gt; 1) &#123; hanoi(n - 1, first, third, second); printf(\"将第%d个圆盘从%c移动到%c\\n\", n, first, third); hanoi(n - 1, second, first, third); &#125; else &#123; printf(\"将第%d个圆盘从%c移动到%c\\n\", n, first, third); &#125; return pow(2, n) - 1;&#125; 运行结果： 1234567891011121314151617请输入圆盘的个数：4将第1个圆盘从A移动到B将第2个圆盘从A移动到C将第1个圆盘从B移动到C将第3个圆盘从A移动到B将第1个圆盘从C移动到A将第2个圆盘从C移动到B将第1个圆盘从A移动到B将第4个圆盘从A移动到C将第1个圆盘从B移动到C将第2个圆盘从B移动到A将第1个圆盘从C移动到A将第3个圆盘从B移动到C将第1个圆盘从A移动到B将第2个圆盘从A移动到C将第1个圆盘从B移动到C共移动了15次","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"指针类型","slug":"c_7","date":"2021-03-07T09:02:14.000Z","updated":"2021-07-17T02:36:51.061Z","comments":true,"path":"2021/03/07/c_7/","link":"","permalink":"https://imqinhao.cn/2021/03/07/c_7/","excerpt":"指针类型编程练习题","text":"指针类型编程练习题 指针与指针变量编程练习7.1输入三个整数，按从小到大的顺序输出，要求用指针实现。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(void)&#123; int num1,num2,num3,*p1,*p2,*p3,tmp; printf(\"请输入三个数：\\n\"); scanf(\"%d%d%d\",&amp;num1,&amp;num2,&amp;num3); p1 = &amp;num1; p2 = &amp;num2; p3 = &amp;num3; if(*p1 &lt; *p2) &#123; tmp = *p1; *p1 = *p2; *p2 = tmp; &#125; if(*p2 &lt; *p3) &#123; tmp = *p2; *p2 = *p3; *p3 = tmp; &#125; if(*p1 &lt; *p2) &#123; tmp = *p1; *p1 = *p2; *p2 = tmp; &#125; printf(\"%d\\t%d\\t%d\\n\",num1,num2,num3); return 0;&#125; 指针与一维数组编程练习7.2输入 10 个数，将其中最小的数与第一个数对换，最大的数与最后一个数对换。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int main(void)&#123; printf(\"****************************** 编程练习7.2 ******************************\\n\"); int num[10]; int *p, i, max, min, tip1, tip2, temp; p = num; for(i = 0;i &lt; 10;i ++) &#123; scanf(\"%d\", p + i); &#125; p = num; max = p[0]; min = p[0]; for(i = 1;i &lt; 10;i ++) &#123; if(*(p + i) &lt; min) &#123; tip1 = i; min = *(p + i); &#125; else if(*(p + i) &gt; max) &#123; tip2 = i; max = *(p + i); &#125; &#125; p = num; // 交换 temp = p[tip1]; p[tip1] = p[0]; p[0] = min; temp = p[tip2]; p[tip2] = p[9]; p[9] = temp; for(i = 0;i &lt; 10;i ++) &#123; printf(\"%6d\", *p++); &#125; printf(\"\\n\"); return 0;&#125; 编程练习7.3编写四个程序，分别用四种方法引用数组元素，输入 10 个整数，按升序排列，输出排序结果。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main(void)&#123; printf(\"******************************* 编程练习7.3 *******************************\\n\"); int a[10], *p, i, j, temp; // 第一种 printf(\"请输入10个整数：\\n\"); for(i = 0;i &lt; 10;i ++) &#123; scanf(\"%d\", &amp;a[i]); &#125; for(i = 0;i &lt; 10;i ++) &#123; for(j = 0;j &lt; 10 - i;j ++) &#123; if(a[j] &gt; a[j + 1]) &#123; temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125; for(i = 0;i &lt; 10;i ++) &#123; printf(\"%6d\", a[i]); &#125; printf(\"\\n\"); return 0;&#125; 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main(void)&#123; printf(\"******************************* 编程练习7.3 *******************************\\n\"); int a[10], *p, i, j, temp; // 第二种 p = a; for(i = 0;i &lt; 10;i ++) &#123; scanf(\"%d\", p ++); &#125; p = a; for(i = 0;i &lt; 10;i ++) &#123; for(j = 0;j &lt; 10 - i;j ++) &#123; if(p[j] &gt; p[j + 1]) &#123; temp = p[j]; p[j] = p[j + 1]; p[j + 1] = temp; &#125; &#125; &#125; for(i = 0;i &lt; 10;i ++) &#123; printf(\"%6d\", p[i]); &#125; printf(\"\\n\"); return 0;&#125; 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main(void)&#123; printf(\"******************************* 编程练习7.3 *******************************\\n\"); int a[10], *p, i, j, temp; // 第三种 for(i = 0;i &lt; 10;i ++) &#123; scanf(\"%d\", a + i); &#125; for(i = 0;i &lt; 10;i ++) &#123; for(j = 0;j &lt; 10 - i;j ++) &#123; if(*(a + j) &gt; *(a + j + 1)) &#123; temp = *(a + j); *(a + j) = *(a + j + 1); *(a + j + 1) = temp; &#125; &#125; &#125; for(i = 0;i &lt; 10;i ++) &#123; printf(\"%6d\", *(a+i)); &#125; printf(\"\\n\"); return 0;&#125; 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main(void)&#123; printf(\"******************************* 编程练习7.3 *******************************\\n\"); int a[10], *p, i, j, temp; // 第四种 p = a; for(i = 0;i &lt; 10;i ++) &#123; scanf(\"%d\", p++); &#125; p = a; for(i = 0;i &lt; 10;i ++) &#123; for(j = 0;j &lt; 10;j ++) &#123; if(*(p + j) &gt; *(p + j + 1)) &#123; temp = *(p + j); *(p + j) = *(p + j + 1); *(p + j + 1) = temp; &#125; &#125; &#125; for(i = 0;i &lt; 10;i ++) &#123; printf(\"%6d\", *(p + i)); &#125; printf(\"\\n\"); return 0;&#125; 指针与二维数组编程练习7.4输入 3 行 4 列二位数组，求最小值及其下标。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;int main(void)&#123; printf(\"********************** 编程练习7.4 **********************\\n\"); int array[3][4]; int i, j, min, t, k, (*p)[4]; p = array; k = t = 0; printf(\"请输入12个数字：\\n\"); for(i = 0;i &lt; 3;i ++) &#123; for(j = 0;j &lt; 4;j ++) &#123; scanf(\"%d\", *(p+i)+j); &#125; &#125; min = array[0][0]; for(i = 0;i &lt; 3;i ++) &#123; for(j = 0;j &lt; 4;j ++) &#123; printf(\"%6d\", *(*(p + i) + j)); &#125; printf(\"\\n\"); &#125; for(i = 0;i &lt; 3;i ++) &#123; for(j = 0;j &lt; 4;j ++) &#123; if(min &gt; *(*(p + i) + j)) &#123; min = *(*(p + i) + j); k = i; t = j; &#125; &#125; &#125; printf(\"最小值：%d , 行下标：%d , 列下标：%d\\n\", min, k, t); return 0;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"数组类型","slug":"c_6","date":"2021-03-06T09:02:14.000Z","updated":"2021-07-17T02:36:40.755Z","comments":true,"path":"2021/03/06/c_6/","link":"","permalink":"https://imqinhao.cn/2021/03/06/c_6/","excerpt":"数组类型编程练习题","text":"数组类型编程练习题 一维数组编程练习6.1输入 10 个数到数组 t 中，求最小值及最小值在数组 t 中的下标。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main(void)&#123; printf(\"****************************** 编程练习6.1 ******************************\\n\"); int i; int j; int min; int t[10]; printf(\"请输入10个数：\\n\"); for(i = 0;i &lt; 10;i ++) &#123; scanf(\"%d\",&amp;t[i]); &#125; min = t[0]; for(i = 1;i &lt;= 10;i ++) &#123; if(t[i] &lt; min) &#123; min = t[i]; j = i; &#125; &#125; printf(\"最小值：%d\\t下标：%d\\n\",min,j); return 0;&#125; 编程练习6.2输入 10 个数到数组 t 中，再输入 x ，如果有与 x 相等的数组元素，输出该数组元素的下标；否则，输出 -1。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;int main(void)&#123; printf(\"****************************** 编程练习6.2 ******************************\\n\"); int i; int n; // 下标 int x; int flag; int temp; int t[10]; printf(\"请输入10个数：\\n\"); for(i = 0;i &lt; 10;i ++) &#123; scanf(\"%d\",&amp;t[i]); &#125; printf(\"请输入x的值：\"); scanf(\"%d\",&amp;x); for(i = 0;i &lt; 10;i ++) &#123; if(t[i] == x) &#123; flag = 0; temp = i; break; &#125; else &#123; flag = 1; &#125; &#125; if(flag == 1) &#123; printf(\"-1\\n\"); &#125; else &#123; printf(\"%d\\n\", temp); &#125; printf(\"\\n\"); return 0;&#125; 编程练习6.3输入 10 个数到数组 t 中，按降序排序，输出排序结果。 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int main(void)&#123; printf(\"********************************* 编程练习6.3 *********************************\\n\"); int i; int j; int temp; int t[10]; printf(\"请输入10个数：\\n\"); for(i = 0;i &lt; 10;i ++) &#123; scanf(\"%d\",&amp;t[i]); &#125; for(i = 1;i &lt;= 10;i ++) &#123; for(j = 0;j &lt; 10-i;j ++) &#123; if(t[j] &lt; t[j + 1]) &#123; temp = t[j]; t[j] = t[j+1]; t[j+1] = temp; &#125; &#125; &#125; for(i = 0;i &lt; 10;i ++) &#123; printf(\"%d\\t\",t[i]); &#125; printf(\"\\n\"); return 0;&#125; 编程练习6.4输入 10 个整数到数组 t 中（数组长度为偶数），将数组 t 中的数组元素倒置，输出倒置以后的数组 t 。例如，数组 t 中 10 个数组元素依次为 1 、3 、5、 7、 9 、 8、 6、 4 、 2 、 0，倒置以后 10 个数组元素依次为 0、 2、 4、 6、 8、 9、 7、 5、 3、 1。已知声明变量和数组声明为“ int i , tmp, t[10]; “，要求不再声明其他的变量或数组。 1234567891011121314151617181920#include &lt;stdio.h&gt;int main(void)&#123; printf(\"*********************************** 编程练习6.4 ***********************************\\n\"); int i; int tmp; int t[10]; printf(\"请输入10个数：\\n\"); for(i = 0;i &lt; 10;i ++) &#123; scanf(\"%d\",&amp;t[i]); &#125; for(i = 0;i &lt; 10;i ++) &#123; tmp = t[9-i]; printf(\"%d\\t\",tmp); &#125; printf(\"\\n\"); return 0;&#125; 编程练习6.5输入 9 个整数到数组 t 中（数组长度为奇数），将数组 t 中的数组元素倒置，输出倒置以后的数组 t 。例如，数组 t 中 10 个数组元素依次为 2、 4、 6、 8、 9、 7、 5、 3、 1 ，倒置以后 9 个数组元素依次为 1、 3、 5、 7、 9、 8、 6、 4、 2 。已知声明变量和数组声明为“ int i , tmp, t[9]; “，要求不再声明其他的变量或数组。 1234567891011121314151617#include &lt;stdio.h&gt;int main(void)&#123; int i,tmp,t[9]; printf(\"请输入9个数:\\n\"); for(i = 0;i &lt; 9;i ++) &#123; scanf(\"%d\",&amp;t[i]); &#125; for(i = 0;i &lt; 9;i ++) &#123; tmp = t[8-i]; printf(\"%d\\t\",tmp); &#125; printf(\"\\n\"); return 0;&#125; 编程练习6.6已知数组声明为“ int a[10] = {0,10,20,30,40,50,60,70,80,90}; “ ，10个数组元素是按升序排列的。输入一个整数 n ，如果没有与 n 相等的数组元素，输出 -1 ；否则，删除与 n 相等的数组元素，要求剩余的九个数组元素是按升序排列的，输出数组。 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int main(void)&#123; int a[10] = &#123;0,10,20,30,40,50,60,70,80,90&#125;; int n,i,j,tip,flag; printf(\"请输入整数n：\"); scanf(\"%d\",&amp;n); for(i = 0;i &lt; 10;i ++) &#123; if(a[i] == n) &#123; flag = 1; tip = i; &#125; &#125; if(flag != 1) &#123; printf(\"-1\\n\"); &#125; if(flag == 1) &#123; for(j = 0;j &lt; 10;j ++) &#123; if(tip != j) &#123; printf(\"%5d\",a[j]); &#125; &#125; &#125; printf(\"\\n\"); return 0;&#125; 二维数组编程练习6.7求 3 行 5 列二维数组中的最小值，及最小值在数组中的行号和列号，并输出。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main(void)&#123; printf(\"****************************** 编程练习6.7 ******************************\\n\"); printf(\"85\\t73\\t66\\t98\\t100\\n99\\t78\\t56\\t68\\t69\\n73\\t58\\t66\\t52\\t83\\n\"); int i,j,min,line,row; int a[3][5] = &#123; &#123;85,73,66,98,100&#125;, &#123;99,78,56,68,69&#125;, &#123;73,58,66,52,83&#125;&#125;; min = a[0][0]; for(i = 0;i &lt; 3;i ++) &#123; for(j = 0;j &lt; 5;j ++) &#123; if(min &gt; a[i][j]) &#123; min = a[i][j]; line = i + 1; row = j + 1; &#125; &#125; &#125; printf(\"最小值：%d\\t行号：%d\\t\\t列号：%d\\n\",min,line,row); return 0;&#125; 编程练习6.8求 3 行 5 列二维数组中每列数组元素的最小值，并输出。 123456789101112131415161718192021#include &lt;stdio.h&gt;int main(void)&#123; printf(\"********************************* 编程练习6.8 *********************************\\n\"); printf(\"82\\t77\\t93\\t86\\t99\\n72\\t66\\t45\\t53\\t30\\n100\\t97\\t88\\t67\\t98\\n\"); int i,j,min; int a[3][5] = &#123;&#123;82,77,93,86,99&#125;,&#123;72,66,45,53,30&#125;,&#123;100,97,88,67,98&#125;&#125;; for(i = 0;i &lt; 3;i ++) &#123; min = a[i][0]; for(j = 0;j &lt; 5;j ++) &#123; if(min &gt; a[i][j]) &#123; min = a[i][j]; &#125; &#125; printf(\"第%d行的最小值：%d\\n\",i,min); &#125; return 0;&#125; 编程练习6.9求 3 行 3 列二维数组主对角线（从左上角到右下角）上元素之和。 1234567891011121314151617181920#include &lt;stdio.h&gt;int main(void)&#123; printf(\"***************************** 编程练习6.9 *****************************\\n\"); printf(\"1\\t2\\t3\\n4\\t5\\t6\\n7\\t8\\t9\\n\"); int i,j,sum = 0; int a[3][3] = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;; for(i = 0;i &lt; 3;i ++) &#123; for(j = 0;j &lt; 3;j ++) &#123; if(i == j) &#123; sum += a[i][j]; &#125; &#125; &#125; printf(\"sum = %d\\n\",sum); return 0;&#125; 编程练习6.10二维数组 a （3 行 4 列）表示矩阵 A ，二维数组 b （4 行 5 列）表示矩阵 B ，计算矩阵 A 与 矩阵 B 的成绩。 博主正在研究题目中。。。 数组与字符串编程练习6.11不调用库函数 strcpy，将以下数组 s1 中的字符串复制到数组 s2 中，并输出数组 s2 中的字符串。 123char s1[80], s2[80];gets(s1); 1234567891011121314#include &lt;stdio.h&gt;int main(void)&#123; int i = 0; char s1[80],s2[80]; gets(s1); while(s1[i] != '\\0') &#123; s2[i] = s1[i]; i ++; &#125; printf(\"%s\\n\",s2); return 0;&#125; 编程练习6.12输入 10 个字符串，输出最大的字符串。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void)&#123; printf(\"******************************** 编程练习6.12 ********************************\\n\"); char ch[10][100]; char max[100]; int i,j,n; printf(\"请输入10个字符串：\\n\"); for(i = 0;i &lt; 10;i ++) &#123; scanf(\"%s\",ch[i]); &#125; strcpy(max,ch[0]); for(i = 1;i &lt; 10;i ++) &#123; if(strcmp(ch[i],max) &gt; 0) &#123; strcpy(max,ch[i]); &#125; &#125; printf(\"max:%s\\n\",max); return 0;&#125; 编程练习6.13判断数组 s 中的字符串是不是回文。一个字符串从左向右读和从右向左读是一样的，该字符串是回文。例如，字符串 “abcdedcba” 是回文。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void)&#123; int i,j,flag = 0; char s[80]; gets(s); j = strlen(s) - 1; for(i = 0;i &lt; strlen(s);i ++) &#123; if(s[i] != s[j]) &#123; flag = 1; printf(\"%s 不是回文\\n\",s); break; &#125; j --; &#125; if(flag != 1) &#123; printf(\"%s 是回文\\n\",s); &#125; return 0;&#125; 编程练习6.14输出数组 s 中字符串的子串，子串从 s[begin] 开始，长度为 len 。 1234char s[80];int begin, len;gets(s);scanf(\"%d%d\", &amp;begin, &amp;len); 123456789101112131415#include &lt;stdio.h&gt;int main(void)&#123; printf(\"****************************** 编程练习6.14 ******************************\\n\"); char s[80]; int begin, len; gets(s); scanf(\"%d%d\", &amp;begin, &amp;len); for(;len &gt; 0;len --,begin ++) &#123; printf(\"%c\",s[begin]); &#125; printf(\"\\n\"); return 0;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"循环结构","slug":"c_5","date":"2021-03-05T09:02:14.000Z","updated":"2021-07-17T02:36:28.128Z","comments":true,"path":"2021/03/05/c_5/","link":"","permalink":"https://imqinhao.cn/2021/03/05/c_5/","excerpt":"循环结构编程练习题","text":"循环结构编程练习题 for语句编程练习5.1降序输出 1 ~ 30 中所有的偶数。 123456789101112131415#include &lt;stdio.h&gt;int main(void)&#123; // 降序输出1~30中的所有偶数 int i; for(i = 30;i &gt;= 1;i --) &#123; if(i % 2 == 0) &#123; printf(\"%d\\t\",i); &#125; &#125; printf(\"\\n\"); return 0;&#125; 编程练习5.2输入10个分数，去掉最高分和最低分后求平均分，保留一位小数 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int main(void)&#123; //输入10个分数，去掉最高分和最低分后求平均分，保留一位小数 int i; double score; double MaxScore; double MinScore; double sum = 0.0; double average; for(i = 1;i &lt;= 10;i ++) &#123; printf(\"请第%d位裁判评分：\",i); scanf(\"%lf\",&amp;score); MinScore = score; if(score &gt; MaxScore) &#123; MaxScore = score; &#125; if(score &lt; MinScore) &#123; MinScore = score; &#125; sum += score; &#125; sum = sum - MaxScore - MinScore; average = sum / 8.0; printf(\"去掉一个最高分：%.1lf分\\n\",MaxScore); printf(\"去掉一个最低分：%.1lf分\\n\",MinScore); printf(\"总分是：%.1lf分\\n\",sum); printf(\"平均分是%.1lf分\\n\",average);&#125; 编程练习5.3求 1×2×3×…×10的值。 1234567891011#include &lt;stdio.h&gt;int main(void)&#123; int i; int result = 1; for(i = 1;i &lt;= 10;i ++) &#123; result *= i; &#125; printf(\"%d\\n\",result);&#125; 编程练习5.4求 1！+ 2！+ 3！+ … + 10! 的值。 12345678910111213141516171819#include &lt;stdio.h&gt;int main(void)&#123; int i; int j; int res; int sum = 0; for(i = 1;i &lt;= 10;i ++) &#123; res = 1; for(j = 1;j &lt;= i;j ++) &#123; res *= j; &#125; printf(\"%d的阶乘是：%d\\n\",i,res); sum += res; &#125; printf(\"%d\\n\",sum);&#125; 编程练习5.5根据用户输入的正整数 a（1~9）和正整数 n ，求 a + aa + … + aa…a（n 个 a ）的值。例如，当用户输入 a 为 6 ，n 为 5 时，6 + 66 + 666 + 6666 + 66666 = 74070 。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(void)&#123; printf(\"*********************** 编程练习5.5 ***********************\\n\"); int a; int n; int i; int g = 0; int s = 0; int sum; printf(\"请输入a的值：\"); scanf(\"%d\",&amp;a); printf(\"请输入n的值：\"); scanf(\"%d\",&amp;n); for(i = 1;i &lt;= n;i ++) &#123; g += a; if(i != n) &#123; printf(\"%d + \",g); &#125; else &#123; printf(\"%d\",g); &#125; s += g; g *= 10; &#125; printf(\" = %d\\n\",s); &#125; 编程练习5.6$$根据用户输入的正整数n，求 1 + \\frac{1}{3}+ \\frac{1}{5}+ \\frac{1}{7}+… 的前n项之和。$$ 1234567891011121314151617#include &lt;stdio.h&gt;int main(void)&#123; int n; int i; double result = 0.0; double sum = 0.0; printf(\"请输入n的值：\"); scanf(\"%d\",&amp;n); for( i = 1;i &lt;= n;i ++) &#123; result = (1 / (2.0 * i - 1)); printf(\"1 / ( 2.0 * %d - 1) = %.2lf\\n\",i,result); sum += result; &#125; printf(\"结果为：%.2lf\\n\",sum);&#125; 编程练习5.7$$根据用户输入的正整数n，求 1 - \\frac{1}{2}+\\frac{1}{3}-\\frac{1}{4}+…+\\frac{(-1)^{n+1}}{n}的值。$$ 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(void)&#123; int i; int n; //用户输入n的值 double result; printf(\"请输入n的值：\"); scanf(\"%d\",&amp;n); for(i = 1;i &lt;= n;i ++) &#123; if(i % 2 == 0) &#123; result -= 1.0/i; &#125; else &#123; result += 1.0/i; &#125; &#125; printf(\"结果为：%.2lf\\n\",result);&#125; 编程练习5.8$$求\\frac{2}{1}+\\frac{3}{2}+\\frac{5}{3}+\\frac{8}{5}+\\frac{13}{8}+…的前20项之和。$$ 123456789101112131415161718192021#include &lt;stdio.h&gt;int main(void)&#123; printf(\"************************* 编程练习5.8 *************************\\n\"); int i; double x = 1.0; double y = 2.0; double z; double result; for(i = 1;i &lt;= 20;i ++) &#123; z = (y / x); result += z; printf(\"%.lf / %.lf = %lf\\n\",y,x,z); z = y; y += x; x = z; &#125; printf(\"**************************************************************\\n\"); printf(\"最终的结果为：%lf\\n\",result);&#125; 编程练习5.9$$求 1-\\frac{2}{3}+\\frac{3}{5}-\\frac{4}{7}+\\frac{5}{9}-\\frac{6}{11}+…的前20项之和。$$ 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(void)&#123; printf(\"*********************** 编程练习5.9 ***********************\\n\"); int i; double a = 1; double result; for(i = 1;i &lt;= 20;i ++) &#123; if(i % 2 == 0) &#123; result -= (i / a); printf(\"第%d项：- %d / %.lf\\n\",i,i,a); &#125; else &#123; result += (i / a); printf(\"第%d项：+ %d / %.lf\\n\",i,i,a); &#125; a += 2; &#125; printf(\"**********************************************************\\n\"); printf(\"结果为：%lf\\n\",result);&#125; 编程练习5.10求数列 1,2,3,5,8,13,21,34，… 的第25项的值。 1234567891011121314151617181920#include &lt;stdio.h&gt;int main(void)&#123; // 求数列1,2,3,5,8,13,21,34, ...中第25项的值。 printf(\"******************** 编程练习5.10 ********************\\n\"); printf(\"需求：求数列1,2,3,5,8,13,21,34, ...中第25项的值。\\n\"); int i; int a = 0; int b = 1; int sum = 0; for(i = 1;i &lt;= 25;i ++) &#123; sum = a + b; a = b; b = sum; printf(\"第%d项：%d\\n\",i,sum); &#125; printf(\"******************************************************\\n\"); &#125; 编程练习5.11输出数列0,1,2,3,6,11,20,37,68, …的前20项，每行输出5项 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main(void)&#123; printf(\"************************** 编程练习5.11 **************************\\n\"); printf(\" 输出数列0,1,2,3,6,11,20,37,68, ...的前20项，每行输出5项\\n\"); int a = 0; int b = 1; int c = 2; int sum; int i; printf(\"%d\\t%d\\t%d\\t\",a,b,c); for(i = 4;i &lt;= 20;i ++) &#123; sum = a + b + c; a = b; b = c; c = sum; printf(\"%d\\t\",sum); if(i % 5 == 0) &#123; printf(\"\\n\"); &#125; &#125; return 0;&#125; 编程练习5.12输入15个字符，统计其中英文字母、数字字符、空格和其他字符的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int main(void)&#123; printf(\"**************************** 编程练习5.12 ****************************\\n\"); int i; char ch; int letter_times = 0; //英文字母次数 int number_times = 0; //数字字符次数 int space_times = 0; //空格次数 int others_times = 0; //其它次数 for(i = 1;i &lt;= 15;i ++) &#123; printf(\"请输入第%d个字符：\",i); scanf(\"%c\",&amp;ch); getchar(); if(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; number_times ++; &#125; else if(ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') &#123; letter_times ++; &#125; else if(ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; letter_times ++; &#125; else if(ch == ' ' || ch == \"\\n\") &#123; space_times ++; &#125; else &#123; others_times ++; &#125; &#125; printf(\"*********************** 统计结果 ***********************\\n\"); printf(\"英文字母个数：%d\\n\",letter_times); printf(\"数字字符个数：%d\\n\",number_times); printf(\"空格字符个数：%d\\n\",space_times); printf(\"其它字符个数：%d\\n\",others_times);&#125; 编程练习5.13输出 2000~2100 年之间所有的闰年。符合以下二者之一的年份是闰年： （1）能被4整除，但不能被100整除，如2016。 （2）能被400整除，如2000。 要求：每行输出5项。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(void)&#123; printf(\"************************** 编程练习5.13 **************************\\n\"); int year; int times; for(year = 2000;year &lt;= 2100;year ++) &#123; if(year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) &#123; times ++; if(times % 5 == 0) &#123; printf(\"%d\\n\",year); &#125; else &#123; printf(\"%d\\t\",year); &#125; &#125; &#125; return 0;&#125; 编程练习5.14$$输出所有的水仙花数。水仙花数是一个三位正整数，每位数字的三次方之和等于该数本身。例如1^3+5^3+3^3=153，153是水仙花数。$$ 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(void)&#123; printf(\"************************* 编程练习5.14 *************************\\n\"); int i; //循环记数 int a; //百位 int b; //十位 int c; //个位 for(i = 100;i &lt;= 999;i ++) &#123; a = i / 100; b = i % 100 / 10; c = i % 100 % 10; if(a*a*a + b*b*b + c*c*c == i) &#123; printf(\"%d\\t%d\\t%d\\t%d\\n\",a,b,c,i); &#125; else &#123; continue; &#125; &#125; return 0;&#125; while语句编程练习5.15输入若干整数，以 -1 结束，去掉最大值和最小值，求平均值。 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main(void)&#123; int number; int times = 0; int sum = 0; int average; printf(\"请输入整数（输入-1结束）：\\n\"); scanf(\"%d\",&amp;number); while(number != -1) &#123; sum += number; times ++; scanf(\"%d\",&amp;number); &#125; if(times &gt; 0) &#123; average = sum / times; printf(\"平均值为：%d\\n\",average); &#125; else &#123; printf(\"错误输入！\\n\"); &#125; return 0;&#125; 编程练习5.16输入一行字符，统计英文字母、数字字符、空格和其他字符的个数。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;int main(void)&#123; printf(\"**************************** 编程练习5.16 ****************************\\n\"); char ch; int letter_times = 0; int number_times = 0; int space_times = 0; int others_times = 0; printf(\"请输入一行字符：\"); scanf(\"%c\",&amp;ch); while(ch != '\\n') &#123; if(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; number_times ++; &#125; else if(ch &gt;= 'a' &amp;&amp; ch &lt;= 'z' || ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; letter_times ++; &#125; else if(ch == ' ') &#123; space_times ++; &#125; else &#123; others_times ++; &#125; scanf(\"%c\",&amp;ch); &#125; printf(\"**************************** 数据统计结果 ****************************\\n\"); printf(\"英文字符个数：%d\\n\", letter_times); printf(\"数字字符个数：%d\\n\", number_times); printf(\"空格字符个数：%d\\n\", space_times); printf(\"其他字符个数：%d\\n\", others_times);&#125; 编程练习5.17$$求1-\\frac{1}{2}+\\frac{1}{3}-\\frac{1}{4}+…+\\frac{(-1)^{n+1}}{n}的值，绝对值小于10^{-5}的项不计算。$$ 12 编程练习5.18$$根据公式\\frac{π}{4}≈1-\\frac{1}{3}+\\frac{1}{5}-\\frac{1}{7}+…求π的近似值，绝对值小于10^{-5}的项不计算。$$ 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(void)&#123; printf(\"***************************** 编程练习5.18 *****************************\\n\"); int i = 1; int times = 1; double sum = 0.0; double item; while( (item = 1.0/i) &gt;= 1.0e-5) &#123; if(times % 2 == 0) &#123; sum -= item; &#125; else &#123; sum += item; &#125; times ++; i += 2; &#125; printf(\"sum = %lf\\n\",4*sum); return 0;&#125; 编程练习5.19$$求1-\\frac{1}{4}+\\frac{1}{7}-\\frac{1}{10}+\\frac{1}{13}-\\frac{1}{16}+…的值，绝对值小于10^{-5}的项不计算。$$ 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(void)&#123; printf(\"******************************** 编程练习5.19 ********************************\\n\"); int i = 1; int times = 1; //循环计次 double item; double sum; while( (item = 1.0/i) &gt;= 1.0e-5) &#123; if(times % 2 == 0) &#123; sum -= item; &#125; else &#123; sum += item; &#125; i += 3; times ++; &#125; printf(\"sum = %lf\\n\",sum); return 0;&#125; 编程练习5.20输入两个正整数，求最小公倍数。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(void)&#123; printf(\"**************************** 编程练习5.20 ****************************\\n\"); int number1; int number2; int gcd; printf(\"请输入两个正整数：\\n\"); scanf(\"%d%d\",&amp;number1,&amp;number2); if(number1 &gt; number2) &#123; gcd = number1; &#125; else &#123; gcd = number2; &#125; while(gcd % number1 || gcd % number2) &#123; gcd ++; &#125; printf(\"%d 和 %d 的最小公倍数为：%d\\n\",number1,number2,gcd); return 0;&#125; 编程练习5.21输入一个正整数 n ，求 n 是几位数。 123456789101112131415#include &lt;stdio.h&gt;int main(void)&#123; int number; int size = 0; printf(\"请输入一个正整数：\"); scanf(\"%d\",&amp;number); while(number) &#123; size ++; number /= 10; &#125; printf(\"数字的位数为：%d 位\\n\",size); return 0;&#125; 编程练习5.22输入一个正整数 n ，判断 n 是否为回文数。所谓回文数，是从左到右读这个数和从右到左读这个数是一样的。例如，98789是回文数。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(void)&#123; printf(\"*************************** 编程练习5.22 ***************************\\n\"); int number; int x; int y = 0; printf(\"请输入一个正整数：\"); scanf(\"%d\",&amp;number); x = number; while(x &gt; 0) &#123; y = y * 10 + x % 10; x = x / 10; &#125; if(y == number) &#123; printf(\"%d 是一个回文数\\n\",number); &#125; else &#123; printf(\"%d 不是一个回文数\\n\",number); &#125;&#125; 嵌套的循环语句编程练习5.25输入如下所示的五五乘法表。 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(void)&#123; printf(\"******************************* 编程练习5.25 *******************************\\n\"); int i; int j; int k; for(i = 1;i &lt;= 5;i ++) &#123; for(j = i;j &lt;= 5;j ++) &#123; printf(\"%d * %d = %d\\t\",i,j,i*j); &#125; printf(\"\\n\"); for(k = 0;k &lt;= i-1;k ++) &#123; printf(\"\\t\\t\"); &#125; &#125; printf(\"\\n\"); return 0;&#125; 编程练习5.26输出如图所示的图案 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(void)&#123; printf(\"******************************* 编程练习5.26 *******************************\\n\"); int i; int j; int k; for(i = 1;i &lt;= 7;i ++) &#123; // 1 : 6 // 2 : 5 // 3 : 4 for(k = 1;k &lt;= 7-i;k ++) &#123; printf(\" \"); &#125; for(j = 1;j &lt;= i*2-1;j ++) &#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; return 0;&#125; 编程练习5.27根据输入的行数输出图案。例如，输入的行数为 7 ，则输出的图案如图所示。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(void)&#123; printf(\"***************************** 编程练习5.27 *****************************\\n\"); int n; int i; int j; int k; printf(\"请输入行数：\"); scanf(\"%d\",&amp;n); for(i = -n / 2;i &lt;= n / 2;i ++) &#123; for(j = abs(i);j &gt;= 0;j --) &#123; printf(\" \"); &#125; for(k = 1;k &lt;= n - 2 * abs(i);k ++) &#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; return 0;&#125; 编程练习5.28输出 100 以内所有的质数，每行输出5个质数。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(void)&#123; printf(\"******************************* 编程练习5.28 *******************************\\n\"); int i; int j; int m; int times = 0; for(i = 2;i &lt; 100;i ++) &#123; m = (int)(sqrt(i) + 1); for(j = 2;j &lt; m;j ++) &#123; if(i % j == 0) &#123; break; &#125; &#125; if(j == m) &#123; printf(\"%d\\t\",i); times ++; if(times % 5 == 0) &#123; printf(\"\\n\"); &#125; &#125; &#125; return 0;&#125; 编程练习5.29百钱买百鸡问题。一百个铜钱买了一百只鸡，其中公鸡一只5钱，母鸡一只3钱，小鸡一钱3只。问：一百只鸡中公鸡、母鸡、小鸡各有多少只？ 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main(void)&#123; int i; //公鸡 int j; //母鸡 int k; //小鸡 for(i = 0;i &lt;= 20;i ++) &#123; for(j = 0;j &lt;= 33;j ++) &#123; for(k = 3;k &lt;= 99;k ++) &#123; if(i * 5 + j * 3 + k/3 == 100) &#123; if(i + j + k == 100) &#123; if(k % 3 == 0) &#123; printf(\"公鸡：%d 只\\t母鸡：%d 只\\t小鸡：%d 只\\n\",i,j,k); &#125; &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"选择结构","slug":"c_4","date":"2021-03-04T09:02:14.000Z","updated":"2021-07-17T02:36:15.126Z","comments":true,"path":"2021/03/04/c_4/","link":"","permalink":"https://imqinhao.cn/2021/03/04/c_4/","excerpt":"选择结构编程练习题","text":"选择结构编程练习题 关系运算符和相等类运算符关系运算符 关系运算符 含义 &lt; 小于 &gt; 大于 &lt;= 小于或等于 &gt;= 大于或等于 表达关系式的类型是int。如果指定的关系为真，关系表达式的值是1；如果指定的关系为假，关系表达式的值是0。 相等类运算符 相等类运算符 含义 == 等于 != 不等于 相等类表达式的类型是int。如果指定的关系为真，相等类表达式的值是1；如果指定的关系为假，相等类表达式的值是0。 逻辑运算符逻辑非运算符逻辑非运算符是 ! ，属于单目运算符。 逻辑非运算符和运算对象构成的表达式的类型是int。如果运算对象的值不等于0，表达式的值是0；如果运算对象的值等于假，相等类表达式的值是1。 逻辑与运算符逻辑与运算符是&&，属于双目运算符。 逻辑与运算符和运算对象构成的表达式的类型是int。如果两个运算对象的值都不等于0，表达式的值是1；否则，表达式的值是0。即任何一个运算对象的值等于0，表达式的值是0 逻辑非运算符逻辑非运算符是||，属于双目运算符。 逻辑或运算符和运算对象构成的表达式的类型是int。如果任何一个运算对象的值不等于0，表达式的值是1；否则，表达式的值是0。即只有两个运算对象的值都等于0，表达式的值才是0 if语句第一种形式12if (表达式) 语句 其功能是：如果表达式的值不等于0，则执行其后的语句；否则，不执行该语句。 第二种形式1234if (表达式) 语句1else 语句2 其功能是：如果表达式的值不等于0，则执行语句1；否则，执行语句2。 嵌套的if语句if 语句的两种形式中，如果“语句”、“语句1”或“语句2”也是if语句，称为嵌套的if语句。 编程练习编程练习4.1$$输入整数a和b，如果a^2+b^2大于100，则输出a+b的值；否则，输出a-b的值。$$ 1234567891011121314151617181920#include &lt;stdio.h&gt;int main(void)&#123; // 输入整数a和b，如果a²+b²大于100，则输出a+b的值，否则，输出a-b的值 int a; int b; printf(\"请输入a的值：\"); scanf(\"%d\",&amp;a); printf(\"请输入b的值：\"); scanf(\"%d\",&amp;b); if(a * a + b * b &gt; 100) &#123; printf(\"a + b = %d\\n\",a + b); &#125; else &#123; printf(\"a - b = %d\\n\",a - b); &#125; return 0;&#125; 编程练习4.2输入整数 n ，如果 n 既是 5 的整倍数又是 7 的整倍数，则输出 yes，否则输出 no 。 1234567891011121314151617#include &lt;stdio.h&gt;int main(void)&#123; // 输入整数n，如果n既是5的整倍数又是7的整倍数，则输出yes，否则输出no int n; printf(\"请输入一个整数：\"); scanf(\"%d\",&amp;n); if (n % 5 == 0 &amp;&amp; n % 7 == 0) &#123; printf(\"yes\\n\"); &#125; else &#123; printf(\"no\\n\"); &#125; return 0;&#125; 编程练习4.3商场为促销实行打折销售商品，折扣规则如表所示。 商品数量 折扣 x &lt; 5 0 5 ≤ x &lt; 10 1% 10 ≤ x &lt; 21 2% 21 ≤ x &lt; 30 4% 30 ≤ x 6% 假定商品的价格为 p 元，编程计算某顾客购买 x 件商品的应付金额。计算公式为：$$sum = p * x * (1-d)$$其中，sum 为应付金额，d 为折扣数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;int main(void)&#123; double p; //商品价格 int x; //商品数量 double sum; //应付金额 double d; //折扣数 int b; //折扣率 printf(\"请输入商品的数量：\"); scanf(\"%d\",&amp;x); printf(\"请输入商品的单价：\"); scanf(\"%lf\",&amp;p); if (x &lt; 5) &#123; d = 0; b = d * 100; sum = p * x * (1-d); &#125; else if (x &lt; 10) &#123; d = 0.01; b = d * 100; sum = p * x * (1-d); &#125; else if(x &lt; 21) &#123; d = 0.02; b = d * 100; sum = p * x * (1-d); &#125; else if(x &lt; 30) &#123; d = 0.04; b = d * 100; sum = p * x * (1-d); &#125; else &#123; d = 0.06; b = d * 100; sum = p * x * (1-d); &#125; printf(\"你购买了%d件商品\\n单价为%.2lf元\\n折扣数为：%d%\\n结算价格为%.2lf元\\n\",x,p,b,sum); return 0;&#125; 编程练习4.4输入’0’‘9’或’a’‘f’或’A’~’F’中的一个字符，代表一个十六进制数，将其转换为十进制数，求该数与15的和并输出。例如，输入a，输出25。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;int main(void)&#123; char ch; int result; printf(\"请输入字符：\"); scanf(\"%c\",&amp;ch); if(ch == 'a' || ch == 'A')&#123; result = 10 + 15; &#125; else if(ch == 'b' || ch == 'B') &#123; result = 11 + 15; &#125; else if(ch == 'c' || ch == 'C') &#123; result = 12 + 15; &#125; else if(ch == 'd' || ch == 'D') &#123; result = 13 + 15; &#125; else if(ch == 'e' || ch == 'E') &#123; result = 14 + 15; &#125; else if(ch == 'f' || ch == 'F') &#123; result = 15 + 15; &#125; else if(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; result = ch - 48 + 15; &#125; else &#123; printf(\"请检查输入！\\n\"); return; &#125; printf(\"%d\\n\",result);&#125; 编程练习4.5输出一张如下所示的时间表： 根据输入的序号显示相应的问候信息：输入 1 时，输出 Good morning ；输入 2 时，输出 Good Afternoon ；输入 3 时，输出 Good night； 对于其他的输入，则输出 error 。","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"顺序结构","slug":"c_3","date":"2021-03-03T09:02:14.000Z","updated":"2021-07-17T02:36:04.030Z","comments":true,"path":"2021/03/03/c_3/","link":"","permalink":"https://imqinhao.cn/2021/03/03/c_3/","excerpt":"顺序结构编程练习题","text":"顺序结构编程练习题 编程练习编程练习3.4使用转换说明%c输出以下图案（注：星号之间没有空格） 12345678910#include &lt;stdio.h&gt;int main(void)&#123; printf(\" %c \\n\",'*'); printf(\" %c%c%c \\n\",'*','*','*'); printf(\" %c%c%c%c%c \\n\",'*','*','*','*','*'); printf(\" %c%c%c%c%c%c%c \\n\",'*','*','*','*','*','*','*'); printf(\"%c%c%c%c%c%c%c%c%c\\n\",'*','*','*','*','*','*','*','*','*'); return 0;&#125; 编程练习3.5输入三个整数，求其平均值。 1234567891011121314#include &lt;stdio.h&gt;int main(void)&#123; // 输入三个整数，求其平均值 int num1; scanf(\"%d\",&amp;num1); int num2; scanf(\"%d\",&amp;num2); int num3; scanf(\"%d\",&amp;num3); int average = (num1 + num2 + num3)/3; printf(\"( %d + %d + %d) ÷ 3 = %d\\n\",num1,num2,num3,average); return 0;&#125; 编程练习3.6$$根据公式c=\\frac{5}{9}(f-32)，输入华氏温度f，求摄氏温度c，结果精确到小数点后两位。$$ 12345678910#include &lt;stdio.h&gt;int main(void)&#123; double f ; scanf(\"%lf\",&amp;f); double c; c = 5/9.0*(f-32.0); printf(\"%.2lf℉ = %.2lf℃\\n\",f,c); return 0;&#125; 编程练习3.7输入圆的半径，求圆的周长和面积。 1234567891011121314151617#include &lt;stdio.h&gt;int main(void)&#123; int r; double PI = 3.14; double c; double s; //用户输入半径 scanf(\"%d\",&amp;r); //圆的周长 c = PI * (2 * r); //圆的面积 s = PI * (r * r); //输出 printf(\"圆的周长为：%.2lf，圆的面积为：%.2lf。\\n\",c,s); return 0;&#125; 编程练习3.8输入学生的相关信息：学号（int类型）、年龄（int类型）、性别（char 类型，’M’代表男生，’F’代表女生）和五门课程的成绩（double 类型）；输出该学生的相关信息：学号、年龄、性别、各科成绩和平均成绩。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;int main(void)&#123; // 输入学生的相关信息 // 学号：int类型 // 年龄：int类型 // 性别：char类型（M：男生，N：女生） // 五门课程的成绩：double类型 // 学号 int id; // 年龄 int age; // 性别 char sex; // 成绩1 double score1; // 成绩2 double score2; // 成绩3 double score3; // 成绩4 double score4; // 成绩5 double score5; // 获取输入信息 printf(\"请输入学号：\"); scanf(\"%d\",&amp;id); printf(\"请输入年龄：\"); scanf(\"%d\",&amp;age); printf(\"请输入性别(男生：M 女生：F）：\"); getchar(); scanf(\"%c\",&amp;sex); printf(\"请输入语文成绩：\"); scanf(\"%lf\",&amp;score1); printf(\"请输入数学成绩：\"); scanf(\"%lf\",&amp;score2); printf(\"请输入英语成绩：\"); scanf(\"%lf\",&amp;score3); printf(\"请输入物理成绩：\"); scanf(\"%lf\",&amp;score4); printf(\"请输入化学成绩：\"); scanf(\"%lf\",&amp;score5); // 计算平均分 double average = (score1 + score2 + score3 + score4 + score5) / 5; // 输出成绩信息 printf(\"学号\\t\\t年龄\\t\\t性别\\t\\t语文\\t\\t数学\\t\\t英语\\t\\t物理\\t\\t化学\\t\\t平均分\\t\\t\\n\"); printf(\"%d\\t\\t%d\\t\\t%c\\t\\t%.1lf\\t\\t%.1lf\\t\\t%.1lf\\t\\t%.1lf\\t\\t%.1lf\\t\\t%.1lf\\t\\t\\n\",id,age,sex,score1,score2,score3,score4,score5,average); return 0;&#125; 编程练习3.9输入一个四位正整数，求其各位数字之和。例如：1357的各位数字之和为1 + 3 + 5 + 7 = 16 。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main(void)&#123; // 输入一个四位正整数，求其各位数字之和。 int number; // 获取用户输入 scanf(\"%d\",&amp;number); // 计算第一位数 int num1 = number / 1000; printf(\"第一位数是：%d\\n\",num1); // 计算第二位数 int num2 = number % 1000 / 100; printf(\"第二位数是：%d\\n\",num2); // 计算第三位数 int num3 = number % (num1 * 1000 + num2 * 100) /10; printf(\"第三位数是：%d\\n\",num3); // 计算第四位数 int num4 = number % (num1 * 1000 + num2 * 100 + num3 * 10); printf(\"第四位数是：%d\\n\",num4); // 计算各个数字之和 int result = num1 + num2 + num3 + num4; printf(\"%d + %d + %d + %d = %d\\n\",num1,num2,num3,num4,result); return 0;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"标记、类型与表达式","slug":"c_2","date":"2021-03-02T09:02:14.000Z","updated":"2021-07-17T02:35:51.146Z","comments":true,"path":"2021/03/02/c_2/","link":"","permalink":"https://imqinhao.cn/2021/03/02/c_2/","excerpt":"标记 类型 变量与常用类型说明符 运算符与表达式","text":"标记 类型 变量与常用类型说明符 运算符与表达式 标记 标记（token）是具有唯一含义的语言的最小单位，分为五种：关键字（keyword）、标识符（identifier）、常量（constant）、串字面量（string literal）以及标点符号（punctuator）。 关键字关键字也称为保留字，C语言共有44个关键字： auto break case char const continue default do double else enum extern float for goto if inline int long register restrict return short signed sizeof static struct switch typedef union unsigned void volatile while _Alignas _Alignof _Atomic _Bool _Complex _Generic _Imaginary _Noreturn _Static_assert _Thread_local 标识符标识符由小写字母、大写字母、数字、下划线、通用字符名或实现定义的字符构成，且数字不能作为标识符的第一个字符，关键字不能作为标识符。 C语言大小写敏感。 C语言对标识符的最大长度没有具体的限制，VC允许标识符的最大长度为247个字符。 通常，应该选择相应的英文单词或其缩写作为标识符，做到见名知义。 常量 在程序运行过程中，其值不变的量称为常量。常量分为四种类型。 整数常量整数常量只包括正整数和零，不包括负整数。 整数常量分为十进制整数常量、八进制整数常量和十六进制整数常量。 十进制整数常量由 0~9 组成，且以非零数字开头，如 123 、 1000 。 八进制整数常量由 0~7 组成，且以 0 开头，或者只有一个0，如 017 、 0 。 十六进制整数常量由 09 、AF（或 a~f ）组成，且以 0x 或 0X 开头，如0x1a 、 0XD5 。 123456#include &lt;stdio.h&gt;int main(void)&#123; printf(\"sum = %d \\n\",123 + 012 + 0x12); return 0;&#125; 浮点常量计算机中的浮点数只能近似地表示值在某个范围之内的有理数和一些特殊值，如NAN（非数值）、+INF（正无穷大）、-INF（负无穷大）等。 浮点常量是非负的浮点数，其十进制书写形式有以下两种： 小数点表示法 由数字 0 ~9 和小数点组成，必须有小数点。如果小数点左边为0，则 0 可省略；如果小数点右边为 0 ，则 0 可省略。 例如： 5.20 520.0 520. 0.520 .520 0.0 0. .0 指数表示法 第一种形式： 1十进制整数常量E符号位 十进制整数常量 第二种形式： 1浮点常量的小数表示法E符号位 十进制整数常量 其中，E 也可以写成 e ， “符号位” 即正负号是可选的。 枚举常量 枚举常量是类型为 int 的标识符。 字符常量字符常量分为整数字符常量和宽字符常量。 123456#include &lt;stdio.h&gt;int main(void)&#123; printf(\"%d %d %d %d\\n\", 'A' , 'b' + 2 , '0' , '1' + 3); return 0;&#125; 分析 ASCII 码表，可以得出四条规则： （1）数字字符 0~9 的 ASCII 码值是连续递增的。 （2）大写字母 A~Z 的ASCII 码值是连续递增的。 （3）小写字母 a~z 的 ASCII 码值是连续递增的。 （4）大写字母的 ASCII 码比相应小写字母的 ASCII 码值小 32 。 转义序列 含义 十进制ASCII码值 \\a 响铃(alert) 7 \\b 退格(backspace) 8 \\f 走纸换页(form feed) 12 \\n 换行(new line)，光标移到下一行的行首 10 \\r 回车(carriage rerurn)，光标移到当前行的行首 13 \\t 水平制表(horizontal tab)，光标移到当前行的下一个制表位 9 \\v 垂直制表(verical tab) 11 串字面量串字面量分为三种：字符串字面量、UTF-8串字面量 和 宽串字面量。 字符串字面量是用一对双引号括起来的零个或多个字符。在翻译的第七个阶段，空字符即’\\0’被加到字符串字面量的末尾，然后字符串字面量以数组元素类型为 char 的数组的形式存储在内存中。 如果字符串字面中不含’\\0’，则该字符串字面量也称为字符串。 字符串的长度是指空字符前的字符在内存中所占的字节数。因此，长度为 n 的字符串，在内存中占 n+1 个字节。 不要将字符常量与字符串相混淆。例如，’z’ 是字符常量，占 4 个字节；而 “z” 是字符串，占 2 个字节。 类型类型分为两种： 对象类型（object type）：用于描述对象 函数类型（function type）：用于描述函数 基本类型 枚举类型一组命名的整数常量值构成枚举（enumeration），不同的枚举构成不同的枚举类型。 空类型空类型的值的集合是空集，空类型是不完整对象类型，而且不可能是完整的。 派生类型 变量与常用类型说明符变量常用类型说明符有四种，分别是 int 、char、float 和 double 。 变量必须先声明后使用。 常用类型 在 0 ~ 2147483647 范围内的整数常量，其类型是 int 。 char 类型在输入时，两个数字字符之间不能加空格符，如果加了空格符，char 类型的变量获取的是空格符，而不是数字字符。 双精度浮点类型 double 比单精度浮点类型 float 精度更高，表示数据的范围更大。 浮点常量默认是 double 类型，在浮点常量后加后缀 f 或 F 则是 float 类型。 在没有特殊要求的情况下，程序设计中声明浮点常量，建议使用 double 类型。 运算符与表达式表达式表达式是由运算符和运算对象构成的序列。 表达式具有以下一个或多个功能： 描述一个值的计算 指定一个对象或一个函数 产生副作用 根据运算符的运算对象的数量，可将运算符分为以下三种： 单目运算符：只有一个运算对象 双目运算符：有两个运算对象 三目运算符：有三个运算对象 乘法类运算符 乘法运算符 除法运算符 模运算符 * / % 乘法类运算符有三个，都是双目运算符。 加法类运算符 加法运算符 减法运算符 + - 加法类运算符有两个，都是双目运算符。 sizeof运算符 sizeof 运算符是单目运算符，表达式的值是运算对象所占用内存大小（按字节计算），其运算对象是表达式或用小括号括起来的类型名。 char 类型在内存中占 1 个字节。 int 类型在内存中占 4 个字节。 float 类型在内存中占 4 个字节。 double 类型在内存中占 8 个字节。 一元加运算符与一元减运算符一元加运算符 + 是单目运算符，表达式的值是运算对象的值。 一元减运算符 - 是单目运算符，表达式的值是运算对象的相反数。 整数提权实例： 12345678910#include &lt;stdio.h&gt;int main(void)&#123; char ch; printf(\"sizeof +ch = %d\\n\",sizeof +ch); printf(\"sizeof ch = %d\\n\",sizeof ch); printf(\"sizeof -ch = %d\\n\",sizeof -ch); printf(\"sizeof ch = %d\\n\",sizeof ch); return 0;&#125; 运行结果： 1234sizeof +ch &#x3D; 4sizeof ch &#x3D; 1sizeof -ch &#x3D; 4sizeof ch &#x3D; 1 变量 ch 是 char 类型，在内存中占 1 个字节，整数提升将 ch 的值转换为 int 类型的值，因此，表达式 +ch 和 -ch 的类型都是 int ，在内存中占 4 个字节。 注意：变量 ch 的类型并没有改变，仍然是 char 类型。 常用算术转换其中一个运算对象是 double 类型，另一个运算对象的值被转换为 double 类型的值。 如果以上条件不满足，并且其中一个运算对象是 float 类型，另一个运算对象的值被转换为 float 类型的值。 如果以上两个条件都不满足，对两个运算对象进行整数提升，即 char 类型运算对象的值被转换为 int 类型的值。 运算对象的类型并没有改变。","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"C语言绪论","slug":"c_1","date":"2021-03-01T09:02:14.000Z","updated":"2021-07-17T02:35:41.134Z","comments":true,"path":"2021/03/01/c_1/","link":"","permalink":"https://imqinhao.cn/2021/03/01/c_1/","excerpt":"C语言程序的基本结构 C语言程序的上机执行过程 编译 连接 运行","text":"C语言程序的基本结构 C语言程序的上机执行过程 编译 连接 运行 C语言程序的基本结构 C语言程序是由函数构成的。一个C语言程序至少包含一个main函数。 C语言程序总是从main函数开始执行。 为了增强程序的可读性，通常书写C语言程序时应遵循以下规则： 一行内仅写一条语句 正反大括号分别各占一行 每对大括号上下对齐 语句采用缩进格式，错落有致 每条语句的最后必须有一个分号，分号是C语句的组成部分。 C语言本身没有输入/输出语句，输入/输出的操作由scanf和printf等函数来完成。 可以用/* ····· */ 或者 // ······· 在C语言程序中加注释，以增强程序的可读性。 C语言程序的上机执行过程编写好的C语言程序要经过编辑（输入） ，编译 和 连接 后才能形成可执行的程序。 C语言程序的上机执行过程一般要经过四个步骤：编辑（Edit）、编译（compile）、连接（link） 和 运行 。 编辑（Edit） 编辑指源程序的输入，对应的文件称为源文件，其拓展名为”.c“。 编译（compile）编译是使用编译器（compiler）将源文件转换为目标文件的过程。编译器对源程序进行语法检查，当发现错误时，将错误的类型和所在位置显示出来，以帮助程序员修改源程序中的错误。目标文件的扩展名为”.obj“。 连接（link）连接是将目标文件和其他分别进行编译生成的目标文件（如果有的话）以及库函数连接生成可执行文件的过程。可执行文件的扩展名为”.exe“。 运行运行时将可执行文件投入运行，以获取程序处理的结果。如果程序运行结果不正确，则回到第一步，重新对程序进行编辑、编译、连接和运行。直到取得预期结果为止。","categories":[{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[]},{"title":"《网络设备安全配置与管理》综合实训任务书","slug":"network_security_comprehensive","date":"2020-11-01T08:30:11.000Z","updated":"2021-07-17T02:46:28.688Z","comments":true,"path":"2020/11/01/network_security_comprehensive/","link":"","permalink":"https://imqinhao.cn/2020/11/01/network_security_comprehensive/","excerpt":"网络搭建 根据所给定的拓扑要求，将给定的网络设备互连，搭建物理网络。 2. IP 地址规划 根据要求确定所需子网的数量，每个子网的主机数量，设计适当的编址方案，填写网络地址规划表和设备地址表。 3. 网络设备的安全配置 根据任务书中指出的安全需求，完成数据网络安全配置。 4 数据网络安全测试 安全配置后进行完全效果测试，并分析对应的数据包，理解背后的原理。","text":"网络搭建 根据所给定的拓扑要求，将给定的网络设备互连，搭建物理网络。 2. IP 地址规划 根据要求确定所需子网的数量，每个子网的主机数量，设计适当的编址方案，填写网络地址规划表和设备地址表。 3. 网络设备的安全配置 根据任务书中指出的安全需求，完成数据网络安全配置。 4 数据网络安全测试 安全配置后进行完全效果测试，并分析对应的数据包，理解背后的原理。 一、综合实训内容描述《网络设备安全配置与管理》综合实训目的在于通过实际案例需求分析完成设备的仿真配置，同时根据需求完成网络安全配置与管理，保证数据网络安全正常运行。从而能在实际工程中理解网络安全通信的含义。 二、实施中需要完成的工作任务1. ** **网络搭建 根据所给定的拓扑要求，将给定的网络设备互连，搭建物理网络。 2. IP 地址规划 根据要求确定所需子网的数量，每个子网的主机数量，设计适当的编址方案，填写网络地址规划表和设备地址表。 3. 网络设备的安全配置 根据任务书中指出的安全需求，完成数据网络安全配置。 4 数据网络安全测试 安全配置后进行完全效果测试，并分析对应的数据包，理解背后的原理。 三、注意事项项目完成后需要提交相关的WORD规划文件以及相应的配置文档。两份文档存储在文件夹中上交。文件及文件夹命名规则如下： 文档类型 格式 名称 规划表文档 WORD 综合实训任务书（姓名） 配置文档 PKT 综合实训项目（姓名） 四、网络拓扑图如下 五、根据网络安全需求，进行网络安全配置（一）基础配置 1、在Packet Tracer中绘制如图所示拓扑图，模拟某公司分隔两地的总公司和分公司之间通过Internet 连接。（注意：XX为学号最后2位） 2、IP地址规划和配置 （1）IP地址规划： 如拓扑图所示，2个分公司内部采用私网地址，Internet采用公网地址，地址表规划如下： 设备名称 接口 IP 地址 网关 R1 Fa0/0 10.10.11.254/24 Fa1/0 100.1.1.1/30 tunnel 1.1.1.1/24 R3 Fa0/0 192.168.11.254/24 Fa1/0 200.1.1.1/30 tunnel 1.1.1.2/24 ISP router Fa4/0 100.1.1.2/30 Fa5/0 200.1.1.2/30 Fa0/0 201.1.1.254/24 Server 0 Fa0 10.10.11.1/24 10.10.11.254/24 PC1 Fa0 10.10.11.2/24 10.10.11.254/24 PC5 Fa0 10.10.11.3/24 10.10.11.254/24 PC2 Fa0 10.10.11.4/24 10.10.11.254/24 Laptop0 Fa0 201.1.1.1/24 201.1.1.254/24 公网DNS Fa0 201.1.1.252/24 201.1.1.254/24 公网www Fa0 201.1.1.253/24 201.1.1.254/24 公网PC Fa0 201.1.1.2/24 201.1.1.254/24 PC6 Fa0 192.168.11.1/24 192.168.11.254/24 （2）IP地址配置： 按拓扑图地址规划要求： 给各路由器配置对应的IP地址、子网掩码； 给各PC机配置对应的IP地址、子网掩码、网关。 配置命令如下：（注意：配置命令要大概说明其含义） R1 IP 地址配置 12345678910R1&gt; enable #进入特权模式R1# configure terminal #进入全局模式R1(config)# interface fastEthernet 0&#x2F;0 #进入fa0&#x2F;0端口R1(config-if)# ip address 10.10.11.254 255.255.255.0 #配置IP和子网掩码R1(config-if)# no shutdown #启用端口R1(config-if)# exit #退出fa0&#x2F;0端口R1(config)# interface fastEthernet 1&#x2F;0 #进入fa1&#x2F;0端口R1(config-if)# ip address 100.1.1.1 255.255.255.252 #配置IP和子网掩码R1(config-if)# no shutdown #启用端口R1(config-if)# exit #退出fa1&#x2F;0端口 R3 IP 地址配置 12345678910R3&gt; enable #进入特权模式R3# configure terminal #进入全局模式R3(config)# interface fastEthernet 0&#x2F;0 #进入fa0&#x2F;0端口R3(config-if)# ip address 192.168.11.254 255.255.255.0 #配置IP和子网掩码R3(config-if)# no shutdown #启用端口R3(config-if)# exit #退出fa0&#x2F;0端口R3(config)# interface fastEthernet 1&#x2F;0 #进入fa1&#x2F;0端口R3(config-if)# ip address 200.1.1.1 255.255.255.252 #配置IP和子网掩码R3(config-if)# no shutdown #启用端口R3(config-if)# exit #退出fa1&#x2F;0端口 ISP 配置 1234567891011121314ISP&gt; enable #进入特权模式ISP# configure terminal #进入全局模式ISP(config)# interface fastEthernet 4&#x2F;0 #进入fa4&#x2F;0端口ISP(config-if)# ip address 100.1.1.2 255.255.255.252 #配置IP和子网掩码ISP (config-if)# no shutdown #启用端口ISP(config-if)# exit #退出fa4&#x2F;0端口ISP(config)# interface fastEthernet 5&#x2F;0 #进入fa5&#x2F;0端口ISP(config-if)# ip address 200.1.1.2 255.255.255.252 #配置IP和子网掩码ISP(config-if)# no shutdown #启用端口ISP(config-if)# exit #退出fa5&#x2F;0端口ISP(config)# interface fastEthernet 0&#x2F;0 #进入fa0&#x2F;0端口ISP(config-if)# ip address 201.1.1.254 255.255.255.0 #配置IP和子网掩码ISP(config-if)# no shutdown #启用端口ISP(config-if)# exit #退出fa0&#x2F;0端口 3、在总公司和分公司边界路由器上配置默认路由，达到总公司和分公司公网地址互通，配置命令如下：（注意：配置命令要大概说明其含义） R1 配置默认路由 1R1(config)#ip route 0.0.0.0 0.0.0.0 100.1.1.2 #配置默认路由 R3 配置默认路由 1R3(config)#ip route 0.0.0.0 0.0.0.0 100.1.1.2 #配置默认路由 4、测试R1和R3的公网地址间的互通性（验证Internet互通），截图如下：（注意：说明为什么） 答：可以互通，因为R1配置了默认路由，全部数据包转发给了ISP的Fa4/0端口，而R3配置了默认路由，全部数据包转发给了ISP的Fa5/0端口，最终数据包在同一个路由器的两个端口上，所以可以直接通信。 （二）路由器R1的SSH登录服务配置： 1、SSH登录要求： 在路由器R1上配置SSH登录服务，其中所有的域名、用户名、密码等皆为wtctx-YYY（YYY为姓名缩写） 2、配置命令如下：（注意：配置命令要大概说明其含义） 12345678910R1(config)# hostname R1 #配置ssh前必须修改主机名R1(config)# ip domain-name wtctx-qh #给路由器设置域名R1(config)# crypto key generate rsa #生成rsa秘钥R1(config)# line vty 0 15 #进入vty端口，最多15人同时在线R1(config-line)# transport input ssh #启用SSH登录R1(config-line)# privilege level 15 #设置用户操作等级为最高级R1(config-line)# login local #使用本地验证R1(config-line)# exit #退出到全局模式R1(config)# username wtctx-qh password wtctx-qh #创建用户名和密码R1(config)# enable secret wtctx-qh #设置密文密码 3、测试PC2 SSH登录R1，截图如下： （三）交换机端口安全配置： 1、在总公司交换机上端口安全要求： （1）f0/1端口采用静态MAC地址学习方式，指定服务器0的MAC地址，端口最大MAC地址数为？违规处理方式shutdown （2）f0/2端口采用sticky MAC地址学习方式，端口最大MAC地址数为？违规处理方式restrict 2、相关配置命令如下：（注意：配置命令要大概说明其含义） Fa0/1 端口配置 1234567891011Switch&gt; en #进入特权模式Switch# configure terminal #进入全局模式Switch(config)# interface fastEthernet 0&#x2F;1 #进入Fa0&#x2F;1端口Switch(config-if)# shutdown #关闭端口，清空mac地址表Switch(config-if)# switchport mode access #端口定义为access口Switch(config-if)# switchport port-security #开启端口安全功能Switch(config-if)# switchport nonegotiate #禁用DTPSwitch(config-if)# switchport port-security maximum 1 #设置允许最大地址数为1Switch(config-if)# switchport port-security mac-address 0090.0C62.168A #绑定允许接入的地址Switch(config-if)# switchport port-security violation shutdown #指定违规处理行为Switch(config-if)# no shutdown #启用端口 解析：端口最大mac地址数为1即可，由于Fa0/1与服务器0是直连的，绑定服务器0的mac地址即可限制其它设备接入。 Fa0/2 端口配置 1234567891011Switch&gt; en #进入特权模式Switch# configure terminal #进入全局模式Switch(config)# interface fastEthernet 0&#x2F;2 #进入Fa0&#x2F;1端口Switch(config-if)# shutdown #关闭端口，清空mac地址表Switch(config-if)# switchport mode access #端口定义为access口Switch(config-if)# switchport port-security #开启端口安全功能Switch(config-if)# switchport nonegotiate #禁用DTPSwitch(config-if)# switchport port-security maximum 3 #设置允许最大地址数为3Switch(config-if)# switchport port-security mac-address sticky #绑定允许接入的地址Switch(config-if)# switchport port-security violation restrict #指定违规处理行为Switch(config-if)# no shutdown #启用端口 解析：端口最大mac地址数为3，通过观察交换机的mac地址表可以看出，交换机一共粘贴到了三个地址，Fa0/2端口下另外一个交换机的Fa0/1号端口的mac地址，和PC1与PC5的mac地址。添加其他设备发现无法通信，表明最大数为3是正确的。 （四）无线局域网安全配置： 在分公司无线路由器上做安全配置： 1、基础安全设置：（XX为学号最后2位） 1）修改无线路由器默认的管理密码为：wtctx 2）修改LAN口地址：192.168.XX+1.1/24 3）修改SSID：wtctx18 4）无线安全配置： 认证：WPA2-PSK 加密：AES 预共享密钥：wtctx2020 2、进一步安全配置： 1）隐藏SSID 2）无线mac地址过滤 只允许图中3台无线设备laptop0、Smartphone0、Table PC0的mac地址接入，其他不允许 设备 mac地址 Laptop0 0001.642A.4045 Smartphone0 0001.4205.D0AC Tablet PC0 0001.C7B0.ED9E 3、测试各无线终端与PC6的连通性，截图显示如下： （五）GRE over IPSec VPN配置： 1、在企业总公司和分公司间配置GRE over IPSec VPN (企业总公司和分公司间参数一致)，要求： （1）GRE tunnel两端地址分别为：1.1.1.1/24和1.1.1.2/24 ，tunnel编号为120 （2）企业总公司和分公司间运行rip协议或OSPF实现互通 （3）IPSec配置：设置IKE参数,策略优先级为1（预共享验证、DES加密、MD5验证，DH组2，预共享验证密钥为wtctx） （4）Ipsec SA 参数设置：ESP-DES加密、ESP-MD5-HMAC验证 （5）VPN数据流acl编号为110 （6）transform-set 命名为wtctxset1，crypto map命名为wtctxmap 2、配置如下：（注意：配置命令要大概说明其含义） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253R1(config)#interface tunnel 120 #创建虚拟tunnel端口R1(config-if)#ip address 1.1.1.1 255.255.255.0 #定义tunnel接口的IP地址R1(config-if)#tunnel source fastEthernet 1&#x2F;0 #定义tunnel通道的源地址R1(config-if)#tunnel destination 200.1.1.1 #定义tunnel通道的目的地址R1(config)#router rip #启用rip路由协议R1(config-router)#version 2 #定义rip v2版本R1(config-router)#no auto-summary #关闭自动汇总R1(config-router)#network 10.10.11.0 #宣告自己的网段R1(config-router)#network 1.1.1.1 #宣告自己的网段R1(config-router)# exit #回到全局模式R1(config)# crypto isakmp enable #启用IKER1(config)# crypto isakmp policy 1 #建立IKE策略，优先级为1R1(config-isakmp)# authentication pre-share #使用预共享的密码进行身份验证R1(config-isakmp)# encryption des #使用DES加密方式R1(config-isakmp)# hash md5 #指定Hash算法为MD5R1(config-isakmp)# group 2 #指定秘钥位数，group2安全性更高R1(config-isakmp)# exit #回到全局模式R1(config)#access-list 110 permit gre host 100.1.1.1 host 200.1.1.1 #定义感兴趣流量R1(config)# crypto isakmp key wtctx address 200.1.1.1 #设置预共享秘钥和对端IPR1(config)#crypto ipsec transform-set wtctxset1 esp-des esp-md5-hmac #配置IPSec交换集R1(config)#crypto map wtctxmap 1 ipsec-isakmp #创建加密图R1(config-crypto-map)#set peer 200.1.1.1 #标识对方路由器IP地址R1(config-crypto-map)#set transform-set wtctxset1 #指定加密图使用的IPSec交换集R1(config-crypto-map)#match address 110 #用ACL来定义加密的通信R1(config-crypto-map)#exit #回到全局模式R1(config)#interface fastEthernet 1&#x2F;0 #进入Fa1&#x2F;0端口R1(config-if)#crypto map wtctxmap #应用加密图到接口R3(config)#interface tunnel 120 #创建虚拟tunnel端口R3(config-if)#ip address 1.1.1.2 255.255.255.0 #定义tunnel接口的IP地址R3(config-if)#tunnel source fastEthernet 1&#x2F;0 #定义tunnel通道的源地址R3(config-if)#tunnel destination 100.1.1.1 #定义tunnel通道的目的地址R3(config)#router rip #启用rip路由协议R3(config-router)#version 2 #定义rip v2版本R3(config-router)#no auto-summary #关闭自动汇总R3(config-router)#network 192.168.11.0 #宣告自己的网段R3(config-router)#network 1.1.1.2 #宣告自己的网段R3(config)# crypto isakmp enable #启用IKER3(config)# crypto isakmp policy 1 #建立IKE策略，优先级为1R3(config-isakmp)# authentication pre-share #使用预共享的密码进行身份验证R3(config-isakmp)# encryption des #使用DES加密方式R3(config-isakmp)# hash md5 #指定Hash算法为MD5R3(config-isakmp)# group 2 #指定秘钥位数，group2安全性更高R3(config-isakmp)# exit #回到全局模式R3(config)#access-list 110 permit gre host 200.1.1.1 host 100.1.1.1 #定义感兴趣流量R3(config)# crypto isakmp key wtctx address 100.1.1.1 #设置预共享秘钥和对端IPR3(config)#crypto ipsec transform-set wtctxset1 esp-des esp-md5-hmac #配置IPSec交换集R3(config)#crypto map wtctxmap 1 ipsec-isakmp #创建加密图R3(config-crypto-map)#set peer 100.1.1.1 #标识对方路由器IP地址R3(config-crypto-map)#set transform-set wtctxset1 #指定加密图使用的IPSec交换集R3(config-crypto-map)#match address 110 #用ACL来定义加密的通信R3(config-crypto-map)#exit #回到全局模式R3(config)#interface fastEthernet 1&#x2F;0 #进入Fa1&#x2F;0端口R3(config-if)#crypto map wtctxmap #应用加密图到接口 3、测试： 总公司PC5和分公司PC6间以私有地址互访，截图如下： 4、分析GRE over Ipsec VPN的数据包 答：可以看到入站前源地址和目的地址都是私网地址，经过路由器，从出站方向可以看到添加了GRE头部，然后添加了公网地址的头部，源地址和目的地址都为公网地址，然后经过IPsec加密，最后添加了公网地址的头部进行传送。 （六）Easy VPN配置： 1、在R1上配置Easy VPN，配置策略要求如下： （1）设置IKE参数,策略优先级为2（预共享验证、DES加密、MD5验证、DH组2） （2）启动aaa，设置认证组名为wtc-a，授权组名为wtc-o，用户名和密码为wtc （3）设置策略组名为wtcgroup、密码为wtckey，地址池为wtcpool，地址范围172.16.1.1—172.16.1.254 （4）设置 transform-set 命名为wtctxset2（ESP-DES加密、ESP-MD5-HMAC验证），动态crypto map命名为wtcdmap，静态crypto map命名为wtctxmap 2、配置命令如下：（注意：配置命令要大概说明其含义） 12345678910111213141516171819202122232425R1(config)# crypto isakmp policy 2 ##建立IKE策略，优先级为2R1(config-isakmp)# authentication pre-share #使用预共享的密码进行身份验证R1(config-isakmp)# encryption des #使用DES加密方式R1(config-isakmp)# hash md5 #指定Hash算法为MD5R1(config-isakmp)# group 2 #指定秘钥位数，group2安全性更高R1(config)# aaa new-model #启用aaaR1(config)# aaa authentication login wtc-a local #认证R1(config)# aaa authorization network wtc-o local #授权R1(config)# username wtc password wtc #在交换机本地设置一个用户R1(config)# ip local pool wtcpool 172.16.1.1 172.16.1.254 #定义地址池R1(config)# crypto isakmp client configuration group wtcgroup #配置用户组策略R1(config-isakmp-group)# key wtckey #定义密码R1(config-isakmp-group)# pool wtcpool #定义使用的地址池R1(config-isakmp-group)# exit #回到全局模式R1(config)# crypto ipsec transform-set wtctxset2 esp-des esp-md5-hmac #配置IPSec交换集R1(config)# crypto dynamic-map wtcdmap 2 #定义动态保密图R1(config-crypto-map)# set transform-set wtctxset2 #设置调用的IPsec交换集R1(config-crypto-map)# reverse-route #路由器必须配置此功能R1(config-crypto-map)# exit #回到全局模式R1(config)# crypto map wtctxmap client authentication list wtc-a #设置认证用户列表R1(config)# crypto map wtctxmap isakmp authorization list wtc-o #设置授权用户列表R1(config)# crypto map wtctxmap client configuration address respond # VPN地址推送方式R1(config)# crypto map wtctxmap 2 ipsec-isakmp dynamic wtcdmap #将动态保密图映射到静态保密图R1(config-crypto-map)# exit #回到全局模式R1(config)# interface fastEthernet 1&#x2F;0 #进入Fa1&#x2F;0端口R1(config-if)# crypto map wtctxmap #关联到Fa1&#x2F;0端口 3、测试： 出差员工PC以VPN登录，能访问公总司PC，截图显示 4、分析easy VPN的数据包 答：位于公网的电脑，登录easy VPN之后会自动获取到一个我们设置的地址池地址，和位于公司总部的电脑进行通信时，首先在公网这边的路由器ISP进站源地址是分配的地址池IP，目的地址为分公司私网地址，出站后添加了ESP头部，然后添加了公网地址头。在总公司路由器进站则是将添加了私网地址头，源地址为公网电脑登录VPN分配的地址池IP，目的地址为总公司内部的私网地址。 （七）NAT配置： 1、在企业总公司边界路由器R1上配置静态一对多nat，实现公网PC能访问内网服务器0的web服务和ftp服务，要求： 内网服务器对应的公网地址为：202.56.110.1 2、在企业总公司边界路由器R1上配置PAT，实现内网用户访问公网WWW服务器和公网PC，要求： （1）公网IP地址直接为私网接口地址； （2）私网地址acl编号为1 3、配置命令如下：（注意：配置命令要大概说明其含义） 1234567R1(config)#interface fastEthernet 0&#x2F;0 #进入Fa0&#x2F;0端口R1(config-if)#ip nat inside #定义对于NAT来说内部接口R1(config)#interface fastEthernet 1&#x2F;0 #进入Fa1&#x2F;0端口R1(config-if)#ip nat outside #定义对于NAT来说外部接口R1(config)#ip nat inside source static tcp 10.10.11.1 80 202.56.110.1 80R1(config)#ip nat inside source static tcp 10.10.11.1 20 202.56.110.1 20R1(config)#ip nat inside source static tcp 10.10.11.1 21 202.56.110.1 21 1ISP(config)#ip route 202.56.110.1 255.255.255.255 100.1.1.1 #配置静态路由 12R1(config)#access-list 1 permit 10.10.11.0 0.0.0.255 #acl列表R1(config)#ip nat inside source list 1 interface fastEthernet 1&#x2F;0 overload #定义转换源 4、测试： （1）公网PC能访问总公司内网服务器0的www服务，截图如下： （2）公网PC能访问总公司内网服务器0的ftp服务，截图如下： （3）总公司PC能访问公网服务器，截图如下：","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://imqinhao.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"Java 设计模式-1","slug":"Design_patterns_1","date":"2020-10-20T12:40:00.000Z","updated":"2021-07-17T02:39:21.829Z","comments":true,"path":"2020/10/20/Design_patterns_1/","link":"","permalink":"https://imqinhao.cn/2020/10/20/Design_patterns_1/","excerpt":"1.设计模式原则 2.设计模式分类 3.常用设计模式 4.工厂模式定义 5.工厂模式类图 6.工厂模式示例 7.工厂模式应用 8.抽象工厂模式定义 9.抽象工厂模式类图 10.抽象工厂模式示例 11.抽象工厂模式应用 12.工厂方法模式、抽象工厂模式区别","text":"1.设计模式原则 2.设计模式分类 3.常用设计模式 4.工厂模式定义 5.工厂模式类图 6.工厂模式示例 7.工厂模式应用 8.抽象工厂模式定义 9.抽象工厂模式类图 10.抽象工厂模式示例 11.抽象工厂模式应用 12.工厂方法模式、抽象工厂模式区别 什么是设计模式在软件工程中，设计模式是对软件设计中普遍存在的各种问题，所提出的解决方案。 换句话说，设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计的经验的总结。使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性。 设计模式原则开闭原则开闭原则的意思是：对扩展开放，对修改封闭。在程序需要进行扩展的时候，不能去修改或影响原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性更好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。 里氏代换原则里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当子类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而且子类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则这个原则是开闭原则的基础，核心内容：针对接口编程，高层模块不应该依赖底层模块，二者都应该依赖抽象而不依赖于具体。 接口隔离原则这个原则的意思是：使用多个隔离的接口，比使用单个庞大的接口要好。其目的在于降低耦合度。由此可见，其实设计模式就是从大型软件架构出发，便于升级和维护软件的设计思想。它强调低依赖、低耦合。 单一职责原则类的职责要单一，不能将太多的职责放在一个类中。 可能有的人会觉得单一职责原则和前面的接口隔离原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要约束的是类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。 最少知道原则最少知道原则也叫迪米特法则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 一个对象应该对其他对象保持最少的了解。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。所以在类的设计上，每一个类都应当尽量降低成员的访问权限。 合成复用原则合成复用原则就是在一个新的对象里通过关联关系（组合关系、聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简而言之，尽量多使用组合/聚合的方式，尽量少使用甚至不使用继承关系。 设计模式分类通常来说设计模式分为三大类： 创建型模式，共 5 种：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共 7 种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共 11 种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 什么是工厂模式 工厂模式（Factory Pattern）的意义就跟它的名字一样，在面向对象程序设计中，工厂通常是一个用来创建其他对象的对象。工厂模式根据不同的参数来实现不同的分配方案和创建对象。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。例如用工厂来创建 人 这个对象，如果我们需要一个男人对象，工厂就会为我们创建一个男人；如果我们需要一个女人，工厂就会为我们生产一个女人。 工厂模式通常分为： 普通工厂模式 多个工厂方法模式 静态工厂方法模式 普通工厂模式刚刚我们说到，用工厂模式来创建人。先创建一个男人，他每天都“吃饭、睡觉、打豆豆”，然后我们再创建一个女人，她每天也“吃饭、睡觉、打豆豆”。 我们以普通工厂模式为例，在 project 目录下新建一个FactoryTest.java。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 二者共同的接口interface Human&#123; public void eat(); public void sleep(); public void beat();&#125;// 创建实现类 Maleclass Male implements Human&#123; public void eat()&#123; System.out.println(\"Male can eat.\"); &#125; public void sleep()&#123; System.out.println(\"Male can sleep.\"); &#125; public void beat()&#123; System.out.println(\"Male can beat.\"); &#125;&#125;//创建实现类 Femaleclass Female implements Human&#123; public void eat()&#123; System.out.println(\"Female can eat.\"); &#125; public void sleep()&#123; System.out.println(\"Female can sleep.\"); &#125; public void beat()&#123; System.out.println(\"Female can beat.\"); &#125;&#125;// 创建普通工厂类class HumanFactory&#123; public Human createHuman(String gender)&#123; if( gender.equals(\"male\") )&#123; return new Male(); &#125;else if( gender.equals(\"female\"))&#123; return new Female(); &#125;else &#123; System.out.println(\"请输入正确的类型！\"); return null; &#125; &#125;&#125;// 工厂测试类public class FactoryTest &#123; public static void main(String[] args)&#123; HumanFactory factory = new HumanFactory(); Human male = factory.createHuman(\"male\"); male.eat(); male.sleep(); male.beat(); &#125;&#125; 编译运行12javac FactoryTest.javajava FactoryTest 运行结果 多个工厂方法模式普通工厂模式就是上面那样子了，那么多个工厂方法模式又有什么不同呢？在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象。多个工厂方法模式是提供多个工厂方法，分别创建对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package 设计模式;//两者共同的接口interface Human &#123; public void eat(); public void sleep(); public void beat();&#125;//创建实现类Maleclass Male implements Human &#123; public void eat() &#123; System.out.println(\"Male can eat.\"); &#125; public void sleep() &#123; System.out.println(\"Male can sleep.\"); &#125; public void beat() &#123; System.out.println(\"Male can beat.\"); &#125;&#125;//创建实现类Femaleclass Female implements Human &#123; public void eat() &#123; System.out.println(\"Female can eat.\"); &#125; public void sleep() &#123; System.out.println(\"Female can sleep.\"); &#125; public void beat() &#123; System.out.println(\"Female can beat.\"); &#125;&#125;//多个工厂方法class HumanFactory &#123; public Male CreateMale() &#123; return new Male(); &#125; public Female createFemale() &#123; return new Female(); &#125;&#125;//工厂测试类public class FactoryTest2 &#123; public static void main(String args[]) &#123; HumanFactory factory = new HumanFactory(); Human maleHuman = factory.CreateMale(); maleHuman.eat(); maleHuman.sleep(); maleHuman.beat(); &#125;&#125; 编译运行12javac FactoryTest2.javajava FactoryTest2 运行结果 静态工厂方法模式将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package 设计模式;//两者共同的接口interface Human &#123; public void eat(); public void sleep(); public void beat();&#125;//创建实现类Maleclass Male implements Human &#123; public void eat() &#123; System.out.println(\"Male can eat.\"); &#125; public void sleep() &#123; System.out.println(\"Male can sleep.\"); &#125; public void beat() &#123; System.out.println(\"Male can beat.\"); &#125;&#125;//创建实现类Femaleclass Female implements Human &#123; public void eat() &#123; System.out.println(\"Female can eat.\"); &#125; public void sleep() &#123; System.out.println(\"Female can sleep.\"); &#125; public void beat() &#123; System.out.println(\"Female can beat.\"); &#125;&#125;//多个工厂方法class HumanFactory&#123; public static Male createMale() &#123; return new Male(); &#125; public static Female createFemale() &#123; return new Female(); &#125;&#125;//工厂测试类public class FactoryTest2 &#123; public static void main(String[] args)&#123; Human male = HumanFactory.createMale(); male.eat(); male.sleep(); male.beat(); &#125;&#125; 总结：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 什么是抽象工厂模式抽象工厂模式（Abstract Factory Pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。如果比较抽象工厂模式和工厂模式，我们不难发现前者只是在工厂模式之上增加了一层抽象的概念。抽象工厂是一个父类工厂，可以创建其它工厂类。所以我们也叫它 “工厂的工厂”。 抽象工厂模式类图“女娲娘娘”只有一个，而我们的工厂却可以有多个，因此在这里用作例子就不合适了。作为“女娲娘娘”生产出来的男人女人们，那就让我们来当一次吃货吧。（吃的东西总可以任性多来一点） 现在，假设我们有 A、B 两个厨房。每个厨房拥有的餐具和食品都不一样，但是用户搭配使用的方式，比如刀子和苹果、杯子和牛奶等等，我们假设是一致的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package 抽象工厂模式;//抽象食物interface Food&#123; public String getFoodName();&#125;//抽象餐具interface TableWare&#123; public String getToolName();&#125;//抽象工厂interface KitchenFactory&#123; public Food getFood(); public TableWare getTableWare();&#125;//具体食物 Apple 的定义如下class Apple implements Food&#123; @Override public String getFoodName() &#123; return \"apple\"; &#125;&#125;//具体餐具 Knife 的定义如下class Knife implements TableWare&#123; @Override public String getToolName() &#123; return \"knife\"; &#125;&#125;//以具体工厂 AKitchen 为例class AKitchen implements KitchenFactory&#123; @Override public Food getFood() &#123; return new Apple(); &#125; @Override public TableWare getTableWare() &#123; return new Knife(); &#125;&#125;//吃货要开吃了public class Foodaholic &#123; public void eat(KitchenFactory kitchenFactory) &#123; System.out.println(\"A foodaholic is eating \" + kitchenFactory.getFood().getFoodName() + \" with \" + kitchenFactory.getTableWare().getToolName()); &#125; public static void main(String[] args) &#123; Foodaholic foodaholic = new Foodaholic(); KitchenFactory kitchenFactory = new AKitchen(); foodaholic.eat(kitchenFactory); &#125; &#125; 编译运行12javac Foodaholic.javajava Foodaholic 运行结果 抽象工厂模式特别适合于这样的一种产品结构：产品分为几个系列，在每个系列中，产品的布局都是类似的，在一个系列中某个位置的产品，在另一个系列中一定有一个对应的产品。这样的产品结构是存在的，这几个系列中同一位置的产品可能是互斥的，它们是针对不同客户的解决方案，每个客户都只选择其一。 工厂方法模式、抽象工厂模式区别工厂方法模式、抽象工厂模式，傻傻分不清楚。 为了解释得更清楚，先介绍两个概念： 产品等级结构：比如一个抽象类是食物，其子类有苹果、牛奶等等，则抽象食物与具体食物名称之间构成了一个产品等级结构。食物是抽象的父类，而具体的食物名称是其子类。 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。如 AKitchen 生产的苹果、刀子，苹果属于食物产品等级结构中，而刀子则属于餐具产品等级结构中。而 BKitchen 可能生成另一组产品，如牛奶、杯子。 因此工厂方法模式、抽象工厂模式最大的区别在于： 工厂方法模式：针对的是 一个产品等级结构。 抽象工厂模式：针对 多个产品等级结构。 什么是适配器模式顾名思义，适配器模式（Adapter Pattern）当然是用来适配的啦。当你想使用一个已有的类，但是这个类的接口跟你的又不一样，不能拿来直接用，这个时候你就需要一个适配器来帮你了。 这就好像你兴冲冲地跑去香港，买了个港版的 iPhone6，充电器插头拿回家一看，不能用啊。这时候你多么需要买一个转接头适配器… 你去香港旅游，买的 iPhone6 的充电器插头是英标的，它是那种三脚是方形的插头。 而咱们国标的插头是两只脚，即使是三只脚的插头也和英标不一样。 为了方便，这里我们就假设国标插头就只是两只脚的插头吧。 好的，目标明确，英标三只脚插头充电，国标两只脚插头充电。你家很富，有很多插座可以充电。 在国内的家中只能用国标接口进行充电。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 国标插头public interface CnPluginInterface &#123; void chargeWith2Pins();&#125;// 实现国标插座的充电方法public class CnPlugin implements CnPluginInterface &#123; public void chargeWith2Pins() &#123; System.out.println(\"charge with CnPlugin\"); &#125;&#125;// 在国内家中充电public class Home &#123; private CnPluginInterface cnPlugin; public Home() &#123; &#125; public Home(CnPluginInterface cnPlugin) &#123; this.cnPlugin = cnPlugin; &#125; public void setPlugin(CnPluginInterface cnPlugin) &#123; this.cnPlugin = cnPlugin; &#125; // 充电 public void charge() &#123; // 国标充电 cnPlugin.chargeWith2Pins(); &#125;&#125;// 国标测试类public class CnTest &#123; public static void main(String[] args) &#123; CnPluginInterface cnPlugin = new CnPlugin(); Home home = new Home(cnPlugin); // 会输出 “charge with CnPlugin” home.charge(); &#125;&#125; 然而，当把 iPhone6 带回来时，因为与家里的插座不匹配，所以需要一个适配器。这个适配器必须满足以下条件： 插头必须符合国内标准的接口，否则的话还是没办法插到国内插座中。 在调用上面实现的国标接口进行充电时，提供一种机制，将这个调用转到对英标接口的调用 。 这就要求： 适配器必须实现原有的旧的接口。 适配器对象中持有对新接口的引用，当调用旧接口时，将这个调用委托给实现新接口的对象来处理，也就是在适配器对象中组合一个新接口。 1234567891011121314151617181920212223242526272829303132333435363738// 英标插头public interface EnPluginInterface &#123; void chargeWith3Pins();&#125;// 实现英标插座的充电方法public class EnPlugin implements EnPluginInterface &#123; public void chargeWith3Pins() &#123; System.out.println(\"charge with EnPlugin\"); &#125;&#125;//适配器public class PluginAdapter implements CnPluginInterface &#123; private EnPluginInterface enPlugin; public PluginAdapter(EnPluginInterface enPlugin) &#123; this.enPlugin = enPlugin; &#125; // 这是重点，适配器实现了国标的插头，然后重写国标的充电方法，在国标的充电方法中调用英标的充电方法 @Overridepublic void chargeWith2Pins() &#123; enPlugin.chargeWith3Pins(); &#125;&#125;// 适配器测试类public class AdapterTest &#123; public static void main(String[] args) &#123; EnPluginInterface enPlugin = new EnPlugin(); Home home = new Home(); PluginAdapter pluginAdapter = new PluginAdapter(enPlugin); home.setPlugin(pluginAdapter); // 会输出 “charge with EnPlugin” home.charge(); &#125;&#125; 适配器模式的三个特点 适配器对象实现原有接口 适配器对象组合一个实现新接口的对象（这个对象也可以不实现一个接口，只是一个单纯的对象） 对适配器原有接口方法的调用被委托给新接口的实例的特定方法","categories":[{"name":"Java","slug":"Java","permalink":"https://imqinhao.cn/categories/Java/"}],"tags":[]},{"title":"TCP/IP简介","slug":"linux","date":"2020-10-05T05:14:14.000Z","updated":"2021-07-17T02:43:05.354Z","comments":true,"path":"2020/10/05/linux/","link":"","permalink":"https://imqinhao.cn/2020/10/05/linux/","excerpt":"知识点 IP 地址 域名 MAC 地址 端口号 封装和分用","text":"知识点 IP 地址 域名 MAC 地址 端口号 封装和分用 提到网络协议栈结构，最著名的当属 OSI 七层模型，但是 TCP/IP 协议族的结构则稍有不同，它们之间的层次结构有如图对应关系： 可见 TCP/IP 被分为 4 层，每层承担的任务不一样，各层的协议的工作方式也不一样，每层封装上层数据的方式也不一样： 应用层：应用程序通过这一层访问网络，常见 FTP、HTTP、DNS 和 TELNET 协议； 传输层：TCP 协议和 UDP 协议； 网络层：IP 协议，ARP、RARP 协议，ICMP 协议等； 网络接口层：是 TCP/IP 协议的基层，负责数据帧的发送和接收。 TCP/IP（Transmission Control Protocol/Internet Protocol）是传输控制协议和网络协议的简称，它定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。 TCP/IP 不是一个协议，而是一个协议族的统称，里面包括了 IP 协议、ICMP 协议、TCP 协议、以及 http、ftp、pop3 协议等。网络中的计算机都采用这套协议族进行互联。 IP地址网络上每一个节点都必须有一个独立的 IP 地址，通常使用的 IP 地址是一个 32bit 的数字，被 . 分成 4 组，例如，255.255.255.255 就是一个 IP 地址。有了 IP 地址，用户的计算机就可以发现并连接互联网中的另外一台计算机。 在 终端输入 ifconfig -a 命令查看自己的 IP 地址： 1ifconfig -a 域名用 12 位数字组成的 IP 地址很难记忆，在实际应用时，用户一般不需要记住 IP 地址，互联网给每个 IP 地址起了一个别名，习惯上称作域名。 域名与计算机的 IP 地址相对应，并把这种对应关系存储在域名服务系统 DNS(Domain Name System) 中，这样用户只需记住域名就可以与指定的计算机进行通信了。 常见的域名包括 com、net 和 org 三种顶级域名后缀，除此之外每个国家还有自己国家专属的域名后缀（比如我国的域名后缀为 cn）。目前经常使用的域名诸如百度（www.baidu.com）、Linux 组织（www.lwn.net）等等。 我们可以使用命令 nslookup 或者 ping 来查看与域名相对应的 IP 地址，由于实验楼网络限制，我们可以使用 ping github.com（如果 github 也 ping 不通，那么可以使用 ping labfile.oss.aliyuncs.com，如果你是会员账户，那么也可以 ping 其他的域名）查看。 例如： MAC地址MAC（Media Access Control）地址，或称为物理地址、硬件地址，用来定义互联网中设备的位置。 在 TCP/IP 层次模型中，网络层管理 IP 地址，链路层则负责 MAC 地址。因此每个网络位置会有一个专属于它的 IP 地址，而每个主机会有一个专属于它 MAC 地址。 端口号IP 地址是用来发现和查找网络中的地址，但是不同程序如何互相通信呢？这就需要端口号来识别了。如果把 IP 地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是端口采用 16 比特的端口号标识，一个 IP 地址的端口可以有 65536（即：216）个之多！ 服务器的默认程序一般都是通过人们所熟知的端口号来识别的。例如，对于每个 TCP/IP 实现来说，SMTP（简单邮件传输协议）服务器的 TCP 端口号都是 25，FTP（文件传输协议）服务器的 TCP 端口号都是 21，TFTP（简单文件传输协议）服务器的 UDP 端口号都是 69。任何 TCP/IP 实现所提供的服务都用众所周知的 1－1023 之间的端口号。这些人们所熟知的端口号由 Internet 端口号分配机构（Internet Assigned Numbers Authority，IANA）来管理。 常用协议对应端口号： SSH 22 FTP 20 和 21 Telnet 23 SMTP 25 TFTP 69 HTTP 80 SNMP 161 Ping 使用 ICMP，无具体端口号 封装和分用封装：当应用程序发送数据的时候，数据在协议层次当中自顶向下通过每一层，每一层都会对数据增加一些首部或尾部信息，这样的信息称之为协议数据单元（Protocol Data Unit，缩写为 PDU），在分层协议系统里，在指定的协议层上传送的数据单元，包含了该层的协议控制信息和用户信息。如下图所示： 物理层（一层）PDU 指数据位（Bit） 数据链路层（二层）PDU 指数据帧（Frame） 网络层（三层）PDU 指数据包（Packet） 传输层（四层）PDU 指数据段（Segment） 第五层以上为数据（data） 分用：当主机收到一个数据帧时，数据就从协议层底向上升，通过每一层时，检查并去掉对应层次的报文首部或尾部，与封装过程正好相反。 RFCRFC（Request for Comment）文档是所有以太网协议的正式标准，并在其官网上面公布，由 IETF 标准协会制定。大量的 RFC 并不是正式的标准，出版的目的只是为了提供信息。RFC 的篇幅不一，从几页到几百页不等。每一种协议都用一个数字来标识，如 RFC 3720 是 iSCSI 协议的标准，数字越大意味着 RFC 的内容越新或者是对应的协议（标准）出现的比较晚。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://imqinhao.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"5G网络优化","slug":"5G网络优化","date":"2020-10-01T02:00:00.000Z","updated":"2021-07-17T02:31:04.521Z","comments":true,"path":"2020/10/01/5G网络优化/","link":"","permalink":"https://imqinhao.cn/2020/10/01/5G%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/","excerpt":"5G覆盖指标定义 覆盖率 覆盖优化整体流程 NR覆盖类问题及优化方案","text":"5G覆盖指标定义 覆盖率 覆盖优化整体流程 NR覆盖类问题及优化方案 5G覆盖指标定义广播信道SS参考信号接收功率(SS-RSRP) :测量频段带宽上承载辅同步信号(SS) 的资源单元接收功率贡献的线性平均值; SS信噪比和干扰比(SS SINR)定义为”携带辅同步信号的资源单元的功率贡献的线性平均值”除以”在相同频率带宽内承载辅同步信号的资源单元的噪声和干扰功率的线性平均值”; 业务信道CSI参考信号接收功率(CSI-RSRP) 被定义为在所配置的CSI中在所考虑的测量频率带宽内承载用于RSRP测量的CSI参考信号的资源单元的功率贡献上的线性平均值; CSI信噪比和干扰比(CSI-SINR) 被定义为”携带CSI参考信号的资源单元的功率贡献的线性平均值”除以”携带CSI参考信号的资源单元在相同频率带宽内的参考信号的噪声和干扰功率的线性平均值”。 覆盖率 NR和LTE的覆盖相关差异 NR覆盖优化基础覆盖优化的原则 先优化SS-RSRP，后优化SS-SINR 覆盖优化的两大关键任务：消除弱覆盖（保证SS-RSRP）；净化切换带、消除交叉覆盖 优先优化弱覆盖、越区覆盖、再优化重叠覆盖 优先调整天线的下倾角、方位角、天线挂高和迁站及加站，最后考虑调整RS的发射功率和波束管理相关参数以及天线权值 覆盖优化整体流程覆盖优化的流程 数据采集：通过不同的数据采集系统进行覆盖相关数据采集 数据分析：结合采集结果对数据进行综合分析，确定指标情况 原因分析：对存在覆盖问题的小区进行分析，并确定原因 方案制定：基于覆盖问题的原因，制定覆盖优化方案 方案实施：方案实施，并进行方案实施前后的评估 数据采集覆盖指标的来源有哪些？ 覆盖评估 覆盖类问题分析 覆盖问题原因 故障问题 环境变化 新的需求 规划问题 施工问题 参数问题 故障问题设备问题是指由于基站设备出现故障，导致无法提供服务，从而引起覆盖问题，一般表现为扫频仪或中断检测不到信号、信号弱等： 规划问题规划问题也是影响覆盖问题的主要原因，规划偏差小的话可以通过优化解决，如果规划偏差大只能考虑新增站点，耗时耗力： 施工问题施工问题，主要指在施工过程中没按照规划方案进行，如实际建设位置和规划位置有偏差、天馈基础参数设置和规划存在偏差等： 参数问题 无线环境 新增需求 覆盖优化的方案 NR覆盖类问题及优化分析覆盖类问题概述 弱覆盖问题分析指标定义：弱覆盖是指在连片站点中间出现的完全没有NR信号的区域 UE终端的灵敏度一般为-124dBm，考虑部分商用终端与测试终端灵敏度的差异，预留5dB余量，覆盖空洞定义为RSRP ＜ -119dBm的区域。 弱覆盖原因及优化方案 越区覆盖定义所谓孤岛效应就是在无线通信系统中，因为复杂的无线环境，无线信号经过山脉、建筑物、以及大气层的发射、折射，或基站安装位置过高，以及波导效应等原因,弓|起在远离本小区覆盖的区域外形成-个强场区域，如图所示： 越区覆盖影响由于这个区域超出其实际覆盖范围，往往这一-区域没有和周围小区配备邻区关系，形成孤岛，对A小区产生干扰，或在孤岛区域起呼的UE无法切换到A小区，产生掉话。 越区覆盖原因及优化措施 临时规避措施：增加越区覆盖小区和主覆盖小区的单项邻区关系 重叠覆盖问题分析强导频：RSRP ＞ -90dBm 过多：RSRP_number ≥ N，设定N=4 无足够强主导频：最强信号和第（N）个强信号强度的差值如果小于某一门限值D，即定义为该地点没有足够强主导频，RSRP(fist) －RSRP(N) ≤ D，设定D为-6dB 判断NR网络中的某点存在重叠覆盖的条件是：RSRP ＞ -90dB的小区个数大于等于4个；RSRP(fist) －RSRP(4) ≤ 6dB。当上述两个条件都满足时，即为重叠覆盖。 重叠覆盖的影响及原因分析 重叠覆盖问题优化思路 覆盖不均衡上下行覆盖不平衡:指目标覆盖区域内，上下行对称业务出现下行覆盖良好而上行覆盖受限或上行覆盖良好而下行覆盖受限的情况： 上下行不平衡一-般是指下行覆盖大于上行覆盖，在只有下行覆盖的区域，当用户因为检测到了基站信号，想要接入或者切换时，因为上行达不到覆盖要求，也就是手机以最大功率发射基站也收不到，就会造成接入失败或切换失败。另外如果上行覆盖是连续的，那么下行信号因为覆盖大于.上行，会对邻区造成干扰。 影响：上行覆盖不均衡常见表现为有信号但数据业务体验差，容易出现掉话、单通等感知类问题。 )","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"系统信息相关命令","slug":"system_info","date":"2020-08-13T12:14:14.000Z","updated":"2021-07-17T02:50:44.271Z","comments":true,"path":"2020/08/13/system_info/","link":"","permalink":"https://imqinhao.cn/2020/08/13/system_info/","excerpt":"本节内容主要是为了方便通过远程终端维护服务器时，查看服务器上当前 系统日期和时间 ／ 磁盘空间占用情况 ／ 程序执行情况 本小结学习的终端命令基本都是查询命令，通过这些命令对系统资源的使用情况有个了解","text":"本节内容主要是为了方便通过远程终端维护服务器时，查看服务器上当前 系统日期和时间 ／ 磁盘空间占用情况 ／ 程序执行情况 本小结学习的终端命令基本都是查询命令，通过这些命令对系统资源的使用情况有个了解 目标 时间和日期 date cal 磁盘和目录空间 df du 进程信息 ps top kill 01. 时间和日期 序号 命令 作用 01 date 查看系统时间 02 cal calendar 查看日历，-y 选项可以查看一年的日历 02. 磁盘信息 序号 命令 作用 01 df -h disk free 显示磁盘剩余空间 02 du -h [目录名] disk usage 显示目录下的文件大小 选项说明 参数 含义 -h 以人性化的方式显示文件大小 03. 进程信息 所谓 进程，通俗地说就是 当前正在执行的一个程序 序号 命令 作用 01 ps aux process status 查看进程的详细状况 02 top 动态显示运行中的进程并且排序 03 kill [-9] 进程代号 终止指定代号的进程，-9 表示强行终止 ps 默认只会显示当前用户通过终端启动的应用程序 ps 选项说明 选项 含义 a 显示终端上的所有进程，包括其他用户的进程 u 显示进程的详细状态 x 显示没有控制终端的进程 提示：使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃 要退出 top 可以直接输入 q","categories":[{"name":"Linux","slug":"Linux","permalink":"https://imqinhao.cn/categories/Linux/"}],"tags":[]},{"title":"文件和目录常用命令","slug":"Files_and_directories","date":"2020-08-13T12:13:14.000Z","updated":"2021-07-17T02:39:42.429Z","comments":true,"path":"2020/08/13/Files_and_directories/","link":"","permalink":"https://imqinhao.cn/2020/08/13/Files_and_directories/","excerpt":"查看目录内容 切换目录 创建和删除操作 拷贝和移动文件 查看文件内容","text":"查看目录内容 切换目录 创建和删除操作 拷贝和移动文件 查看文件内容 目标 查看目录内容 ls 切换目录 cd 创建和删除操作 touch rm mkdir 拷贝和移动文件 cp mv 查看文件内容 cat more grep 其他 echo 重定向 &gt; 和 &gt;&gt; 管道 | 01. 查看目录内容1.1 终端实用技巧1&gt; 自动补全 在敲出 文件／目录／命令 的前几个字母之后，按下 tab 键 如果输入的没有歧义，系统会自动补全 如果还存在其他 文件／目录／命令，再按一下 tab 键，系统会提示可能存在的命令 2&gt; 曾经使用过的命令 按 上／下 光标键可以在曾经使用过的命令之间来回切换 如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c 1.2 ls 命令说明 ls 是英文单词 list 的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于 DOS 下的 dir 命令 Linux 下文件和目录的特点 Linux 文件 或者 目录 名称最长可以有 256 个字符 以 . 开头的文件为隐藏文件，需要用 -a 参数才能显示 . 代表当前目录 .. 代表上一级目录 1.3 ls 常用选项 参数 含义 -a 显示指定目录下所有子目录与文件，包括隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 计算机中文件大小的表示方式（科普） 单位 英文 含义 字节 B（Byte） 在计算机中作为一个数字单元，一般为 8 位二进制数 千 K（Kibibyte） 1 KB = 1024 B，千字节 （1024 = 2 ** 10） 兆 M（Mebibyte） 1 MB = 1024 KB，百万字节 千兆 G（Gigabyte） 1 GB = 1024 MB，十亿字节，千兆字节 太 T（Terabyte） 1 TB = 1024 GB，万亿字节，太字节 拍 P（Petabyte） 1 PB = 1024 TB，千万亿字节，拍字节 艾 E（Exabyte） 1 EB = 1024 PB，百亿亿字节，艾字节 泽 Z（Zettabyte） 1 ZB = 1024 EB，十万亿亿字节，泽字节 尧 Y（Yottabyte） 1 YB = 1024 ZB，一亿亿亿字节，尧字节 1.4 ls 通配符的使用 通配符 含义 * 代表任意个数个字符 ? 代表任意一个字符，至少 1 个 [] 表示可以匹配字符组中的任一一个 [abc] 匹配 a、b、c 中的任意一个 [a-f] 匹配从 a 到 f 范围内的的任意一个字符 02. 切换目录2.1 cd cd 是英文单词 change directory 的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一 注意：Linux 所有的 目录 和 文件名 都是大小写敏感的 命令 含义 cd 切换到当前用户的主目录(/home/用户目录) cd ~ 切换到当前用户的主目录(/home/用户目录) cd . 保持在当前目录不变 cd .. 切换到上级目录 cd - 可以在最近两次工作目录之间来回切换 2.2 相对路径和绝对路径 相对路径 在输入路径时，最前面不是 / 或者 ~，表示相对 当前目录 所在的目录位置 绝对路径 在输入路径时，最前面是 / 或者 ~，表示从 根目录/家目录 开始的具体目录位置 03. 创建和删除操作3.1 touch 创建文件或修改文件时间 如果文件 不存在，可以创建一个空白文件 如果文件 已经存在，可以修改文件的末次修改日期 3.2 mkdir 创建一个新的目录 选项 含义 -p 可以递归创建目录 新建目录的名称 不能与当前目录中 已有的目录或文件 同名 3.3 rm 删除文件或目录 使用 rm 命令要小心，因为文件删除后不能恢复 选项 含义 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹 时必须加此参数 04. 拷贝和移动文件 序号 命令 对应英文 作用 01 tree [目录名] tree 以树状图列出文件目录结构 02 cp 源文件 目标文件 copy 复制文件或者目录 03 mv 源文件 目标文件 move 移动文件或者目录／文件或者目录重命名 4.1 tree tree 命令可以以树状图列出文件目录结构 选项 含义 -d 只显示目录 4.2 cp cp 命令的功能是将给出的 文件 或 目录 复制到另一个 文件 或 目录 中，相当于 DOS 下的 copy 命令 选项 含义 -i 覆盖文件前提示 -r 若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 4.3 mv mv 命令可以用来 移动 文件 或 目录，也可以给 文件或目录重命名 选项 含义 -i 覆盖文件前提示 05. 查看文件内容 序号 命令 对应英文 作用 01 cat 文件名 concatenate 查看文件内容、创建文件、文件合并、追加文件内容等功能 02 more 文件名 more 分屏显示文件内容 03 grep 搜索文本 文件名 grep 搜索文本文件内容 5.1 cat cat 命令可以用来 查看文件内容、创建文件、文件合并、追加文件内容 等功能 cat 会一次显示所有的内容，适合 查看内容较少 的文本文件 选项 含义 -b 对非空输出行编号 -n 对输出的所有行编号 Linux 中还有一个 nl 的命令和 cat -b 的效果等价 5.2 more more 命令可以用于分屏显示文件内容，每次只显示一页内容 适合于 查看内容较多的文本文件 使用 more 的操作键： 操作键 功能 空格键 显示手册页的下一屏 Enter 键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word 字符串 5.3 grep Linux 系统中 grep 命令是一种强大的文本搜索工具 grep允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式，在就业班会详细讲解 选项 含义 -n 显示匹配行及行号 -v 显示不包含匹配文本的所有行（相当于求反） -i 忽略大小写 常用的两种模式查找 参数 含义 ^a 行首，搜寻以 a 开头的行 ke$ 行尾，搜寻以 ke 结束的行 06. 其他6.1 echo 文字内容 echo 会在终端中显示参数指定的文字，通常会和 重定向 联合使用 6.2 重定向 &gt; 和 &gt;&gt; Linux 允许将命令执行结果 重定向到一个 文件 将本应显示在终端上的内容 输出／追加 到指定文件中 其中 &gt; 表示输出，会覆盖文件原有的内容 &gt;&gt; 表示追加，会将内容追加到已有文件的末尾 6.3 管道 | Linux 允许将 一个命令的输出 可以通过管道 做为 另一个命令的输入 可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 | 的左右分为两端，左端塞东西（写），右端取东西（读） 常用的管道命令有： more：分屏显示内容 grep：在命令执行结果的基础上查询指定的文本","categories":[{"name":"Linux","slug":"Linux","permalink":"https://imqinhao.cn/categories/Linux/"}],"tags":[]},{"title":"计算机网络学习1","slug":"computer_Internet_1","date":"2020-07-17T10:25:00.000Z","updated":"2021-07-17T02:38:21.983Z","comments":true,"path":"2020/07/17/computer_Internet_1/","link":"","permalink":"https://imqinhao.cn/2020/07/17/computer_Internet_1/","excerpt":"学习笔记，包含以下内容： 网络、互联网（互连网）和因特网 三种交换方式 计算机网络的性能指标","text":"学习笔记，包含以下内容： 网络、互联网（互连网）和因特网 三种交换方式 计算机网络的性能指标 网络、互联网（互联网）和因特网网络（Network）由若干结点（Node）和连接这些节点的链路（Link）组成。 多个网络还可以通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网（或互连网）。因此，互连网是“网络中的网络（Network of Network）” 因特网（Internet）是世界上最大的互联网络（用户数以亿计，互连的网络数以百万计） Internet与internet的区别 internet（互联网或互连网）是一个通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。 Internet（因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET。 名词解释ISP：因特网服务提供者 因特网的组成① 边缘部分：由所有连接在因特网上的主机组成。 ② 核心部分：由大量的网络和连接这些网络的路由器组成。 电路交换、分组交换和报文交换电路交换 电话交换机接通电话线的方式称为电路交换。 从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源。 电路交换的三个步骤： 建立连接（分配通信资源） 通话（一直占用通信资源） 释放连接（归还通信资源） 当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。 分组交换 三种交换方式的对比 计算机网络的性能指标速率 计算题：有一个待发送的数据块，大小为100MB，网卡的发送速率为100Mbps，则网卡发送完该数据块需要多长时间？ $$\\frac{100MB}{100Mb/s} = \\frac{MB}{Mb/s} = \\frac{2^{20}·8 b }{10^{6}b/s} ≈ 8.4s$$ 带宽 一条通信线路的“频带宽度”越宽，其所传输数据的“最高数据率”也越高。 吞吐量 吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。 吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。 吞吐量受网络的带宽或额定速率的限制。 时延 发送时延 ： $$ \\frac{分组长度(b)}{发送速率(b/s)} $$ ，与网卡的发送速率、信道带宽、接口速率都有关。 传播时延： $$ \\frac{信道长度(m)}{电磁波传播速率(m/s)} $$ 处理时延： 路由器接收数据后，对数据进行存储转发所消耗的时间。 计算题： 数据块长度为100MB，信道带宽为1 Mb/s，传送距离为1000 km，计算发送时延和传播时延。 $$ 发送时延 = \\frac{分组长度(b)}{发送速率(b/s)} = \\frac{100 × 2^{20} × 8(b)}{10^6(b/s)} = 838.8608s $$ $$ 传播时延 = \\frac{信道长度(m)}{电磁波传播速率(m/s)} = \\frac{1000 × 10^3(m)}{2 × 10^8(m/s)} = 0.005s $$ 时延带宽积$$ 时延带宽积 = 传播时延 × 带宽 $$ 往返时间 在很多情况下，因特网上的信息不仅仅单方向传输，而是双向交互。因此，往返时间RTT（Round-Trip Time）也是一个重要指标。 利用率 信道利用率 ： 用来表示某信道有百分之几的时间是被利用的（有数据通过）。 网络利用率 ： 全网络的信道利用率的加权平均。 根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加。因此，信道的利用率并非越高越好。 如果令$$ D_0 $$ 表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用下面的简单公式来表示D、$$ D_0 $$ 和利用率U之间的关系： $$ D = \\frac{D_0}{1 - U} $$ 当网络的利用率达到 50% 的时候，时延就要加倍。 当网络的利用率超过 50% 的时候，时延急剧增大。 当网络的利用率接近 100% 的时候，时延就趋近于无穷大。 因此，一些拥有较大主干网的ISP通常会控制他们的信道利用率不超过 50% 。如果超过了，就要准备扩容，增大线路的带宽。 也不能使信道利用率太低，这会使宝贵的通信资源被白白浪费。应该使用一些机制，可以根据情况动态调整输入到网络中的通信量，使网络利用率保持在一个合理的范围内。 丢包率 丢包率即分组丢失率，是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率。 丢包率具体可分为接口丢失率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。 丢包率是网络运维人员非常关心的一个网络性能指标，但对于普通用户来说往往并不关心这个指标，因为他们通常意识不到网络丢包。 分组丢失主要有两种情况： 分组在传输过程中出现误码，被结点丢弃 分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时就可能造成网络拥塞。 丢包率反映了网络的拥塞情况： 无拥塞时路径丢包率为0 轻度拥塞时路径丢包率为1% ~ 4% 严重拥塞时路径丢包率为5% ~ 15%","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://imqinhao.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"Python基础之变量进阶","slug":"Python_variable","date":"2020-07-07T10:30:11.000Z","updated":"2021-07-17T02:48:31.379Z","comments":true,"path":"2020/07/07/Python_variable/","link":"","permalink":"https://imqinhao.cn/2020/07/07/Python_variable/","excerpt":"变量的引用 可变和不可变类型 局部变量和全局变量","text":"变量的引用 可变和不可变类型 局部变量和全局变量 01. 变量的引用 变量 和 数据 都是保存在 内存 中的 在 Python 中 函数 的 参数传递 以及 返回值 都是靠 引用 传递的 1.1 引用的概念在 Python 中 变量 和 数据 是分开存储的 数据 保存在内存中的一个位置 变量 中保存着数据在内存中的地址 变量 中 记录数据的地址，就叫做 引用 使用 id() 函数可以查看变量中保存数据所在的 内存地址 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 修改了数据的引用 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 1.2 变量引用 的示例在 Python 中，变量的名字类似于 便签纸 贴在 数据 上 定义一个整数变量 a，并且赋值为 1 代码 图示 a = 1 将变量 a 赋值为 2 代码 图示 a = 2 ) 定义一个整数变量 b，并且将变量 a 的值赋值给 b 代码 图示 b = a 变量 b 是第 2 个贴在数字 2 上的标签 1.3 函数的参数和返回值的传递在 Python 中，函数的 实参/返回值 都是是靠 引用 来传递来的 12345678910111213141516171819def test(num): print(\"-\" * 50) print(\"%d 在函数内的内存地址是 %x\" % (num, id(num))) result = 100 print(\"返回值 %d 在内存中的地址是 %x\" % (result, id(result))) print(\"-\" * 50) return resulta = 10print(\"调用函数前 内存地址是 %x\" % id(a))r = test(a)print(\"调用函数后 实参内存地址是 %x\" % id(a))print(\"调用函数后 返回值内存地址是 %x\" % id(r)) 02. 可变和不可变类型 不可变类型，内存中的数据不允许被修改： 数字类型 int, bool, float, complex, long(2.x) 字符串 str 元组 tuple 可变类型，内存中的数据可以被修改： 列表 list 字典 dict 1234a = 1a = \"hello\"a = [1, 2, 3]a = [3, 2, 1] 1234567891011121314151617181920demo_list = [1, 2, 3]print(\"定义列表后的内存地址 %d\" % id(demo_list))demo_list.append(999)demo_list.pop(0)demo_list.remove(2)demo_list[0] = 10print(\"修改数据后的内存地址 %d\" % id(demo_list))demo_dict = &#123;\"name\": \"小明\"&#125;print(\"定义字典后的内存地址 %d\" % id(demo_dict))demo_dict[\"age\"] = 18demo_dict.pop(\"name\")demo_dict[\"name\"] = \"老王\"print(\"修改数据后的内存地址 %d\" % id(demo_dict)) 注意：字典的 key 只能使用不可变类型的数据 注意 可变类型的数据变化，是通过 方法 来实现的 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 哈希 (hash) Python 中内置有一个名字叫做 hash(o) 的函数 接收一个 不可变类型 的数据作为 参数 返回 结果是一个 整数 哈希 是一种 算法，其作用就是提取数据的 特征码（指纹） 相同的内容 得到 相同的结果 不同的内容 得到 不同的结果 在 Python 中，设置字典的 键值对 时，会首先对 key 进行 hash 已决定如何在内存中保存字典的数据，以方便 后续 对字典的操作：增、删、改、查 键值对的 key 必须是不可变类型数据 键值对的 value 可以是任意类型的数据 03. 局部变量和全局变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 3.1 局部变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 函数执行结束后，函数内部的局部变量，会被系统回收 不同的函数，可以定义相同的名字的局部变量，但是 彼此之间 不会产生影响 局部变量的作用 在函数内部使用，临时 保存 函数内部需要使用的数据 123456789101112131415161718192021def demo1(): num = 10 print(num) num = 20 print(\"修改后 %d\" % num)def demo2(): num = 100 print(num)demo1()demo2()print(\"over\") 局部变量的生命周期 所谓 生命周期 就是变量从 被创建 到 被系统回收 的过程 局部变量 在 函数执行时 才会被创建 函数执行结束后 局部变量 被系统回收 局部变量在生命周期 内，可以用来存储 函数内部临时使用到的数据 3.2 全局变量 全局变量 是在 函数外部定义 的变量，所有函数内部都可以使用这个变量 1234567891011121314151617# 定义一个全局变量num = 10def demo1(): print(num)def demo2(): print(num)demo1()demo2()print(\"over\") 注意：函数执行时，需要处理变量时 会： 首先 查找 函数内部 是否存在 指定名称 的局部变量，如果有，直接使用 如果没有，查找 函数外部 是否存在 指定名称 的全局变量，如果有，直接使用 如果还没有，程序报错！ 1) 函数不能直接修改 全局变量的引用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 在函数内部，可以 通过全局变量的引用获取对应的数据 但是，不允许直接修改全局变量的引用 —— 使用赋值语句修改全局变量的值 123456789101112131415161718192021num = 10def demo1(): print(\"demo1\" + \"-\" * 50) # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num)def demo2(): print(\"demo2\" + \"-\" * 50) print(num)demo1()demo2()print(\"over\") 注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值 2) 在函数内部修改全局变量的值 如果在函数中需要修改全局变量，需要使用 global 进行声明 1234567891011121314151617181920212223num = 10def demo1(): print(\"demo1\" + \"-\" * 50) # global 关键字，告诉 Python 解释器 num 是一个全局变量 global num # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num)def demo2(): print(\"demo2\" + \"-\" * 50) print(num)demo1()demo2()print(\"over\") 3) 全局变量定义的位置 为了保证所有的函数都能够正确使用到全局变量，应该 将全局变量定义在其他函数的上方 1234567891011a = 10def demo(): print(\"%d\" % a) print(\"%d\" % b) print(\"%d\" % c)b = 20demo()c = 30 注意 由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！ 代码结构示意图如下 4) 全局变量命名的建议 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如： 全局变量名前应该增加 g_ 或者 gl_ 的前缀 提示：具体的要求格式，各公司要求可能会有些差异","categories":[{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"}],"tags":[]},{"title":"综合应用 —— 名片管理系统","slug":"Python_cards_manage","date":"2020-07-07T09:20:14.000Z","updated":"2021-07-17T02:48:19.394Z","comments":true,"path":"2020/07/07/Python_cards_manage/","link":"","permalink":"https://imqinhao.cn/2020/07/07/Python_cards_manage/","excerpt":"综合应用已经学习过的知识点： 变量 流程控制 函数 模块 开发 名片管理系统","text":"综合应用已经学习过的知识点： 变量 流程控制 函数 模块 开发 名片管理系统 系统需求 程序启动，显示名片管理系统欢迎界面，并显示功能菜单 123456789**************************************************欢迎使用【名片管理系统】V1.01. 新建名片2. 显示全部3. 查询名片0. 退出系统************************************************** 用户用数字选择不同的功能 根据功能选择，执行不同的功能 用户名片需要记录用户的 姓名、电话、QQ、邮件 如果查询到指定的名片，用户可以选择 修改 或者 删除 名片 步骤 框架搭建 新增名片 显示所有名片 查询名片 查询成功后修改、删除名片 让 Python 程序能够直接运行 01. 框架搭建目标 搭建名片管理系统 框架结构 准备文件，确定文件名，保证能够 在需要的位置 编写代码 编写 主运行循环，实现基本的 用户输入和判断 1.1 文件准备 新建 cards_main.py 保存 主程序功能代码 程序的入口 每一次启动名片管理系统都通过 main 这个文件启动 新建 cards_tools.py 保存 所有名片功能函数 将对名片的 新增、查询、修改、删除 等功能封装在不同的函数中 1.2 编写主运行循环 在 cards_main 中添加一个 无限循环 123456789101112131415161718while True: # TODO(小明) 显示系统菜单 action = input(\"请选择操作功能：\") print(\"您选择的操作是：%s\" % action) # 根据用户输入决定后续的操作 if action in [\"1\", \"2\", \"3\"]: pass elif action == \"0\": print(\"欢迎再次使用【名片管理系统】\") break else: print(\"输入错误，请重新输入\") 字符串判断1if action in [\"1\", \"2\", \"3\"]: 1if action == \"1\" or action == \"2\" or action == \"3\": 使用 in 针对 列表 判断，避免使用 or 拼接复杂的逻辑条件 没有使用 int 转换用户输入，可以避免 一旦用户输入的不是数字，导致程序运行出错 pass pass 就是一个空语句，不做任何事情，一般用做占位语句 是为了保持程序结构的完整性 无限循环 在开发软件时，如果 不希望程序执行后 立即退出 可以在程序中增加一个 无限循环 由用户来决定 退出程序的时机 TODO 注释 在 # 后跟上 TODO，用于标记需要去做的工作 1# TODO(作者/邮件) 显示系统菜单 1.3 在 cards_tools 中增加四个新函数12345678910111213141516171819202122232425262728def show_menu(): \"\"\"显示菜单 \"\"\" passdef new_card(): \"\"\"新建名片 \"\"\" print(\"-\" * 50) print(\"功能：新建名片\")def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\")def search_card(): \"\"\"搜索名片 \"\"\" print(\"-\" * 50) print(\"功能：搜索名片\") 1.4 导入模块 在 cards_main.py 中使用 import 导入 cards_tools 模块 1import cards_tools 修改 while 循环的代码如下： 12345678910111213141516171819202122232425262728import cards_toolswhile True: cards_tools.show_menu() action = input(\"请选择操作功能：\") print(\"您选择的操作是：%s\" % action) # 根据用户输入决定后续的操作 if action in [\"1\", \"2\", \"3\"]: if action == \"1\": cards_tools.new_card() elif action == \"2\": cards_tools.show_all() elif action == \"3\": cards_tools.search_card() elif action == \"0\": print(\"欢迎再次使用【名片管理系统】\") break else: print(\"输入错误，请重新输入：\") 至此：cards_main 中的所有代码全部开发完毕！ 1.5 完成 show_menu 函数12345678910111213def show_menu(): \"\"\"显示菜单 \"\"\" print(\"*\" * 50) print(\"欢迎使用【菜单管理系统】V1.0\") print(\"\") print(\"1. 新建名片\") print(\"2. 显示全部\") print(\"3. 查询名片\") print(\"\") print(\"0. 退出系统\") print(\"*\" * 50) 02. 保存名片数据的结构程序就是用来处理数据的，而变量就是用来存储数据的 使用 字典 记录 每一张名片 的详细信息 使用 列表 统一记录所有的 名片字典 定义名片列表变量 在 cards_tools 文件的顶部增加一个 列表变量 12# 所有名片记录的列表card_list = [] 注意 所有名片相关操作，都需要使用这个列表，所以应该 定义在程序的顶部 程序刚运行时，没有数据，所以是 空列表 03. 新增名片3.1 功能分析 提示用户依次输入名片信息 将名片信息保存到一个字典 将字典添加到名片列表 提示名片添加完成 3.2 实现 new_card 方法 根据步骤实现代码 1234567891011121314151617181920212223242526def new_card(): \"\"\"新建名片 \"\"\" print(\"-\" * 50) print(\"功能：新建名片\") # 1. 提示用户输入名片信息 name = input(\"请输入姓名：\") phone = input(\"请输入电话：\") qq = input(\"请输入 QQ 号码：\") email = input(\"请输入邮箱：\") # 2. 将用户信息保存到一个字典 card_dict = &#123;\"name\": name, \"phone\": phone, \"qq\": qq, \"email\": email&#125; # 3. 将用户字典添加到名片列表 card_list.append(card_dict) print(card_list) # 4. 提示添加成功信息 print(\"成功添加 %s 的名片\" % card_dict[\"name\"]) 技巧：在 PyCharm 中，可以使用 SHIFT + F6 统一修改变量名 04. 显示所有名片4.1 功能分析 循环遍历名片列表，顺序显示每一个字典的信息 4.2 基础代码实现12345678910def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") for card_dict in card_list: print(card_dict) 显示效果不好！ 4.3 增加标题和使用 \\t 显示123456789101112131415161718192021def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") # 打印表头 for name in [\"姓名\", \"电话\", \"QQ\", \"邮箱\"]: print(name, end=\"\\t\\t\") print(\"\") # 打印分隔线 print(\"=\" * 50) for card_dict in card_list: print(\"%s\\t\\t%s\\t\\t%s\\t\\t%s\" % (card_dict[\"name\"], card_dict[\"phone\"], card_dict[\"qq\"], card_dict[\"email\"])) 4.4 增加没有名片记录判断1234567891011def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") # 1. 判断是否有名片记录 if len(card_list) == 0: print(\"提示：没有任何名片记录\") return 注意 在函数中使用 return 表示返回 如果在 return 后没有跟任何内容，只是表示该函数执行到此就不再执行后续的代码 05. 查询名片5.1 功能分析 提示用户要搜索的姓名 根据用户输入的姓名遍历列表 搜索到指定的名片后，再执行后续的操作 5.2 代码实现 查询功能实现 12345678910111213141516171819202122232425262728293031def search_card(): \"\"\"搜索名片 \"\"\" print(\"-\" * 50) print(\"功能：搜索名片\") # 1. 提示要搜索的姓名 find_name = input(\"请输入要搜索的姓名：\") # 2. 遍历字典 for card_dict in card_list: if card_dict[\"name\"] == find_name: print(\"姓名\\t\\t\\t电话\\t\\t\\tQQ\\t\\t\\t邮箱\") print(\"-\" * 40) print(\"%s\\t\\t\\t%s\\t\\t\\t%s\\t\\t\\t%s\" % ( card_dict[\"name\"], card_dict[\"phone\"], card_dict[\"qq\"], card_dict[\"email\"])) print(\"-\" * 40) # TODO(小明) 针对找到的字典进行后续操作：修改/删除 break else: print(\"没有找到 %s\" % find_name) 增加名片操作函数：修改/删除/返回主菜单 123456789101112131415def deal_card(find_dict): \"\"\"操作搜索到的名片字典 :param find_dict:找到的名片字典 \"\"\" print(find_dict) action_str = input(\"请选择要执行的操作 \" \"[1] 修改 [2] 删除 [0] 返回上级菜单\") if action == \"1\": print(\"修改\") elif action == \"2\": print(\"删除\") 06. 修改和删除6.1 查询成功后删除名片 由于找到的字典记录已经在列表中保存 要删除名片记录，只需要把列表中对应的字典删除即可 1234elif action == \"2\": card_list.remove(find_dict) print(\"删除成功\") 6.2 修改名片 由于找到的字典记录已经在列表中保存 要修改名片记录，只需要把列表中对应的字典中每一个键值对的数据修改即可 12345678if action == \"1\": find_dict[\"name\"] = input(\"请输入姓名：\") find_dict[\"phone\"] = input(\"请输入电话：\") find_dict[\"qq\"] = input(\"请输入QQ：\") find_dict[\"email\"] = input(\"请输入邮件：\") print(\"%s 的名片修改成功\" % find_dict[\"name\"]) 修改名片细化 如果用户在使用时，某些名片内容并不想修改，应该如何做呢？—— 既然系统提供的 input 函数不能满足需求，那么就新定义一个函数 input_card_info 对系统的 input 函数进行扩展 12345678910111213141516171819def input_card_info(dict_value, tip_message): \"\"\"输入名片信息 :param dict_value: 字典原有值 :param tip_message: 输入提示信息 :return: 如果输入，返回输入内容，否则返回字典原有值 \"\"\" # 1. 提示用户输入内容 result_str = input(tip_message) # 2. 针对用户的输入进行判断，如果用户输入了内容，直接返回结果 if len(result_str) &gt; 0: return result_str # 3. 如果用户没有输入内容，返回 `字典中原有的值` else: return dict_value 07. LINUX 上的 Shebang 符号(#!) #!这个符号叫做 Shebang 或者 Sha-bang Shebang 通常在 Unix 系统脚本的中 第一行开头 使用 指明 执行这个脚本文件 的 解释程序 使用 Shebang 的步骤 使用 which 查询 python3 解释器所在路径 1$ which python3 修改要运行的 主 python 文件，在第一行增加以下内容 1#! /usr/bin/python3 修改 主 python 文件 的文件权限，增加执行权限 1$ chmod +x cards_main.py 在需要时执行程序即可 1./cards_main.py 源代码cards_tools代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132# 记录所有的名片字典card_list = []def show_menu(): '''显示菜单''' print(\"*\" * 50) print(\"欢迎使用【名片管理系统】 V1.0\") print() print(\"1. 新建名片\") print(\"2. 显示全部\") print(\"3. 查询名片\") print() print(\"0. 退出系统\") print(\"*\" * 50)def new_card(): \"\"\"新增名片\"\"\" # 1.提示用户输入名片的详细信息 name = input(\"请输入姓名：\") phone = input(\"请输入手机号：\") qq = input(\"请输入QQ号：\") email = input(\"请输入邮箱：\") # 使用用户输入的信息建立一个名片字典 card_dict = &#123;\"name\": name, \"phone\": phone, \"qq\": qq, \"email\": email&#125; # 将名片字典添加到列表中 card_list.append(card_dict) # 提示用户新增成功 print(\"添加 &#123;&#125; 的名片成功！\".format(name))def show_all(): \"\"\"显示所有名片\"\"\" # 显示功能 print(\"显示所有名片\") # 判断是否存在名片记录 if len(card_list) == 0: print(\"当前没有任何的名片记录，请使用新增功能添加名片！\") return else: # 打印表头 for name in [\"姓名\", \"电话\", \"QQ\", \"邮箱\"]: print(\"&#123;:15&#125;\".format(name), end=\" \") print() # 打印分隔线 print(\"-\" * 50) for card_dict in card_list: print(\"&#123;:15&#125;&#123;:15&#125;&#123;:15&#125;&#123;:15&#125;\".format(card_dict[\"name\"], card_dict[\"phone\"], card_dict[\"qq\"], card_dict[\"email\"]))def search_card(): \"\"\"搜索名片\"\"\" # 显示功能 print(\"搜索名片\") # 用户输入要搜索的姓名 find_name = input(\"请输入要搜索的姓名：\") # 遍历名片列表 for user_info in card_list: if user_info[\"name\"] == find_name: # 打印表头 for name in [\"姓名\", \"电话\", \"QQ\", \"邮箱\"]: print(\"&#123;:20&#125;\".format(name), end=\" \") print() # 打印分隔线 print(\"-\" * 50) # 打印名片信息 print(\"&#123;:20&#125;&#123;:20&#125;&#123;:20&#125;&#123;:20&#125;\".format(user_info[\"name\"], user_info[\"phone\"], user_info[\"qq\"], user_info[\"email\"])) # 针对找到的名片记录执行修改和删除的操作 deal_card(user_info) break else: print(\"抱歉，没有找到&#123;&#125;的名片\".format(find_name))def deal_card(find_dict): \"\"\"处理查找到的名片 :param find_dict: 查找到的名片 \"\"\" action_str = input(\"请选择要执行的操作： \" \"[1] 修改 / [2] 删除 / [0] 返回上级菜单\") if action_str == \"1\": find_dict[\"name\"] = input_card_info(find_dict[\"name\"], \"姓名[回车不修改]：\") find_dict[\"phone\"] = input_card_info(find_dict[\"phone\"], \"电话[回车不修改]：\") find_dict[\"qq\"] = input_card_info(find_dict[\"qq\"], \"QQ[回车不修改]：\") find_dict[\"email\"] = input_card_info(find_dict[\"email\"], \"邮箱[回车不修改]：\") print(\"修改&#123;&#125;的名片成功！\".format(find_dict[\"name\"])) elif action_str == \"2\": card_list.remove(find_dict) print(\"删除&#123;&#125;的名片成功！\".format(find_dict[\"name\"]))def input_card_info(dict_value, tip_message): \"\"\"输入名片信息 :param dict_value: 字典原有数值 :param tip_message: 用户输入提示信息 :return: 如果用户输入了内容，就返回内容，如果没有输入内容，则用字典中原有的值 \"\"\" # 提示用户输入内容 result_str = input(tip_message) # 针对用户的输入进行判断，如果用户输入了内容，直接返回结果 if len(result_str) &gt; 0: return result_str # 如果用户没有输入内容，返回“字典中原有的值” else: return dict_value cards_main代码1234567891011121314151617181920212223242526272829303132333435363738394041import cards_tools# 由用户决定退出程序的时机while True: # 显示系统功能 cards_tools.show_menu() # 没有使用int转换用户输入，可以避免一旦用户输入的不是数字，导致程序运行出错 action_str = input(\"请选择您希望执行的操作：\") print(\"您选择的操作是【&#123;&#125;】\".format(action_str)) # 1,2,3对名片进行操作 # 使用in针对列表判断，避免使用or拼接复杂的逻辑条件 if action_str in [\"1\",\"2\",\"3\"]: # 新增名片 if action_str == \"1\": print(\"-\" * 50) cards_tools.new_card() # 显示全部 if action_str == \"2\": print(\"-\" * 50) cards_tools.show_all() # 查询名片 if action_str == \"3\": print(\"-\" * 50) cards_tools.search_card() # 如果在开发程序的时候，不希望立刻编写分支内部的代码 # 可以使用pass关键字，表示一个占位符，能够保证程序的代码结构正确 # 程序运行时，pass关键字不会执行任何的操作 # pass # 0表示退出系统 elif action_str == \"0\": print(\"欢迎再次使用【名片管理系统】\") break # 其他内容输入错误，需要提示用户 else: print(\"您输入的不正确，请重新选择\") 效果预览","categories":[{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"}],"tags":[]},{"title":"MySQL压缩包版安装方法","slug":"mysql-install","date":"2020-06-13T04:00:00.000Z","updated":"2021-07-17T02:45:48.206Z","comments":true,"path":"2020/06/13/mysql-install/","link":"","permalink":"https://imqinhao.cn/2020/06/13/mysql-install/","excerpt":"MySQL虽然提供了msi的安装包方式，但是最新版的会默认安装在C盘，而压缩版的我们只需要将文件夹放在自己想放的位置，配置即可使用。接下来我们介绍一下MySQL压缩包安装方式。","text":"MySQL虽然提供了msi的安装包方式，但是最新版的会默认安装在C盘，而压缩版的我们只需要将文件夹放在自己想放的位置，配置即可使用。接下来我们介绍一下MySQL压缩包安装方式。 下载压缩包首先我们到MySQL官网下载MySQL的压缩包，MySQL提供了压缩包和安装包两种方式，两种方式的区别是压缩包解压之后配置一下就可以使用，而.msi的安装包安装较为繁琐，故我们介绍压缩包的方式。 解压压缩包解压之后我们会得到下图所示的文件及文件夹 MySQL安装以管理员身份运行cmd 进入到解压根目录/bin目录下 创建配置文件my.ini 1234# 设置mysql的安装目录 basedir&#x3D;D:\\\\mysql-8.0.20-winx64# 设置mysql数据库的数据的存放目录 datadir&#x3D;D:\\\\mysql-8.0.20-winx64\\\\data basedir和datadir设置时需要注意的是如果使用“\\”请使用双“\\”来分割目录，如果不使用这种可以使用单“/” 将my.ini剪切到bin目录下 新建data文件夹 初始化MySQL数据目录执行命令mysqld --initialize 运行完之后就会发现在我们新建的data文件夹生成了很多文件 报错如果出现了下面的提示，说明没有安装VC++2015运行库，MySQL运行需要这个运行库，可以去微软官网下载。没有出现报错则跳过该步骤。 进入微软官网搜索并下载 获取初始化数据库随机密码执行完上一步之后，在data目录下生的文件有一个.err文件，这里面有初始化的密码。我们编辑打开此文件，找到密码。该文件命名规则是【电脑用户名.err】如下图 找到我们的随机密码 安装MySQL服务执行命令mysqld --install mysql 启动MySQL服务执行命令net start mysql 配置环境变量此电脑右键—&gt;属性—&gt;高级系统设置—&gt;环境变量 找到PATH变量，推荐配置在用户变量。 将MySQL文件夹的bin目录的路径复制，点击右侧新建，添加到环境变。 配置完成后记得点击确定，有两个地方需要点击确定。 MySQL连接登录连接MySQL输入mysql -u root -p，输入我们刚刚获取到的随机密码。 出现下面的提示又电脑的路径变成了mysql> 表示我们连接数据库成功。 修改密码输入ALTER USER 'root'@'localhost' IDENTIFIED BY '密码'; 修改密码成功会提示Query OK 退出重新登录12exitmysql -u root -p","categories":[{"name":"数据库","slug":"数据库","permalink":"https://imqinhao.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"无法访问蓝奏云的解决方法","slug":"lanzous","date":"2020-06-11T12:20:11.000Z","updated":"2021-07-17T02:42:43.618Z","comments":true,"path":"2020/06/11/lanzous/","link":"","permalink":"https://imqinhao.cn/2020/06/11/lanzous/","excerpt":"介绍一下打开蓝奏云链接时提示我们网页不存在的解决方法","text":"介绍一下打开蓝奏云链接时提示我们网页不存在的解决方法 方法一将蓝奏云链接的www改成pan，然后删掉lanzous后面的s。 方法二更改DNS为114.114.114.114 和 114.114.115.115","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://imqinhao.cn/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[]},{"title":"政府工作报告词云示例","slug":"Python-5","date":"2020-06-01T05:14:20.000Z","updated":"2021-07-17T02:49:10.236Z","comments":true,"path":"2020/06/01/Python-5/","link":"","permalink":"https://imqinhao.cn/2020/06/01/Python-5/","excerpt":"政府工作报告词云小练习 使用库： jieba库 wordcloud库","text":"政府工作报告词云小练习 使用库： jieba库 wordcloud库 源代码123456789101112import jiebaimport wordcloudfrom imageio import imreadmask = imread(\"chinamap.png\")f = open(\"新时代中国特色社会主义.txt\",\"r\", encoding=\"utf-8\")t = f.read()f.close()ls = jieba.lcut(t)txt = \" \".join(ls)w = wordcloud.WordCloud(width=1000,height=700,background_color=\"white\",font_path=\"msyh.ttc\",mask=mask)w.generate(txt)w.to_file(\"wordclouddemo3.png\") 效果演示","categories":[{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"}],"tags":[]},{"title":"华为应用开发学习笔记","slug":"huawei-exam-application","date":"2020-05-29T12:13:14.000Z","updated":"2021-07-17T02:41:11.130Z","comments":true,"path":"2020/05/29/huawei-exam-application/","link":"","permalink":"https://imqinhao.cn/2020/05/29/huawei-exam-application/","excerpt":"华为应用开发学习笔记","text":"华为应用开发学习笔记 解压命令.tar 用 tar -xvf 解压 .gz 用 gzip -d 或者 gunzip 解压 .tar.gz 和 .tgz 用 tar -xzf 解压 .bz2 用 bzip2 -d 或者用 bunzip2 解压 .tar.bz2 用 tar -xjf 解压 .Z 用 uncompress 解压 .tar.Z 用 tar -xZf 解压 .tar.xz 用 jxvf 解压 .rar 用 unrar e 解压 .zip 用 unzip 解压 使用rpmbuild命令将源码打包成rpm包。 公共镜像：常见的标准操作系统镜像。 私有镜像：个人镜像，仅用户自己可见。 共享镜像：由其他用户共享的私有镜像。 市场镜像：提供预装操作系统、应用环境和各类软件的优质第三方镜像。 Linux安装软件方式源码安装 可以自定义安装目录和一些配置文件 需要事先调整编译参数 yum安装软件 全自动安装，自动安装依赖 缺乏自主性，软件的功能和存放的位置均已设置好 RPM安装 自主制作的RPM包能够实现全自动安装，且可自动以安装路径等配置 需提前识别依赖并手动安装 数据库配置文件props.ora ：Oracle props.pg ： PostgreSQL Props.fb ： FireBirdSQL Props.gb ： GuassDB Props.percona ： percona 华为云服务中的鲲鹏云手机服务的特性 原生指令兼容性 32/64位应用全兼容 ARM原生指令兼容性 Monbox双OS共内核架构 单台服务器超200路并发 性能较模拟器提升10倍以上 自研芯片及硬件底座 华为鲲鹏916/920芯片 自研高性能GPU 华为云鲲鹏云手机结合华为在操作系统、虚拟化以及容器等方面技术深厚积累，构建高密MonBox仿真软件架构，相比同等性能x86服务器构造方案，性能提升高达10倍以上，并完美兼容32位与64位的应用。 华为云服务器应用场景计算加速型 ： AI训练、推理 内存密集型KM1 ：Redis、Cassandra内存数据库 存储密集型KI1 ：分布式缓存数据库、大数据 通用计算型KC1 ：建站、电商、游戏、视频、大数据、HPC等 通用型KS1 ：大数据管理节点、NameNode、HPC等 存储型KD1 ：大数据数据节点、DataNode、Kafka等 openEuler1.0是一款开源操作系统，支持鲲鹏、至强及其他多种处理器，能充分释放计算芯片的潜能 iSula特点iSula 通用容器引擎（iSulad）是一种新的容器解决方案，具有以下特点： 快速灵活&amp;轻量级 可信&amp;安全启动 升级不中断业务 增强安全性和调测特性 iSula部署模式 iSula 通用容器引擎（iSulad）是一种新的容器解决方案，提供统一的架构设计来满足CT和IT领域的不同需求。相比 Golang 编写的 Docker，轻量级容器具有轻、灵、巧、快的特点，不受硬件规格和架构的限制，底噪开销更小，可应用领域更为广泛。openEuler 1.0 中提供容器运行的基础平台iSula。 容器根据部署模型可以分成三种模型：应用容器、安全容器、系统容器。 应用容器应用最广泛的容器形态，容器中仅运行客户定义的应用程序。openEuler 1.0 集成 moby 18.09 版本，并在版本基础上进行了 bugfix 和稳 定性增强。 安全容器本质上是虚拟机，但是接口封装为容器接口；着重容器的隔离性缺陷。openEuler 1.0 集成 kata-container1.7 版本，在社区版本的基础 上，进行了稳定性和可靠性加固，增加了异构计算支持，更适于生产环境的 Host CGroup 配置与 DPDK/SPDK 高性能网络、存储支持。 系统容器本质上是容器，但是使用方式和虚拟机相同；着重解决虚拟机的厚重问题。iSula 容器平台支持创建系统容器，并能支持在系统容器内动 态调整设备、运行资源，且提供更优秀的 user namespace 隔离。 华为鲲鹏920处理器内置了3大加速引擎：ssl加速引擎、加解密加速引擎、压缩解压缩加速引擎。 华为计算服务适用场景高性能计算型：可适用于基因工程、游戏动画、生物制药的计算和存储系统；渲染农场、动漫影视基地等公共渲染平台，以及影视等渲染 平台；高性能前端集群、Web 服务器、高性能科学和工程应用、广告服务、视频编码和分布式分析等等 计算加速型 ： AI训练、推理 内存密集型KM1 ：Redis、Cassandra内存数据库 存储密集型KI1：分布式缓存数据库、大数据 通用计算型KC1：建站、电商、游戏、视频、大数据、HPC等 通用型KS1：大数据管理节点、NameNode、HPC等 存储型KD1：大数据数据节点、DataNode、Kafka等 TPCC衡量标准tpmC（NewOrders）:每分钟处理的订单个数 tpmTOTAL（TPS）：每分钟处理的总数 华为云通过的国际认证近日，全球权威标准机构BSI（英国标准协会）和CSA（云安全联盟）宣布，华为云顺利通过ISO 27001&amp; ISO 27017&amp;ISO 27018&amp;CSA STAR四个安全复审和认证。 容灾指标业界领先：跨AZ RPO=0，RTO&lt; 30分钟，确保数据零丢失，业务快速恢复。 最高等级：快速构建云上两地三中心，同城双中心可达Tier5~Tier6容灾等级。 专属安全：物理隔离，满足安全合规要求，相比客户自建容灾中心免基础设施运维。 云计算的特征1.按需自助服务，消费者不需要或很少需要云服务提供商的协助，就可以单方面按需获取云端的计算资源。 2.广泛的网络接入，消费者可以随时随地使用云终端设备接入网络并使用云端的计算资源。常见的云终端设备包括手机、平板、笔记本电 脑、PDA掌上电脑和台式机等。 3.资源池化，云端计算资源需要被池化，以便通过多租户形式共享给多个消费者，也只有池化才能根据消费者的需求动态分配或再分配各 种物理的和虚拟的资源。消费者通常不知道自己正在使用的计算资源的确切位置，但是在自助申请时允许指定大概的区域范围（比如在哪 个国家、哪个省或者哪个数据中心）。 4.快速弹性伸缩。消费者能方便、快捷地按需获取和释放计算资源，也就是说，需要时能快速获取资源从而扩展计算能力，不需要时能迅 速释放资源，以便降低计算能，从而减少资源的使用费用。对于消费者来说，云端的计算资源是无限的，可以随时申请并获取任何数量的 计算资源。但是我我们一定要消除一个误解，那就是一个实际的云计算系统不一定是投资巨大的工程，也不一定要购买成千上万台计算 机，也不一定具备超大规模的运算能力。其实一台计算机就可以组建一个最小的云端，云端建设方案务必采用可伸缩性策略，刚开始时采 用几台计算机，然后根据用户数量规模来增减计算资源。 5.可计量服务，消费者使用云端计算资源是要付费的，付费的计量方法有很多，比如根据某类资源（如存储、CPU、内存、网络带宽等） 的使用量和时间长短计费，也可以按照每使用一次来计费。但不管如何计费，对消费者来说，价码要清楚，计量方法要明确，而云服务提 供商需要监视和控制资源的使用情况，并及时输出各种资源的使用报表，做到供/需双方费用结清清楚楚、明明白白。 云计算的四种部署模型私有云云端资源只给一个单位组织内的用户使用，这是私有云的核心特征。而云端的所有权、日程管理和操作的主体到底属于谁并没有严格的规 定，可能是本单位，也可能是第三方机构，还可能是二者的联合。云端可能位于本单位内部，也可能托管在其他地方。 社区云云端资源专门给固定的几个单位内的用户使用，而这些单位对云端具有相同的诉求（如安全要求、云端使命、规章制度、合规性要求 等）。云端的所有权、日常管理的操作的主体可能是本社区内的一个或多个单位，也可能是社区外的第三方机构，还可能是二者的联合。 云端可能部署在本地，也可能部署与他处。 公共云云端资源开发给社会公众使用。云端的所有权、日常管理和操作的主体可以是一个商业组织、学术机构、政府部门或者它们其中的几个联 合。云端可能部署在本地，也可能部署于其他地方，比如中山市民公共云的云端可能就建在中山，也可能建在深圳。 混合云混合云由两个或两个以上不同类型的云（私有云、社区云、公共云）组成，它们各自独立，但用标准的或专有的技术将它们组合起点，而 这些技术能实现云之间的数据和应用程序的平滑流转。由多个相同类型的云组合在一起，混合云属于多云的一种。私有云和公共云构成的 混合云是目前最流行的——当私有云资源短暂性需求过大（称为云爆发，Cloud Bursting）时，自动租赁公共云资源来平抑私有云资源 的需求峰值。例如，网店在节假日期间点击量巨大，这时就会临时使用公共云资源的应急。 云计算的3种服务模式SaaS软件即服务（Software as a Service，SaaS）,云服务提供商把IT系通中的应用软件层作为服务租出去，消费者不用自己安装应用软件，直 接使用即可，这进一步降低了云服务消费者的技术门槛。 PaaS平台即服务（Platform as a Service，PaaS）。云服务提供商把IT系统中的平台软件层作为服务租出去，消费者自己开发或者安装程序， 并运行程序。 IaaS基础设施及服务（Infrastructure as a Service，IaaS）。云服务提供商把IT系统的基础设施层作为服务租出去，由消费者自己安装操作系 统、中间件、数据库和应用程序。 云硬盘的类型普通IO该类型云硬盘的最大IOPS为2200，适用于大容量、读写速率中等、事务性处理较少的应用场景，例如企业的日常办公应用或者小型测试 等 高速高IO该类型云硬盘的最大IOPS可达5000，最低读写时延为1 ms，适用于主流的高性能、高可靠应用场景，例如企业应用、大型开发测试以及 Web服务器日志等。 超高IO该类型云硬盘的最大IOPS可达33000，最低读写时延为1 ms，适用于超高IO、超大带宽的读写密集型应用场景，例如高性能计算应用场 景，用来部署分布式文件系统，或者I/O密集型应用场景，用来部署各类NoSQL/关系型数据库。 超高IO (时延优化)该类型的云硬盘提供低至1 ms的读写时延和高达1 GB/s的吞吐量，可运行企业核心业务，如SAP HANA。 docker ps -a显示标题含义CONTAINER ID：容器的唯一表示ID。 IMAGE：创建容器时使用的镜像。 COMMAND：容器最后运行的命令。 CREATED：创建容器的时间。 STATUS：容器状态。 PORT：:对外开放的端口。 CPU性能和网络带宽都会影响HPC性能 –mcpu=tsv110是GNU9编译器对鲲鹏架构进行指定优化的参数。 RPM常用命令安装软件：执行rpm -ivh rpm包名，如： #rpm -ivh apache-1.3.6.i386.rpm 升级软件：执行rpm -Uvh rpm包名。 反安装：执行rpm -e rpm包名。 查询软件包的详细信息：执行rpm -qpi rpm包名。 查询某个文件是属于那个rpm包：执行rpm -qf rpm包名。 查该软件包会向系统里面写入哪些文件：执行 rpm -qpl rpm包名。 TaiShan服务器适用场景 TaiShan 5280：存储型服务器 TaiShan 2280：均衡型服务器 TaiShan X6000：高密型服务器 TaiShan 2480： 2U4路高性能型 设置CPU的亲和性 echo cpuMask>/proc/irq/smp affinity- list numactl命令 C语言的sched setaffinity函数 在从x86平台向鲲鹏处理器迁移软件时，技术分析阶段需要完成以下哪些活动? 软件栈分析（应用软件、OS、数据库、中间件组件等） 编程语言/代码、依赖库分析 准备调试编译环境（准备测试样机服务器/OpenLab线上服务器） 成立项目组 制定迁移计划 协调相关人力/物料资源 主要活动为： 软件栈分析、制定迁移替换策略 申请线上资源/测试样机上架上电 安装OS/编译器/JDK/其他工具软件 GNU1984年有Richard Stallman发起并创建，意在创造一个自由使用、自由学习和修改、自由分发、自由创建衍生版软件的环境。 GNU目标是编写大量兼容于Unix系统的自由软件 GPL 通用性公开许可证，开源协议 自由软件的通用许可证 允许用户任意复制、传递、修改及再发布 基于自由软件修改再次发布的软件，仍需遵循GPL LGPL 相对于GPL较为宽松，允许不公开全部源代码 为基于Linux平台开发商业软件提供了更多空间 OpenEuler的技术特性系统安装：openEuler 1.0 改进了安装程序 Anaconda，并做了个性化定制和修改，方便用户安装。 定制/剪裁：openEuler 1.0 提供优化的 kiwi 工具对系统进行个性化的自定义修改。 文件系统：openEuler 1.0 中使用的默认文件系统是ext4，兼容ext3/2文件系统。openEuler 1.0 支持高性能日志文件系统XFS。 系统管理：openEuler 1.0 使用 systemd 进行系统和服务的管理，systemd 与 SysV 和 Linux 标准的 init 脚本兼容。 系统安全：openEuler 1.0 提供多重安全手段，包括身份识别与认证、安全协议、强制访问控制、完整性保护、安全审计等安全机制，保 障操作系统的安全性，为各类上层应用提供安全基础。 系统调测：openEuler 1.0 支持Perf性能调测工具和blktrace块设备I/O跟踪工具。 编译器：openEuler 1.0 基于原生GCC进行了Bug修复、特性增强；同时openEuler 1.0提供Huawei Open JDK支持，相比较Open JDK， Huawei Open JDK作了优化、稳定性增强、安全增强等。 内核：openEuler 1.0 采用 kernel 版本 4.19。Linux Kernel 4.19 是一个 LTS 版本，提供长期支持并持续更新版本，以保障用户的 Linux 操作系统安全、可靠。 PostgreSQL常用命令登陆数据库：/home/pgsql/bin/psql -U postgres 初始化数据库： /home/pgsql/bin/initdb -D pgsql/ 启动数据库： /home/pgsql/bin/pg_ctl -D pgsql/ -l logfile start BenchmarkSQL配置文件参数warehouse：指定仓库数量。 loadWorkers：指定装载数据的并发数。 Terminals：指定并发用户数。 runMins：指定测试时间。 runTxnsPerTerminal：指定每个Terminal运行的事务数量，runMins必须等于0。 limitTxnsPerMin：指定每分钟总事务数。 terminalWarehouseFixed：指定每个终端是否绑定固定warehouse。 HCS Online主打应用场景 行业云场景 HCSO+HPC场景 HCSO+灾备场景 智能大数据场景 多级混合云场景 鲲鹏处理器优点 采用ARM架构，同样功能性能占用的芯片面积小、功耗低、集成度更高，更多的硬件CPU核具备更好的并发性能。 支持16位、32位、64位多种指令集，能很好的兼容从IoT、终端到云端的各类应用场景。 大量使用寄存器，大多数数据操作都在寄存器中完成，指令执行速度更快。 采用RISC指令集，指令长度固定，寻址方式灵活简单，执行效率高。 HiBench开源的大数据基准测试套件。 用于评估大数据框架的速度，吞吐量和系统资源利用率。 支持的框架：hadoopbench、sparkbench、stormbench、flinkbench、gearpumpbench。 支持的开源版本组件：Hadoop、Spark、Storm、Kafka、Flink。 目前使用较多的版本：HiBench-7.0。 共计19个测试方向，可分为6种测试类别。 软件迁移过程技术分析-&gt;编译迁移-&gt;功能验证-&gt;性能调优-&gt;规模商用 容灾容灾系统是指在相隔较远的异地，建立两套或多套功能相同的IT系统，互相之间可以进行健康状态监视和功能切换，当一处系统因意外 （如火灾、地震等）停止工作时，整个应用系统可以切换到另一处，使得该系统功能可以继续正常工作。容灾技术是系统的高可用性技术 的一个组成部分，容灾系统恢复功能。 数据库容灾数据库容灾，即在异地部署一个一模一样的数据库，一个数据库所处的地理位置发生自然灾害了导致当前数据库发生灾难，另一个数据库会立马顶替工作。 冷备容灾每天备份一次数据库，保存在磁带或光盘上。 热备容灾建立数据库灾备中心，与主库实时进行数据同步，同时应用系统保持文件实时同步，保证引用系统版本最新。 应用双活双活容灾即灾备系统中使主生产端数据库和备机端数据库同时在线运行，处于可读可查询的状态的技术。 SHARE78容灾备份标准等级真正的容灾必须满足三个要素 系统中的部件 数据都具有冗余性，即一个系统发生故障 容灾系统要追求全部的数据复制，也称为容灾的”3R”（Redundance、Remote、Replication） ​ 从简单的仅在本地进行磁带备份，到将备份的磁带存储在异地，再到建立应用系统实时切换的异地备份系统，恢复时间也可以从 几天到小时级到分钟级、秒级或零数据丢失等。目前针对这七个层次，都有相应的容灾方案，所以，用户在选择容灾方案时应重点区 分它们各自的特点和适用范围，结合自己对容灾系统的要求判断选择哪个层次的方案。 零级 无异地备份 零级容灾方案数据仅在本地进行备份，没有在异地备份数据，未制定灾难恢复计划。这种方式是成本低的灾难恢复解决方案，但不具 备真正灾难恢复能力。 特点：是用户投资较少，技术实现简单。 缺点：是一旦本地发生毁灭性灾难，将丢失全部的本地备份数据，业务无法恢复。 一级 实现异地备份 进行本地数据备份，然后将备份介质送往异地存放。异地未建容灾备份中心，没有灾难恢复计划。 该方案成本较低，运用本地备份管理软件，可以在本地发生毁灭性灾难后，恢复从异地运送过来的备份数据到本地，进行业务恢复， 但难以管理。 二级 热备份站点备份 将关键数据进行备份并存放到异地，制定有相应灾难恢复计划，具有热备份能力的站点灾难恢复。一旦发生灾难，利用热备份主机系 统将数据恢复。 该容灾方案由于备份介质是采用交通运输方式送往异地，异地热备中心保存的数据是上一次备份的数据，可能会有几天甚至几周的数 据丢失。这对于关键数据的容灾是不能容忍的。 三级 在线数据恢复 通过网络将关键数据进行备份并存放至异地，制定有相应灾难恢复计划，有备份中心，并配备部分数据处理系统及网络通信系统。特 点：用电子数据传输取代交通工具传输备份数据，从而提高了灾难恢复的速度。 该方案由于备份站点要保持持续运行，对网络的要求较高，因此成本相应有所增加。利用异地的备份管理软件将通过网络传送到异地 的数据备份到主机系统。一旦灾难发生，需要的关键数据通过网络可迅速恢复，通过网络切换，关键应用恢复时间可降低到天（数量 1）或小时级。 四级 定时数据备份 该方案是在第三级容灾方案的基础上，利用备份管理软件自动通过通信网络将部分关键数据定时备份至异地，并制定相应的灾难恢复 计划。一旦灾难发生，利用备份中心已有资源及异地备份数据恢复关键业务系统运行。 该方案由于对备份管理软件设备和网络设备的要求较高，因此投入成本也会增加。但由于该级别备份的特点，业务恢复时间和数据的 丢失量还不能满足关键行业对关键数据容灾的要求。 五级 实时数据备份 在前面几个级别的基础上使用了硬件的镜像技术和软件的数据复制技术，可以实现在应用站点与备份站点的数据都被更新。数据在两 个站点之间相互镜像，由远程异步提交来同步，因为关键应用使用了双重在线存储，所以在灾难发生时，仅仅很小部分的数据被丢 失，恢复的时间被降低到了分钟级或秒级。 由于对存储系统和数据复制软件的要求较高，所需成本也大大增加。该方案由于既能保证不影响当前交易的进行，又能实时复制交易 产生的数据到异地，所以这一层次的方案是目前应用较常见的一类产品容灾解决方案。 六级 零数据丢失 该方案是灾难恢复中较昂贵的方式，也是速度较快的恢复方式，它是灾难恢复的级别中的佼佼者，利用专用的存储网络将关键数据同 步镜像至备份中心，数据不仅在本地进行确认，而且需要在异地（备份）进行确认。 因为，数据是镜像地写到两个站点，所以灾难发生时异地容灾系统保留了全部的数据，实现零数据丢失。要求实现远程实时备份，数 据零丢失；备份中心具备与生产中心一致的处理能力，可实现业务的实时无缝切换，即业务接管。 鲲鹏通用计算型KC1 CPU:MEM = 1:2/1:4 最高30G内网带宽 400万PPS Tai Shan5280存储型服务器支持RAID 0/1/10/1E/5/50/6/60","categories":[{"name":"华为认证","slug":"华为认证","permalink":"https://imqinhao.cn/categories/%E5%8D%8E%E4%B8%BA%E8%AE%A4%E8%AF%81/"}],"tags":[]},{"title":"Python实现《三国演义》人物出场次数统计","slug":"Python-4","date":"2020-05-25T03:11:11.000Z","updated":"2021-07-17T02:49:01.271Z","comments":true,"path":"2020/05/25/Python-4/","link":"","permalink":"https://imqinhao.cn/2020/05/25/Python-4/","excerpt":"使用Python的第三方库jieba库实现《三国演义》人物出场次数Top20统计。","text":"使用Python的第三方库jieba库实现《三国演义》人物出场次数Top20统计。 代码123456789101112131415161718192021222324252627282930313233343536import jiebatxt = open(\"ThreeKingdoms.txt\",\"r\", encoding=\"gb18030\").read()exclude = &#123;\"将军\",\"却说\",\"二人\",\"不可\",\"不能\",\"如此\",\"荆州\",\"商议\",\"如何\",\"主公\",\\ \"军士\",\"左右\",\"军马\",\"引兵\",\"次日\",\"大喜\",\"天下\",\"东吴\",\"于是\",\"今日\",\\ \"不敢\",\"魏兵\",\"陛下\",\"人马\",\"都督\",\"一人\",\"不知\",\"汉中\",\"众将\",\"只见\",\\ \"后主\",\"蜀兵\",\"大叫\",\"上马\",\"先主\",\"太守\",\"此人\",\"天子\",\"后人\",\"背后\",\\ \"城中\",\"何不\",\"一面\",\"忽报\",\"大军\",\"先生\",\"何故\",\"夫人\",\"先锋\",\"然后\",\\ \"不如\",\"赶来\",\"原来\",\"令人\",\"江东\",\"正是\",\"徐州\",\"忽然\",\"下马\",\"喊声\",\\ \"成都\",\"因此\",\"未知\",\"百姓\",\"大败\",\"大事\",\"一军\",\"之后\",\"不见\",\"接应\",\\ \"起兵\",\"引军\",\"军中\",\"可以\",\"进兵\",\"大怒\",\"大惊\",\"心中\",\"以为\",\"不得\",\\ \"下文\",\"粮草\",\"追赶\",\"分付\",\"一声\",\"分解\" &#125;words = jieba.lcut(txt)counts = &#123;&#125;for word in words: if len(word) == 1: continue elif word == \"诸葛亮\" or word == \"孔明曰\": rword = \"孔明\" elif word == \"关公\" or word == \"云长\": rword = \"关羽\" elif word == \"玄德\" or word == \"玄德曰\": rword = \"刘备\" elif word == \"孟德\" or word == \"丞相\": rword = \"曹操\" else: rword = word counts[rword] = counts.get(rword,0) + 1for word in exclude: del counts[word]items = list(counts.items())items.sort(key=lambda x:x[1],reverse=True)for i in range(20): word,count = items[i] print(\"&#123;0:&lt;12&#125;&#123;1:&lt;4&#125;\".format(word,count)) 效果图","categories":[{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"}],"tags":[]},{"title":"七段数码管带时间倒计时效果","slug":"Python-3","date":"2020-05-24T03:11:11.000Z","updated":"2021-07-17T02:48:52.261Z","comments":true,"path":"2020/05/24/Python-3/","link":"","permalink":"https://imqinhao.cn/2020/05/24/Python-3/","excerpt":"带刷新时间的时间倒计时效果，使用随机数生成随机色，实现不同数字间的颜色变化。","text":"带刷新时间的时间倒计时效果，使用随机数生成随机色，实现不同数字间的颜色变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import turtleimport timeimport randomdef drawLine(draw): turtle.pendown() if draw else turtle.penup() turtle.fd(70) turtle.right(90)def drawDigit(digit,color): turtle.pencolor(color) drawLine(True) if digit in [2, 3, 4, 5, 6, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 1, 3, 4, 5, 6, 7, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 2, 3, 5, 6, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 2, 6, 8] else drawLine(False) turtle.left(90) drawLine(True) if digit in [0, 4, 5, 6, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 2, 3, 5, 6, 7, 8, 9] else drawLine(False) drawLine(True) if digit in [0, 1, 2, 3, 4, 7, 8, 9] else drawLine(False) turtle.penup() turtle.left(180) turtle.fd(-70) time.sleep(0.8) turtle.clear()def randomColor(): num1 = random.random() num2 = random.random() num3 = random.random() return num1,num2,num3def main(): turtle.setup(500,500) turtle.penup() turtle.fd(-25) turtle.pensize(5) turtle.speed(0.1) for i in range(1,11): drawDigit(10-i,randomColor()) # randomColor() turtle.write(\"浩浩❤元元\",font=(\"Arial\",55,\"normal\"),align=\"center\") turtle.hideturtle() turtle.done()main()","categories":[{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"}],"tags":[]},{"title":"白嫖天翼云盘4T空间和1年会员","slug":"free-get-189vip","date":"2020-05-23T04:00:00.000Z","updated":"2021-07-17T02:40:08.254Z","comments":true,"path":"2020/05/23/free-get-189vip/","link":"","permalink":"https://imqinhao.cn/2020/05/23/free-get-189vip/","excerpt":"天翼云盘是中国电信推出的云存储服务，通过天翼云盘可多终端上传和下载、管理和分享文件。天翼网盘免费提供30G个人云空间、30G家庭云空间，单文件最大为2G。订购会员可以获得4T空间，且上传文件无大小限制。接下来我们来免费撸1年的黄金VIP会员和4T云存储空间。","text":"天翼云盘是中国电信推出的云存储服务，通过天翼云盘可多终端上传和下载、管理和分享文件。天翼网盘免费提供30G个人云空间、30G家庭云空间，单文件最大为2G。订购会员可以获得4T空间，且上传文件无大小限制。接下来我们来免费撸1年的黄金VIP会员和4T云存储空间。 下载客户端 注册天翼网盘账号打开APP，点击短信验证码登录，勾选登录即同意服务协议和隐私协议。 此时会跳转到短信验证码登录界面，输入手机号，点击获取验证码，将收到的验证码输入到验证码输入栏，点击登录即可注册登录成功。 获得三个月黄金会员进入软件首页，点击活动。 找到家庭云免费赠送三个云黄金会员活动。 完成两个任务即可领取天翼网盘黄金会员。 获得4T空间加1年黄金会员找到活动1年教师尊享会员免费领。 点击立即认证领取。 认证界面填写自己的姓名、学校、身份证号码，然后上传相关的资格证即可领取高达4T的云空间和1年的黄金会员。 其实上面的姓名、学校、身份证号码可以随便乱填，资格证上传一张表情包都是可以通过的。 查看会员是否到账退出APP，重新进入APP，然后查看会员和空间是否到账。 领取更多空间每日签到可以增大云空间容量。 写在最后活动截止到6月30日结束，大家赶紧行动起来。不限速，不限速，不限速，重要的事情说三遍，大家且行且珍惜。 如果想获取更多内容欢迎关注我的公众号！","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://imqinhao.cn/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[]},{"title":"七段数码管绘制系统时间","slug":"python-2","date":"2020-05-20T12:13:14.000Z","updated":"2021-07-17T02:48:40.675Z","comments":true,"path":"2020/05/20/python-2/","link":"","permalink":"https://imqinhao.cn/2020/05/20/python-2/","excerpt":"Python代码利用turtle（海龟绘图）实现七段数码管的显示，绘制当前的系统日期。","text":"Python代码利用turtle（海龟绘图）实现七段数码管的显示，绘制当前的系统日期。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#SevennDigitsDrawV1.pyimport turtleimport timedef DrawGap(): turtle.penup() turtle.fd(5) def DrawLine(draw): DrawGap() turtle.pendown() if draw else turtle.penup() turtle.fd(40) DrawGap() turtle.right(90) def DrawDigits(digits): DrawLine(True) if digits in [2,3,4,5,6,8,9] else DrawLine(False) DrawLine(True) if digits in [0,1,3,4,5,6,7,8,9] else DrawLine(False) DrawLine(True) if digits in [0,2,3,5,6,8,9] else DrawLine(False) DrawLine(True) if digits in [0,2,6,8] else DrawLine(False) turtle.left(90) DrawLine(True) if digits in [0,4,5,6,8,9] else DrawLine(False) DrawLine(True) if digits in [0,2,3,5,6,7,8,9] else DrawLine(False) DrawLine(True) if digits in [0,1,2,3,4,7,8,9] else DrawLine(False) turtle.left(180) turtle.penup() turtle.fd(20)def DrawDate(date): turtle.pencolor(\"red\") for i in date: if i == \"-\": turtle.write('年',font=(\"Arial\",18,\"normal\")) turtle.pencolor(\"green\") turtle.fd(40) elif i == \"=\": turtle.write('月',font=(\"Arial\",18,\"normal\")) turtle.pencolor(\"blue\") turtle.fd(40) elif i == \"+\": turtle.write('日',font=(\"Arial\",18,\"normal\")) else: DrawDigits(eval(i)) def main(): turtle.setup(800,300) turtle.penup() turtle.fd(-300) turtle.pensize(5) DrawDate(time.strftime(\"%Y-%m=%d+\",time.gmtime())) turtle.hideturtle() turtle.done() main() 效果","categories":[{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"}],"tags":[]},{"title":"网页禁止审查元素和F12","slug":"not-allow-F12","date":"2020-05-19T14:25:11.000Z","updated":"2021-07-17T02:47:07.947Z","comments":true,"path":"2020/05/19/not-allow-F12/","link":"","permalink":"https://imqinhao.cn/2020/05/19/not-allow-F12/","excerpt":"很多时候我们不想要自己的博客被其他人审查元素，防止其他人扒下自己的网页，获取网站内资源的真实链接，都会选择使用禁止浏览器右键查看元素或F12审查元素。","text":"很多时候我们不想要自己的博客被其他人审查元素，防止其他人扒下自己的网页，获取网站内资源的真实链接，都会选择使用禁止浏览器右键查看元素或F12审查元素。 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt;document.onkeydown = function()&#123;if(window.event &amp;&amp; window.event.keyCode == 123) &#123; alert(\"F12被禁用\"); event.keyCode=0; event.returnValue=false;&#125;if(window.event &amp;&amp; window.event.keyCode == 13) &#123; window.event.keyCode = 505;&#125;if(window.event &amp;&amp; window.event.keyCode == 8) &#123; alert(str+\"\\n请使用Del键进行字符的删除操作！\"); window.event.returnValue=false;&#125;&#125;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; document.onkeydown = function()&#123; if(window.event &amp;&amp; window.event.keyCode == 123) &#123; window.location=\"about:blank\"; //将当前窗口跳转置空白页 event.keyCode=0; event.returnValue=false; &#125; if(window.event &amp;&amp; window.event.keyCode == 13) &#123; window.event.keyCode = 505; &#125; if(window.event &amp;&amp; window.event.keyCode == 8) &#123; alert(str+\"\\n请使用Del键进行字符的删除操作！\"); window.event.returnValue=false; &#125; &#125; &lt;/script&gt;","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://imqinhao.cn/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[]},{"title":"解决pip异常:No module named 'pip'","slug":"No-module-named-pip","date":"2020-05-19T13:10:00.000Z","updated":"2021-07-17T02:46:39.225Z","comments":true,"path":"2020/05/19/No-module-named-pip/","link":"","permalink":"https://imqinhao.cn/2020/05/19/No-module-named-pip/","excerpt":"学习Python过程中，pip安装模块的时候提示我有新版本更新，更新之后不知道为什么就无法使用pip命令了，一直提示ModuleNotFoundError: No module named 'pip'。","text":"学习Python过程中，pip安装模块的时候提示我有新版本更新，更新之后不知道为什么就无法使用pip命令了，一直提示ModuleNotFoundError: No module named 'pip'。 1234567Traceback (most recent call last): File &quot;e:\\python\\lib\\runpy.py&quot;, line 193, in _run_module_as_main return _run_code(code, main_globals, None, File &quot;e:\\python\\lib\\runpy.py&quot;, line 86, in _run_code exec(code, run_globals) File &quot;E:\\python\\Scripts\\pip.exe\\__main__.py&quot;, line 5, in &lt;module&gt;ModuleNotFoundError: No module named &#39;pip&#39; 解决方案1Python -m ensurepip 1python -m pip install --upgrade pip 至此，pip命令修复完成，又可以正常使用了","categories":[{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"}],"tags":[]},{"title":"非华为电脑使用多屏协同","slug":"huawei-PCManager","date":"2020-05-19T03:42:14.000Z","updated":"2021-07-17T02:41:23.504Z","comments":true,"path":"2020/05/19/huawei-PCManager/","link":"","permalink":"https://imqinhao.cn/2020/05/19/huawei-PCManager/","excerpt":"绕过华为对非华为电脑管家的限制，一键安装PCManager（不需要改BOIS） PCManager管理功能，启动、关闭、服务控制等。 提供极客模式。","text":"绕过华为对非华为电脑管家的限制，一键安装PCManager（不需要改BOIS） PCManager管理功能，启动、关闭、服务控制等。 提供极客模式。 前期准备 具有多屏协同功能的华为或荣耀手机 一台带蓝牙和无线网卡的win 10电脑 安装华为的电脑管家华为电脑管家的安装包大家可以关注我的微信公众号，回复“多屏协同”即可获取安装包及安装工具下载地址。 解压文件解压之后会得到下图的文件。 启动安装工具 将之前安装的电脑管家完全卸载，删除C:\\Program Files\\Huawei\\PCManager目录所有文件。 重启电脑。 PCManagerMgr.exe右键，以管理员身份运行。 卸载之前的版本如果之前安装过旧版本请执行此步骤，没有安装过请跳过 点击卸载，会弹出华为电脑管家的卸载界面，点击我要卸载，等待卸载完成，出现电脑管家已卸载，点击完成。 重启电脑卸载完成后需要重启电脑，然后再次打开工具。 获取口令关注汉客儿的微信公众号，回复关键字口令，将获取到的口令复制到下图方框位置。 开始安装复制口令后，点击安装。 点击安装后会出现正在安装hw电脑管家...，等待弹出华为电脑管家的安装界面。注意：系统必须是win10的，我这里由于安装过了，用虚拟机展示的界面。 点击立即安装。 安装完成后会到工具，看到当前管家已经xx，尽情享受吧，此时软件已经安装完成。 检查服务是否运行检查上图中右边的服务是否是运行中的状态，如果是未运行则点击后面的运行按钮。 连接手机点击左侧我的手机，然后点击立即连接。 选择扫码连接，手机打开华为浏览器，扫码后点击连接。 点击连接。 点击允许。 连接成功之后会出现手机的型号以及存储空间信息。 多屏协同点击多屏协同。 此时就可以使用多屏协同功能啦。 建议电脑和手机处于5GHz频带的wifi可提升流畅度。","categories":[{"name":"软件破解","slug":"软件破解","permalink":"https://imqinhao.cn/categories/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/"}],"tags":[]},{"title":"ICIC","slug":"ICIC","date":"2020-05-12T06:11:21.000Z","updated":"2021-07-17T02:41:34.063Z","comments":true,"path":"2020/05/12/ICIC/","link":"","permalink":"https://imqinhao.cn/2020/05/12/ICIC/","excerpt":"小区间干扰协调（Inter Cell Interference Coordination，ICIC）是用来解决同频组网时，小区间干扰的技术。","text":"小区间干扰协调（Inter Cell Interference Coordination，ICIC）是用来解决同频组网时，小区间干扰的技术。 干扰抑制的3种类型 干扰随机化：加扰、交织、跳频 干扰消除：波束赋形、IRC 干扰协调：ICIC 资源调度方式 资源调度周期 小区间干扰抑制技术小区间的干扰主要来自于同频组网带来的同频干扰。 小区间干扰抑制技术 干扰随机化技术 干扰消除技术 干扰协调技术（ICIC） 小区间干扰随机化技术：加扰 LTE系统充分使用序列的随机化避免小区间干扰 一般情况下，加扰在信道编码之后、数据调制之前进行，即比特级的加扰。 小区间干扰随机化技术：跳频 目前LTE上下行都支持跳频传输，通过跳频传输可以随机化小区间的干扰。 除了PBCH之外，其他下行物理控制信道的资源映射均与小区id有关 PDSCH、PUSCH以及PUCCH采用子帧内跳频传输 PUSCH可以采用子帧间的跳频传输 小区间干扰消除技术：发射端波束赋形 提高期望用户的信号强度 降低信号对其他用户的干扰 已经知道被干扰用户的方位，可以主动降低对该方向辐射能量 小区间干扰消除技术：IRC接收端利用多根天线对接收信号进行加权，抑制强干扰，称为IRC。 小区间干扰协调：ICIC 是一种考虑多个小区中资源使用和负载等情况而进行的多小区无线资源管理方案。 基本思想：通过管理无线资源使得小区间干扰得到控制。 限制的无线资源： 时频资源 一定时频资源上的功率资源 是目前研究的一项热门技术，可以应用于各种宽带的业务。 小区间干扰协调ICIC的实现方式 静态ICIC：对无线资源的使用重新配置的时间以天为单位。几乎不需要基站之间交互信息。 半静态ICIC：对无线资源的使用重新配置的时间以秒为单位。基站之间信息传递的频率类似。 动态ICIC：对无线资源的使用重新配置的时间以10ms或百毫秒为单位，基站之间信息传递的频率类似。 协调调度：对无线资源的使用重新配置的时间以TTI为单位，由于x2接口的时延限制，在基站间无法实时传递信息，协调调度在LTE-advanced阶段实现。 ICIC方案对应关系图 ICIC解决方案-基于SFR半静态ICIC","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"MIMO","slug":"MIMO","date":"2020-05-11T13:21:21.000Z","updated":"2021-07-17T02:44:04.769Z","comments":true,"path":"2020/05/11/MIMO/","link":"","permalink":"https://imqinhao.cn/2020/05/11/MIMO/","excerpt":"多进多出（MIMO）是为极大地提高信道容量，在发送端和接收端都使用多根天线，在收发之间构成多个信道的天线系统。MIMO系统的一个明显特点就是具有极高的频谱利用效率，在对现有频谱资源充分利用的基础上通过利用空间资源来获取可靠性与有效性两方面增益，其代价是增加了发送端与接收端的处理复杂度。大规模MIMO技术采用大量天线来服务数量相对较少的用户，可以有效提高频谱效率。","text":"多进多出（MIMO）是为极大地提高信道容量，在发送端和接收端都使用多根天线，在收发之间构成多个信道的天线系统。MIMO系统的一个明显特点就是具有极高的频谱利用效率，在对现有频谱资源充分利用的基础上通过利用空间资源来获取可靠性与有效性两方面增益，其代价是增加了发送端与接收端的处理复杂度。大规模MIMO技术采用大量天线来服务数量相对较少的用户，可以有效提高频谱效率。 MIMO的定义 Multiple Input Multiple Output，多输入多输出。 在多个天线上分别发送多个数据流利用多径衰落，在不增加带宽和天线发射功率的情况下，提高信道容量及频谱利用率，或提高数据的传输质量。 MIMO的优点MIMO多种模式带来多种增益。 分集增益 波束赋形增益 空间复用增益 频谱效率 要求TD-LTE的下行频率速率达到5bps/Hz（Rel-10为30bps/Hz），上行频谱速率达到2.5bps/Hz（Rel-10为15bps/Hz） MIMO天线收发分集：提高通信质量。 发射分集技术提高系统下行链路性能。 MIMO天线空间复用：提高系统容量 MU-MIMO：基站将占用相同时频资源的多个数据流发送给不同用户 下行同时支持SU-MIMO和MU-MIMO MIMO天线波束赋形：增强抗干扰能力 传统的波束赋形： 小间距的天线阵列，使用较多天线单元 提高峰值速率，小区覆盖，降低小区间的干扰 LTE创新技术：双流波束赋形 MIMO优点总结发送分集：提高可靠性，不能提升数据速率 波束赋形：降低干扰，能提升数据速率 空分复用：多个数据流传输，可提升数据速率 TD-LTE中MIMO的应用（PDSCH 传输方案） 传输模式 PDSCH传输方案 优点 典型应用方案 TM1 单天线传输模式 产生的CRS开销小 各类场景 TM2 发送分集 提高链路传输质量，提高小区覆盖半径 作为其他MIMO模式的回退模式 TM3 开环空间复用 提高小区平均频谱效率和峰值速率 高速移动场景 TM4 闭环空间复用 提高小区平均频谱效率和峰值速率 低速移动场景 TM5 多用户MIMO 提高小区平均频谱效率和峰值速率 密集城区 TM6 Rank=1的预编码 提高小区的覆盖 仅支持rank=1的传输 TM7 单流波束赋形 提高链路传输质量，提高小区覆盖半径 郊区、大范围覆盖场景 TM8 双流波束赋形 提高小区覆盖，提升小区中心用户吞吐量 小区中心吞吐量需求大的场景 TM1：单天线端口传输 最简单的传输方案 PDSCH使用单天线端口传输时，根据Port0上的CRS进行解调。 Port0上的小区专用参考信号的标识是R0。 TM2：发送分集 用于增强小区覆盖。 作为TM3/4/5/6/7的回退模式 LTE中的实现方式SFBC+FSTD。 TM3：开环空间复用 一种大延迟（CDD）空间复用，接收端不需给发射端反馈预编码矩阵信息。 用于提高小区平均频谱效率和峰值速率。 适用于高速移动场景。 TM4：闭环空间复用 发送端需要给接收端反馈预编码矩阵信息。 用于提高小区平均频谱效率和峰值速率。 适用于低速移动场景。 TM5：多用户MIMO 只支持每个用户单层的传输，而且最大支持两层。 用于提高小区平均频谱效率和峰值速率。 TM6：闭环RANK=1的预编码 用于增强小区覆盖。 尽可能减小承载相关的控制信令。 仅支持rank=1的传输。 TM7：单流波束赋形 PDSCH是依据port5上DRS进行解调的。 用于提高小区边缘用户的覆盖。 单流波束赋形是基于专用导频的非码本波束赋形。 主要用于TD-LTE系统。 TM8：双流波束赋形 双流波束赋形将波束赋形技术与空间复用技术相结合。 既提高小区边缘用户的覆盖，也可以提升小区中心用户的吞吐量。 双流波束赋形是基于专用导频的非码本波束赋形。 双流波束赋形是TD-LTE Rel-9中的增强型技术。 终端LTE多天线","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"OFDMA","slug":"OFDMA","date":"2020-04-25T09:13:00.000Z","updated":"2021-07-17T02:47:19.640Z","comments":true,"path":"2020/04/25/OFDMA/","link":"","permalink":"https://imqinhao.cn/2020/04/25/OFDMA/","excerpt":"TD-LTE核心技术 频分多址技术之OFDMA/SC-FDMA","text":"TD-LTE核心技术 频分多址技术之OFDMA/SC-FDMA OFDMA的优点 时域上抵抗多径衰落 频域上抵抗频率选择性衰落，简化接收机的信道均衡操作 码元的长度越长，符号间的干扰（ISI）就越低。 码元的长度越长，码元速率就越低。 OFDM循环前缀CPCP能够克服时延拓展，最大限度消除符号间干扰（ISI）。CP越长，能够抵抗的多径时延越长，但相应的，系统开销也越大。 I指的是OFDM符号的编码 LTE系统中最小的时间单位叫作基本的时间单位。 一个子帧可以划分成14个OFDM符号，14个OFDM符号可以划分成2个时隙，1个时隙就是7个OFDM符号 CP使一个符号周期内因多径产生的波形为完整的正弦波，因此不同子载波对应的时域信号与其多径积分总为0，消除载波间干扰（ICI）。 OFDM定义子载波间的正交性 上行采用SC-FDMA技术 OFDM基本原理高速串行转低速并行 傅里叶逆变换 循环前缀目的：降低ISI和ICI 分类：常规CP和扩展CP OFDM和CDMA的对比 OFDM缺点 SC-FDMA单载波频分多址接入（Single Carrier Frequency Division Multiple Access） SC-FDMA类似于OFDMA，但SC-FDMA可以降低PAPR（峰均比）。 OFDMA VS SC-FDMA OFDMA导致高PAPR，影响UE的成本和电池寿命 SC-FDMA采用单载波技术，峰均比（PAPR）低，有效提高RF功率放大器的效率，降低终端成本和耗电量 下行多址方式-OFDMA集中式：连续RB分给一个用户 点击查看优点 优点：调度开销小 分布式：分配给用户的RB不连续 点击查看优点 优点：选频调度增益较大 RB(Resource Block)：资源块。业务信道资源分配的资源单位，时域上为一个时隙，频域上为12个子载波。 RE(Resource Element)：最小的资源单位，时域上为一个符号，频域上为一个子载波。 上行多址方式-SC-FDMA与OFDMA相同，将传输带宽划分成一系列正交的子载波资源，将不同的子载波资源分配给不同的用户实现多址。注意不同的是：任一终端使用的子载波必须连续。 在任一调度周期中，一个用户分得的子载波必须是连续的 上行方向上给用户分配RB要满足：$$RB = 2^a·3^b·5^c$$ 总结OFDM的缺点高峰均比，高同步要求，同频干扰 SC-FDMA定义目的：抗峰均比 傅里叶表换&amp;傅里叶逆变换 上下行资源的分配上行：资源集中&amp;连续RB数满足$$ RB = 2^a·3^b·5^c $$ 下行：资源既可集中，也可分布","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"网络接入技术与方法","slug":"Network_Access","date":"2020-04-24T10:48:12.000Z","updated":"2021-07-17T02:46:18.627Z","comments":true,"path":"2020/04/24/Network_Access/","link":"","permalink":"https://imqinhao.cn/2020/04/24/Network_Access/","excerpt":"数字用户线xDSL接入技术 光纤同轴电缆混合网 无源光网络（PON）标准化的业务（OC-1=51.84Mbps） 宽带接入技术IEEE 802.16标准与城域网","text":"数字用户线xDSL接入技术 光纤同轴电缆混合网 无源光网络（PON）标准化的业务（OC-1=51.84Mbps） 宽带接入技术IEEE 802.16标准与城域网 宽带接入技术的基本类型从用户接入的角度，宽带接入可以分为接入技术与接入方式两种类型，其中接入方式与用户工作环境与需求相关。 从技术实现的角度，且前宽带接入技术主要有：数字用户线（xDSL）技术、光纤同轴电缆混合网（HFC）技术、光纤接入技术、局域网接入技术以及无线接入技术。其中，无线接入又可以分为无线局域网接入、无线城域网接入与无线Ad hoc接入。 真考试题下列技术中，不属于无线接入技术的是（ ）。 Ad hoc SDH WiFi WiMAX 各种接入技术数字用户线xDSL接入技术xDSL中x的意思是表示它的不同类型，例如，可以理解x是A、H或RA等，它们对应于不同的数字用户线技术。xDSL技术根据上行和下行的速率是否相同可分为速率对称型和速率非对称型两种。 根据信号传输的速率、距离以及上行速率与下行速率的不同，xDSL技术主要可以分为以下几种： 点击查看具体内容 非对称数字用户线（ADSL）高比特率数字用户线（HDSL）速率自适应数字用户线（RADSL）超高比特率数字用户线（VDSL） xDSL技术的上行与下行速率 xDSL 上/下行速率（距离5.5km） 上/下行速率（距离3.6km） 是否对称 线对数 ADSL 64Kbit/s / 1.5Mbit/s 640Kbit/s / 6Mbit/s 否 1 HDSL 1.554Mbit/s 1.554Mbit/s 是 2 VDSL 2.3Mbit/s / 51Mbit/s 2.3Mbit/s / 51Mbit/s 否 2 RADSL 64Kbit/s / 1.5Mbit/s 640Kbit/s / 6Mbit/s 否 1 ADSL的技术特点主要表现在： 能够利用现有的用户电话铜双绞线，以重叠和不干扰传统模拟电话业务的方式，即普通电话业务（POTS）的方式，提供高速数字业务。ADSL允许用户在保留已有的模拟电话业务的同时，进行Internet在线访问、视频点播（VOD）等新型宽带业务。 该技术与本地环路的实际参数以及用户电话铜双绞线的特性关系都不大，所以用户不需要进行电缆的重新铺设。 上行速率在64-640Kbit/s，下行速率在500Kbit/s~7Mbit/s，用户可以根据需要自行选择。 真考试题ADSL的上行速率在（ ）。 10Mbps ~ 20Mbps 7Mbps ~ 10Mbps 640Kbps ~ 7Mbps 64Kbps ~ 640Kbps 下列关于xDSL技术的描述中，错误的是（ ）。 xDSL技术按上行与下行速率分为速率对称与非对称两类 ADSL技术在现有用户电话线上同时支持电话业务和数字业务 ADSL上行传输速率最大可以达到8Mbps HDSL上行传输速率为1.544Mbps 光纤同轴电缆混合网光纤同轴电缆混合网的基本结构 HFC是由电视头端、长距离干线、放大器、馈线与下引线组成。 HFC是新一代的有线电视网络，是一个双向传输系统，光纤结点通过同轴电缆下引线可以为500～2000个用户服务。 HFC改善了信号质量，提高了可靠性，线路可以使用的带宽甚至可以达到1GHz。 从用户接入的角度来看，光纤到HFC是经过双向改造的有线电视网络，是用户通过有线电视宽带接入Intermet的一种重要的方式。 HFC是使用Cable Modem，通过有线电视宽带接入Intermet的，数据传输速率可达10-36Mbit/s。 真考试题下列关于光纤同轴电缆混合网HFC的描述中，错误的是（ ）。 HFC是一个双向传输系统 HFC由有线电视头端、长距离干线、放大器、馈线和下引线组成 HFC的数据传输速率可达10~36Mbps HFC通过路由器将用户计算机与同轴电缆连接起来 电缆调制解调器Cable Modem把用户过算机与有线电视同抽电缆连接起来，不仅有调制解调功能，也带有加密解密和协议适配，以及网桥、路由器与集线器的部分功能。Cable Modem利用频分复用的方法，将双向信道分为：从计算机终端到网络方向称为上行信道，从网络到计算机终端方向称为下行信道。 从数据传输方向上，Cable Modem可以分为单向、双向两类。从传输方式上，Cable Modem可以分为双向对称式传输和非对称式传输两类。从同步方式上，Cable Modem可以分为类似于Ethernet的同步交换和类似于ATM技术的异步交换两类。从接入的角度，Cable Modem可以分为个人Cable Modem和宽带多用户Cable Modem。从接口的角度，Cable Modem可分为外置式、内置式和交互式机顶盒3种。 真考试题下列关于光纤同轴电缆混合网HFC的描述中，错误的是（ ）。 HFC是一个双向传输系统 Cable Modem利用频分多路复用方法将信道分为上行信道与下行信道 Cable Modem传输方式分为对称式和非对称式两类 HFC通过Cable Modem将光缆与同轴电缆连接起来 解析：HFC通过Cable Modem将用户计算机与同轴电缆连接的，并不是将光缆与同轴电缆连接的。 光纤接入技术APON（宽带无源光网络）是ATMPON的简称。ATM是一种基王信元的传输协议，能为接入网提供动态的带宽分配，从而更适合宽带数据业务的需要。EPON（以太网无源光网络）是基于以太网的PON技术。EPON采用点到多点结构、无源光纤传输，在以太网之上提供多种业务，EPON是一种实现光纤到户的重要技术。 无源光网络（PON）是基于ITU ”基于无源光纤网的高速光纤接入系统“ 下进行标准化的。 OC-3：155.520Mbit/s的对称业务 上行OC-3：155.520Mbit/s；下行OC-12：622.080Mbit/s的不对称业务。 OC-1 = 51.84Mbit/s 传输媒介可以是一根或两根单模光纤，双向传输通过波分复用（一根或两根光纤）实现。 真考试题ITU标准OC-24和OC-12的传输速率分别为（ ）。 155.52Mbps和51.84Mbps 155.52Mbps和622.08Mbps 622.08Mbps和155.52Mbps 1.244Gbps和622.08Mbps 解析： OC-24：OC-1 × 24 = 51.84 × 24 = 1244.16Mbps = 1.244Gbps OC-12: OC-24 ÷ 2 = 1244.16 ÷ 2 = 622.08Mbps ITU标准OC-3和OC-12的传输速率分别为（ ）。 622.08Mbps和1.244Gbps 155.52Mbps和622.08Mbps 155.52Mbps和51.84Mbps 51.84Mbps和622.08Mbps 解析： OC-3：OC-1 × 3 = 51.84 × 3 = 155.52Mbps OC-12: OC-1 × 12 = 51.84 × 12 = 622.08Mbps 宽带无线接入技术无线接入技术主要有IEEE 802.11标准的无线局域网（WL.AN）接入、IEEE 802.16标准的无线城域网（WMAN）接入，以及正在发展的Adhoc接入技术几种。 无线接入技术的分类与应用近距离使用可采用IEEE 802.11标准的无线局域网技术，它可以满足一定地理范围内的用户无线接入需求；远距离使用则采用IEEE 802.16标准的WiMAX技术，该技术可以在50km范围内提供最高70Mbit/s的传输速率。 IEEE 802.11标准与IEEE 802.16标准均针对无线环境,但由于通用对象不同,采用的技术与协议解决问题的重点也不相同。IEEE 802.11标准的重点在解决局域网范围的移动节点通信问题,而IEEE 802.16标准的重点是解决建筑物之间的数据通信问题。 IEEE 802.11标准与无线局域网 IEEE 802.11定义了使用红外、跳频扩频与直接序列扩频技术,数据传输速率为1Mbit/s或2Mbit/s IEEE 802.11a将传输速率提高到54Mbit/s IEEE 802.11b定义了使用直序扩频技术,传输速率为1Mbit/s、2Mbit/s、5.5 Mbit/s与11Mbit/s。 IEEE 802.16标准与无线城域网 按IEEE 802.16标准建立采用全双工、宽带通信方式工作的基站。 IEEE 802.16标准规定了无线网络使用更高的、毫米波的10~66GHz波段的频率。 在IEEE 802.16标准上增加了两个物理层标准IEEE 802.16d与IEEE 802.16e。 与IEEE 802.16标准工作组对应的论坛组织是WiMAX，最高的传输速率为134Mbit/s。 真考试题下列关于IEEE 802.16标准的描述中，错误的是（ ）。 提供宽带城域网用户访问Intenet所需要的路由服务 最高传输速率为234Mbps 使用无线频段为10~66GHz 与IEEE 802.16标准工作组对应的论坛组织是WiMAX 下列关于IEEE 802.16标准的描述中，错误的是（ ）。 802.16主要用于解决城市地区范围内的宽带无线网接入问题 802.16a用于移动结点接入 802.11d用于固定结点接入 802.16e用于固定或移动结点接入 下列关于接入技术特征的描述中，正确的是（ ）。 APON是一种无线接入技术 Cable Modem利用波分复用的方法将信道分为上行信道和下行信道 IEEE 802.11b将传输速率提高到54Mbps ADSL技术具有非对称带宽特征 点击查看解析 APON是一种光纤接入技术的一种，A选项错误；Cable Modem利用的是频分复用的方法将信道分为上行信道和下行信道，故B选项错误；IEEE 802.11b最高的传输速率是11Mbit/s，802.11a最高的速率是54Mbit/s，故C选项错误。 下列关于接入技术特征的描述中，正确的是（ ）。 EPON是一种无线接入技术 Cable Modem利用波分复用的方法将信道分为上行信道和下行信道 802.11a将传输速率提高到11Mbps ADSL技术具有非对称带宽特征 点击查看解析 EPON是一种光纤接入技术，故A选项错误；Cable Modem利用的是频分复用的方法将信道分为上行信道和下行信道，故B选项错误；IEEE 802.11b最高的传输速率是11Mbit/s，802.11a最高的速率是54Mbit/s，故C选项错误。 非对称数字用户线ADSL技术特点（上行速率在64-640Kbps，下行速率在500Kbps-7Mbps","categories":[{"name":"计算机三级","slug":"计算机三级","permalink":"https://imqinhao.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/"}],"tags":[]},{"title":"构建宽带城域网的基本技术与方案","slug":"build-MAN-idea","date":"2020-04-24T04:12:12.000Z","updated":"2021-07-17T02:35:30.268Z","comments":true,"path":"2020/04/24/build-MAN-idea/","link":"","permalink":"https://imqinhao.cn/2020/04/24/build-MAN-idea/","excerpt":"基于10GE技术的宽带城域网 基于弹性分组环技术的宽带城域网","text":"基于10GE技术的宽带城域网 基于弹性分组环技术的宽带城域网 基于10GE技术的宽带城域网光以太网是以太网与DWDM技术相结合的产物，可运营光以太网的设备和线路必须符合电信网络99.999%的高运行可靠性，并具备以下特征： ①能够根据终端用户的实际应用需求分配带宽，保证带宽资源充分、合理地应用。 ②县有认证与授权功能，用户访问网络资源必须经过认证和授权，确保用户和网络资源的安全及合法使用。支持VPN和防火墙，可以有效地保证网络安全。 ③支挂MPLS（多协议标签交换），县有一定的服务质量保证，提供分等级的QoS网络服务。 ④提供计费功能，能及时获得用户的上网时间记录和流量记录，支持按上网时间、用户流量计费，或提供包月计费方式，支持实时计费。 ⑤能够方便、快速、灵活地适应用户和业务的拓展。 真考试题下列关于光以太网在宽带城域网应用的描述中，错误的是（ ） 光以太网设备与线路符合电信网络99.99%的高运行可靠性 能根据用户需求动态分配带宽 具有认证与授权功能 具有认证与授权功能 解析：光以太网设备与线路符合电信网络99.999%的高运行可靠性，故A选项错误。 下列关于光以太网技术特征的描述中，错误的是（ ）。 能够根据用户的需求分配带宽 以信元为单位传输数据 具有保护用户和网络资源安全的认证与授权功能 提供分级的QoS服务 解析：光以太网以光信号为单位来传输数据，以信元为单位传输数据的是ATM网。 基于弹性分组环技术的宽带城域网 RPR采用双环结构，有内环和外环，两个RPR结点之间的裸光纤的最大长度达到100km，两环均有实现“自愈环”的功能，均可以传输数据分组与控制分组，且可用统计时分多路复用的方法传输IP分组。 内环的传输方向是逆时针，外环的传输方向是顺时针。 特点特点1 公平性好 点击查看详情 RPR环中每个结点都执行SRP公平算法，使得结点之间能够获得平等的带宽，防止个结点因流量过大而造成环拥塞。同时，RPR环还支持加权公平法则和入口、出口峰值速率限制，用以保证能够根据用户购买的带宽提供相应的服务。 特点2 带宽的利用率高 点击查看详情 RPR采用双环结构传输数据分组和控制分组，并限制数据帧只在源结点与目的结点之间的光纤段上传输，当源结点成功地发送一个数据帧之后，这个数据帧要由目的结点从环中收回。如此，该数据帧将不再占用下游段的环带宽，从而提高了环带宽的利用率。 特点3 保证服务质量 点击查看详情 RPR环对不同的业务数据分配不同的优先级，以保证高优先级信息的可靠传输，从而保证了网络的服务质量。 特点4 快速保护和恢复能力强大 点击查看详情 RPR有自愈环的功能，能够在50ms时间内，隔离出现故障的节点和光纤段，并可在没有专用带宽的前提下就能够提供SDH级的快速保护和恢复。 真考试题下列关于RPR技术的描述中，正确的是（ ）。 RPR的内环与外环都可以传输数据分组与控制分组 RPR环将沿顺时针方向传输的光纤环叫做内环 RPR环中每一个节点都执行DPT公平算法 RPR环能够在100ms内实现自愈 解析：B选项RPR环将沿顺时针方向传输的光纤环叫做外环，逆时针方向传输的光纤环叫作内环，故B选项错误；C选项RPR环中每一个节点都执行SRP公平算法，故C选项错误；D选项RPR环能够在50ms内实现自愈，故D选项错误。A选项两环均有实现“自愈环”的功能，均可以传输数据分组与控制分组，且可用统计时分多路复用的方法传输IP分组。故A选项正确。 下列关于RPR技术的描述中，正确的是（ ）。 RPR能够在30ms内隔离出现故障的节点和光纤段 RPR环中每一个节点都执行DPT公平算法 两个RPR节点之间的裸光纤最大长度为30公里 RPR的内环与外环都可以传输数据分组与控制分组 解析：A选项RPR能够在50ms内隔离出现故障的节点和光纤段，故A选项错误；B选项RPR环中每一个节点都执行SRP公平算法，并不是DPT算法，故B选项错误；C选项两个RPR节点之间的裸光纤最大长度为100公里，故C选项错误。","categories":[{"name":"计算机三级","slug":"计算机三级","permalink":"https://imqinhao.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/"}],"tags":[]},{"title":"TD-LTE系统概述","slug":"TD-LTE-System","date":"2020-04-20T12:11:00.000Z","updated":"2021-07-17T02:51:29.936Z","comments":true,"path":"2020/04/20/TD-LTE-System/","link":"","permalink":"https://imqinhao.cn/2020/04/20/TD-LTE-System/","excerpt":"了解LTE的系统架构 理解TD-LTE的三个核心技术 掌握物理层帧结构 了解LTE的演进过程","text":"了解LTE的系统架构 理解TD-LTE的三个核心技术 掌握物理层帧结构 了解LTE的演进过程 123452G的多址方式重点突出的是TDMA（时分多址）3G的多址方式重点突出的是CDMA（码分多址）3.9&#x2F;4G的多址方式重点突出的是OFDMA（正交频分多址） 3G各种制式峰值速率及小区吞吐量 制式 峰值速率 小区吞吐量 WCDMA 5.76/14.4Mbps 1.5/3Mbps TD-SCDMA 0.55/1.68Mbps 0.36/1Mbps CDMA 2000 1.8/3.1Mbps 0.4/0.8Mbps 3.9G各种制式峰值速率 制式 上行峰值速率（20MHz） 下行峰值速率（20MHz） FDD 50Mbps 150Mbps TDD 10Mbps 110Mbps 14G峰值速率：500M～1Gbps 4G出现之前为什么会出现3.9G？ 解析：4G在研发的过程当中遇到了一个大的竞争对手WiMAX，WiMAX主要研发的是在一个比较宽的带宽里面如何能够做到城市里面的用户移动化的去进行系统的应用。为了缓解一个较大的冲击，所以3GPP从4G研发过程当中抽身推出了3.9G。 同样是LTE的系统，为什么FDD的峰值速率比TDD的峰值速率要高呢？ 1231、FDD是上下行对称的，TDD上下行是非对称的2、TDD有SA和SSP设置，FDD没有。 1峰值速率要求：20M带宽下，下行速率能够达到100Mbps，上行速率能够达到50Mbps。 1控制面的延迟从驻留状态到激活状态下的延迟需低于100ms。 想要给用户带来更好的体验，需要从以下两点来考虑： 速率： $$C = B·log_2（1+\\frac{S}{N})$$ 1234B：信道带宽S：信号的平均功率N：噪声平均功率S&#x2F;N：信噪比 提高用户速率有两种方法： 提高带宽（B），2G系统里面带宽为200KHz，3G（TD-SCDMA）固定的带宽为1.6MHz，4G（LTE）最高可以达到20MHz。 提高信噪比，即降低干扰，降低干扰有很多方式，例如MIMO技术的波束赋形。 降低时延。 什么是LTE？ LTE是Long Term Evolution的缩写，即长期演进。 LTE是3GPP制定的下一代无线通信标准。 TD-LTE是LTE的TDD模式。 LTE是以OFDMA为核心的技术，为了降低用户面的延迟，取消了无线网络控制器（RNC），采用了扁平网络架构。 LTE有两种双工方式：TDD（TD-LTE）和FDD（LTE FDD）。 FDD（频分双工）：上行和下行是不同的频段。 TDD（时分双工）：上行和下行共享同一个频段。 4G技术的特点：大带宽，高速率。 4G网络与3G网络的区别？ 核心网只有PS域 控制与承载相分离应用于PS域中： 系统容量和性能需求 名称 需求 峰值数据率 20MHz系统带宽下，下行瞬间峰值速率100Mbps（频谱效率2.5bps/Hz），上行瞬间峰值速率50Mbps（频谱效率2.5bps/Hz） 控制面延迟 从驻留状态转换到激活状态的时延小于100ms。从睡眠状态转换到激活状态的时延小于50ms。 用户面延迟 零负载（单用户/单数据流），小IP分组条件下时延小于5ms。 控制面容量 每个小区在5MHz带宽下最少支持200个用户。 用户吞吐量 下行每兆赫兹平均用户吞吐量为R6 HSDPA的3～4倍；上行每兆赫兹平均用户吞吐量为R6 HSUPA的2～3倍。 频谱效率 在真实负载的网络中，下行频谱效率为R6 HSPDA的3～4倍；上行频谱效率为R6 HSUPA的2～3倍。 UE的两种状态12Idle态：RRC建立连接没有成功，则处于Idle态。connected态：RRC连接成功，UE就会进入连接态。 系统部署和无线资源管理需求频谱灵活性：支持不同大小的频带尺寸，从1.4～20MHz。 与3GPP无线接入技术的共存和互操作：和GERAN/UTRAN系统可以邻频共站址共存；支持UTRAN/GERAN操作的E-UTRAN终端应支持对UTRAN/GERAN的测量，以及E-UTRAN和UTRAN/GERAN之间的切换。实时业务在E-UTRAN和UTRAN/GERAN之间的切换中断时间小于300ms。 系统架构和演进：单一基于分组的E-UTRAN系统架构，通过分组架构支持实时业务和会话业务最大限度的避免淡点失败；支持端到端QoS，优化回转通信协议。 无线资源管理：增强的端到端QoS；有效支持高层传输；支持不同的无线接入技术之间的负载均衡和政策管理。 TD-LTE核心技术MIMO技术多进多出（MIMO）是为极大地提高信道容量，在发送端和接收端都使用多根天线，在收发之间构成多个信道的天线系统。MIMO系统的一个明显特点就是具有极高的频谱利用效率，在对现有频谱资源充分利用的基础上通过利用空间资源来获取可靠性与有效性两方面增益，其代价是增加了发送端与接收端的处理复杂度。大规模MIMO技术采用大量天线来服务数量相对较少的用户，可以有效提高频谱效率。 扁平网络删除了RNC网络单元，网络组成减少，时延就降低了。 频分多址系统OFDMA技术与OFDM技术相比，每个用户可以选择信道条件较好的子信道进行数据传输，而不像OFDM技术在整个频带内发送，从而保证了各个子载波都被对应信道条件较优的用户使用，获得了频率上的多用户分集增益。在OFDMA中，一组用户可以同时接入到某一信道。 干扰抑制技术ICIC小区在进行同频组网的过程中，不同的小区之间可以通过信息的交互来了解到这些同频资源当中哪些资源收到的干扰较高，那么在本小区进行资源分配的时候尽量避开这些高干扰的资源，从而降低小区间的干扰来提高用户的感知。 E-UTRAN扁平网络架构 取消RNC（中央控制节点），只保留一层RAN节点——eNodeB NodeB和核心网采用基于IP路由的灵活多重连接——S1-flex接口 相邻eNodeB采用Mesh连接——X2接口 扁平网络架构，减少设备投入 减少接口数量，IP的网络接口 增强的端对端QoS UE：终端 eNodeB：LTE系统中基站称之为eNodeB NodeB：3G里面基站称之为NodeB E-UTRAN：基站之间构成了一个网络，称之为无线接入网（E-UTRAN） EPC：核心分组网演进，4G的核心网 LTE网元功能eNodeB具有现3GPP NodeB全部和RNC大部分功能，包括： 物理层功能 MAC，RLC，PDCP功能 RRC功能 资源调度和无线资源管理 无线接入控制 移动性管理 MME NAS信令以及安全性功能 3GPP接入网络移动性导致的CN节点间信令 空闲模式下UE跟踪和可达性 漫游 鉴权 承载管理功能（包括专用承载的建立） SGW 支持UE的移动性切换用户面数据的功能 E-UTRAN空闲模式下行分组数据缓存和寻呼支持 数据包路由和转发 上下行传输层数据包标记 PGW 基于用户的包过滤 合法监听 IP地址分配 上下行传输层数据包标记 DHCPv4和DHCPv6（client，relay，server） LTE各种接口协议 承载用户业务分类 话音类业务：例如打电话，此类业务时延要求高 交互类：例如网络游戏，此类业务对丢包率要求很高 流类：例如视频点播下载 背景类：例如收发电子邮件，此类业务对丢包率要求很高 E-UTRANeNodeB功能划分 PHY（物理层）：负责处理编译码、调制解调、多天线映射以及其它电信物理层功能。物理层以传输信道的方式为MAC层提供服务。 MAC（媒体接入控制层）：负责处理HARQ重传与上下行调度。MAC层将以逻辑信道的方式为RLC层提供服务。 RLC（无线链路控制层）：负责分段与连接、重传处理，以及对高层数据的顺序传送。与UMTS系统不同，LTE系统的RLC协议位于eNodeB，这是因为在LTE系统对无线接入网的架构进行了扁平化，仅仅只有一层节点eNodeB。RLC层以无线承载的方式为PDCP层提供服务，其中，每个终端的每个无线承载配置一个RLC实体。 PDCP：提供加密和完整性保护功能。负责执行头压缩以减少无线接口必须传送的比特流量。头压缩机制基于ROHC，ROHC是一个标准的头压缩算法，已被应用于UMTS及多个移动通信规范中。PDCP层同时负责传输数据的加密和完整性保护功能；在接收端，PDCP协议将负责执行解密及解压缩功能。对于一个终端每个无线承载有一个PDCP实体。 RRC：RRC层协议终止于eNodeB，主要提供广播、寻呼、RRC连接管理、无线承载（RB）控制、移动性管理、UE测量上报和控制等功能。 动态资源分配（调度集） eNodeB测量配置与提供 无线许可控制 连接移动性控制 无线承载控制 小区间RRM EPCMME主要功能 NAS安全性 Idle状态移动性管理 EPS承载控制 SGW主要功能 移动性锚定 PGW主要功能 UE IP地址分配 包过滤","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"管理和运营宽带城域网的关键技术","slug":"manage-MAN-skill","date":"2020-04-13T11:46:11.000Z","updated":"2021-07-17T02:43:40.286Z","comments":true,"path":"2020/04/13/manage-MAN-skill/","link":"","permalink":"https://imqinhao.cn/2020/04/13/manage-MAN-skill/","excerpt":"网络管理 QoS 用户管理 IP地址分配与地址转换","text":"网络管理 QoS 用户管理 IP地址分配与地址转换 网络管理 带内网络管理是指利用传统的电信网络，通过数据通信网（DCN）或公共交换电话网（PSTN）拨号，对网络设备进行数据配置 带外网络管理是指利用IP网络及协议进行网络管理，是利用简单网络管理协议（SNMP）建立网络管理系统。 对汇聚层以下采用带内管理，而对汇聚层及其以上设备采取带外管理。 真考试题下列关于宽带城域网网络管理的描述中，错误的是（ ）。 A. 利用传统电信网进行的网络管理称为”带内”管理 B. 利用IP协议进行的网络管理称为“带外”管理 C. 带内管理使用的是SNMP协议 D. 汇聚层以下采用带内管理 12答案：C解析：带外管理使用的是SNMP协议，故C选项错误。 QoS 在宽带城域网业务中有多媒体业务、数据业务与普通的语音服务；网络服务质量表现在延时、抖动、吞吐量和丢包率等几个方面。 目前宽带城域网保证QoS要求的技术主要有：资源预留（RSVP）、区分服务（DiffServ）与多协议标记交换（MPLS）。 真考试题 下列技术中，不属于宽带城域网QoS保证技术的是（ ）。 A. DiffServ B. MPLS C. MTBF D. RSVP 12答案：C解析：MTBF是平均无故障时间，不属于QoS保证技术。 下列关于宽带城域网技术的描述中，错误的是（ ）。 A. 网络业务包括多媒体、数据与语音业务。 B. 网络服务质量表现在延时、抖动、吞吐量与丢包率 C. 网络服务质量保障技术主要有RSVP、DiffServ与MPLS D. 网络采用IP网络的带内管理 12答案：D解析：采用IP网络的是带外管理，故D选项错误。 用户管理宽带城域网的用户管理应该包括用户认证与接入管理、计费管理等，能够为用户提供带宽保证，实现流量工程。 IP地址分配与地址转换为了解决IP地址不足的问题，目前的基本方案是使用内部专用IP地址与网络地址转换（NAT）技术，只为宽带城域网的关键设备与特殊用户分配固定的公网IP地址。 真考试题下列关于宽带城域网技术的描述中，错误的是（ ）。 A. 宽带城域网保证QoS的主要技术有RSVP、 DiffServ和MPLS B. 宽带城域网带内网络管理是指利用网络管理协议SNMP建立网络管理系统 C. 宽带堿堿网能够为用户提供带宽保证，实现流量工程 D. 宽带城域网可以利用NAT技术解决IP地址资源不足的问题 12答案：B解析：带外管理是指利用网络管理协议SNMP建立网络管理系统，带内管理通过数据通信网（DCN）或公共交换电话网（PSTN）拨号，对网络设备进行数据配置，故B选项错误。 易错提示要熟练掌握”带内” ”带外“ 的概念，差异化记忆。","categories":[{"name":"计算机三级","slug":"计算机三级","permalink":"https://imqinhao.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/"}],"tags":[]},{"title":"宽带城域网的结构","slug":"structure-of-MAN","date":"2020-04-13T01:46:11.000Z","updated":"2021-07-17T02:49:55.896Z","comments":true,"path":"2020/04/13/structure-of-MAN/","link":"","permalink":"https://imqinhao.cn/2020/04/13/structure-of-MAN/","excerpt":"常考知识点： 宽带城域网的结构 管理和运营宽带城域网的关键技术 构建宽带城域网的基本技术与方案 网络接入技术与方法","text":"常考知识点： 宽带城域网的结构 管理和运营宽带城域网的关键技术 构建宽带城域网的基本技术与方案 网络接入技术与方法 宽带城域网的逻辑结构完整的宽带城域网主要包括网络平台、业务平台、管理平台3个平台与城市宽带一个出口。 宽带城域网网络平台各层的主要功能核心交换层的基本功能 核心交换层将多个汇聚层连接起来，为汇聚层的网络提供高速转发，为整个城域网提供一个高速、安全与具有QoS保障能力的数据传输环境。 核心交换层实现与主干网络的互联， 提供城市的宽带IP数据出口。 核心交换层提供宽带城域网的用户访问Internet所需要的路由服务。 汇聚层的基本功能 汇聚接入层的流量，进行数据分组传输的汇聚、转发与交换。 根据汇聚接入层的用户流量，进行本地路由、过滤、流量均衡、QoS优先级管理，以及安全控制、IP地址转换、流量整型等处理。 根据处理结果把用户流量转发到核心交换机或本地进行路由处理。 接入层的基本功能 接入层解决的是“最后一公里”问题。通过各种接入技术，连接最终用户，为它所覆盖范围内的用户提供访问Internet以及其它的信息服务。 三层结构思想上层负责下层的数据汇聚；核心层提供出口与QoS、汇聚本地路由，接入服务用户。 真考试题[单选] 下列关于宽带城域网核心交换层特点的描述中，正确的是（ ）。 A. 将多个接入层连接起来 B. 根据接入层的用户流量进行本地路由、过滤、流量均衡 C. 提供城市的宽带IP数据出口 D. 解决“最后一公里”问题 12答案：C解析：A选项将多个接入层连接起来的是汇聚层而不是核心交换层，故A选项错误；B选项根据接入层的用户流量进行本地路由、过滤、流量均衡的是汇聚层，故B选项错误；D选项解决“最后一公里”的是接入层的任务，故D选项错误。核心交换层实现与主干网络的互联， 提供城市的宽带IP数据出口，故C选项正确。 [单选] 下列关于宽带城域网汇聚层基本功能的描述中，错误的是（ ）。 A. 提供用户访问Internet所需要的路由服务 B. 根据处理结果把用户流量转发到核心交换机 C. 汇聚接入层的用户流量，进行数据转发与交换 D. 根据接入层的用户流量，进行流量均衡、安全控制等处理 12答案：A解析：提供用户访问Internet所需要的路由服务是核心层的基本功能，故A选项错误。 易错提示要熟练掌握每个网络平台各层的主要功能，差异化的记忆。 宽带城域网网络平台的核心层主要承担高速数据交换的功能，汇聚层主要承担路由与流量汇聚的功能，接入层主要承担用户接入与本地流量控制的功能。","categories":[{"name":"计算机三级","slug":"计算机三级","permalink":"https://imqinhao.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/"}],"tags":[]},{"title":"5G无线网络架构演进","slug":"wireless_framework","date":"2020-04-09T03:25:00.000Z","updated":"2021-07-17T02:52:22.938Z","comments":true,"path":"2020/04/09/wireless_framework/","link":"","permalink":"https://imqinhao.cn/2020/04/09/wireless_framework/","excerpt":"了解移动通信网络发展 熟悉接入网架构演进策略 熟悉5G网元接口功能 掌握5G组网特性与应用","text":"了解移动通信网络发展 熟悉接入网架构演进策略 熟悉5G网元接口功能 掌握5G组网特性与应用 移动通信发展历程移动通信标准发展历程 RAN网络架构变迁 3G-4G的演进 4G-5G的演进 5G接入网架构演进 123演进G的gNB，也可以是LTE eNB升级后的ng-eNB。采用gNB与5GC组网时，对应架构Option 2。将LTE eNB需升级到ng-eNB后连接到5G核心网，对应架构Option 5。对于拥有较丰富、优质的Sub-6GHz频谱资源作为覆盖，同时又有足够的高频频谱资源来增强容量的运营商，选择Option 2独立组网是一个比较好的选择。 14G基站（eNB）和5G基站（gNB）公用4G核心网（EPC），LTE eNB和5G gNB用户面可以直接连接到EPC，控制面则仅经由LTE eNB连接到EPC。用户面可以分别经由LTE eNB、EPC或者gNB进行分流。优势在于不需要新增5G核心网，利用运营商现有4G网络基础设施快速部署5G，抢占覆盖和热点。但是5G信令全走4G通道，有4G核心网信令过载风险，因此该阶段主要解决初期的5G覆盖。 组网部署方式比较和运营商选择 5G接入网方案部署 CU-DU划分 CU-DU方案策略比较 5G基站部署 5G传输部署 5G网元与接口功能5G接入网架构概述 4G/5G共核心网网元与接口 网元功能-UPF 网元功能-SMF 网元功能-AMF 网元功能-gNB/en-gNB 接口概述-NG NG接口协议-总览 接口NG-C协议与功能 接口NG-U协议与功能 接口概述-Xn1接口定义：ng-eNB&#x2F;gNB与ng-eNB&#x2F;gNB之间的接口 Xn接口协议-总览 接口Xn-U协议与功能 接口概述-F11接口定义：gNB-CU与gNB-DU之间的接口，包括F1-C和F1-U。 F1接口协议-总览 接口F1-C协议与功能 接口F1-U协议与功能 接口概述-E11接口定义：gNB-CU-CP与gNB-CU-UP之间的接口，目前只有E1-C接口。 接口E1-C协议与功能 接口概述-Radio UU1接口定义：UE与gNB及网络之间的接口。 Radio UU口控制面协议栈 5G无线组网与应用C-RAN概念演进1C-RAN的概念：“Centralization，Collaborative，Cloud，Clean”无线接入云网络架构。 C-RAN推进目标根据工作内容的独立性，可分为5个具体的工作组： C-RAN部署的三种方式根据不同的业务和部署场景，C-RAN的架构总体可以分为CU和DU两级，但是实际部署可以出现CU、DU和RRU分离的三级配置，也可以出现RRU直接连入中心节点。 C-RAN场景部署-eMBBCase 1：基于多连接的部署用于网络容量和覆盖的提升。 1234典型的部署场景包括：·一个宏站覆盖一个宏小区，一个微站覆盖一个微小区，一个宏站可以连接一个或多个微站。宏微小区可以同频或者异频。·对于宏基站，DU和AAU通常分离，但对于微站，DU和AAU可以分离也可以集成在一起；·对于宏站，CU、DU可以部署在一起，对于微站，CU和DU的连接一般需要专门的fronthaul连接，根据具体的技术应用对fronthaul的时延有不同的需求，如果无线承载需要合并，则时延要求一般小于5ms，否则需求可以放松一些。 Case 2：基于基站协同管理的服务与小区间干扰协调和高密度业务的需求 1234相关的部署需求包括：·所有AAU需要和DU池通过直接光纤或高速传输网络连接，时延要求一般在微秒量级。·DU池支持的小区数目可以达到数十至数百个。·CU和DU的连接一般通过传输网络，时延要求则没有RU和DU的fronthaul连接严格。 Case 3：基于时延差异性的部署优化 12·高实时大带宽的业务如视频和虚拟现实业务：为了保证高效的时延控制，需要高速传输网络或光纤直连AAU，数据统一传输到中心机房进行处理，减少中间的流程，同时DU和CU则可以部署在同一位置，网络实体则合而为一。·低实时语音等一般业务：在这种场景下，带宽和实时性要求不高，实时功能DU可以部署在站点侧，多个DU通过fronthaul连接到一个CU，非实时功能CU可以部署在中心机房。 C-RAN场景部署-mMTCCase：垂直行业和机器通信需求-物联网的集中化管控 1物联网的集中化管控：可以让多个DU或者AAU连接到一个CU，由CU进行区域物联网的集中管控。由于物联网业务实时性要求不高，可以将CU和核心网进行共平台部署，减少无线网和核心网的信令的交互，减少机房的数量。 C-RAN场景部署-uRLLCCase：低时延高可靠需求-车联网 123·基于高实时通信的自动驾驶：将RAN的实时处理DU和非实时处理功能单元CU部署在更加靠近用户的位置，并配置相应的服务器和业务网关，进而满足特定的时延和可靠性需求。·基于高可靠需求的公共安全应急通信：在涉及到公共安全的通信业务时，通常需要高可靠性，一般采取广播方式，多小区传送相同信息，因此多个DU需要连接相同的CU做重复的数据传输。·高移动性的业务支持：当UE处于高速移动时，比如在无人机控制场景，为了减少切换，可以让多个DU共享一个逻辑小区，CU对这个逻辑小区做集中控制，在DU间移动无需切换。 C-RAN场景部署总结基于网络切片的三大场景部署 1234从功能上,实时处理单元和非实时处理单元需要各有分工从实体上,RRU冋以部分和DU耦合,DU也可以和CU耦合,实现部分功能的转移从部署上,RRU、DU、CU的地理位置可以灵活部署从对业务的支持上,必须种统的架构去满足eMBB,MTC,URL等不同的业务特点","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"色彩基础","slug":"color","date":"2020-04-04T05:06:11.000Z","updated":"2021-07-17T02:38:10.213Z","comments":true,"path":"2020/04/04/color/","link":"","permalink":"https://imqinhao.cn/2020/04/04/color/","excerpt":"色彩的产生 色光 固有色 RGB模式 色彩三要素 HSB取色 CMYK模式","text":"色彩的产生 色光 固有色 RGB模式 色彩三要素 HSB取色 CMYK模式 色彩的产生光是一种电磁波，人可以识别的电磁波波长是770-350nm之间。高于770的是红外线，低于350的是紫外线。 人眼能看到的波段：可见光。 光源光1太阳，电灯，显示屏，RGB模式。 反射光1234月亮，不发光物，CMYK模式。光滑表面形成直反射：镜子。粗糙表面形成漫反射：各种物 单色光1单色光：三基色光（红Red，绿Green，蓝Blue），一切色彩的基础。 复合光1复合光：色光融合，太阳光等其它可见光。 固有色1物体反射到人眼的常态日光，形成人对物体常态的颜色认知。 光源色1物体反射到人眼的目标光源光线，形成人对物体当前状态的颜色认知。 在RGB原色通道里，填充白色，即为本色光最强的发光。 吸管工具与颜色面板123快捷键：I，用于拾取色彩色值。吸管直接生成前景色；按住Alt键吸取，生成背景色。 RGB色值表达方式1234红色的RGB色值是255.0.0黑色的RGB色值是0.0.0绿色的RGB色值是0.255.0蓝色的RGB色值是0.0.255 在RGB通道创建色彩 123红色 + 绿色 &#x3D; 黄色红色 + 蓝色 &#x3D; 品红绿色 + 蓝色 &#x3D; 青色 色彩三要素色相123456色相：颜色的品相。15°范围内叫作同类色。45°范围内叫作邻近色。120°范围内叫作对比色。180°范围内叫作补色。 饱和度123饱和度是色彩的鲜艳程度，其实就是加入中性灰的程度。调整饱和度命令，可以看做是增减中性灰的操作。 明度1调整明度，就是调节发光量，加入额外的白光。 取色模式可以选择HSB，RGB，LAB，CMYK，WEB模式。 CMYK模式123456印刷色彩模式。C：青色M：品红Y：黄色K：黑色 123CMYK通道里，黑色代表100%浓度的油墨。CMYK靠百分比来表达当前通道的色值。 123456789RGB是加色模式，CMYK是减色模式。制作印刷类图像，不要使用RGB模式，否则成品会偏色。拾色器会对超出印刷色域的颜色做警告，并可以自动修复。","categories":[{"name":"Photoshop","slug":"Photoshop","permalink":"https://imqinhao.cn/categories/Photoshop/"}],"tags":[]},{"title":"图层进阶知识","slug":"Layer","date":"2020-04-03T06:00:00.000Z","updated":"2021-07-17T02:42:54.383Z","comments":true,"path":"2020/04/03/Layer/","link":"","permalink":"https://imqinhao.cn/2020/04/03/Layer/","excerpt":"图层链接 图层编组 图层剪贴蒙版","text":"图层链接 图层编组 图层剪贴蒙版 图层的锁定锁定透明像素1禁止对透明区域进行操作。 锁定图像像素1禁止编辑图像，但可以移动变换。 锁定位置1禁止移动变换。 锁定全部1禁止一切操作。 隐藏图层也可以保护图层编辑。 图层链接图层链接可以多图层统一移动变换。 按住Shift键点击链接图标可以临时停用链接。再次按住Shift键点击链接图标可以取消临时停用链接。 图层链接后统一移动变换，但图层仍属独立编辑。 图层整合形式图层整合以后，图层群们是否具有统一的操作属性，详见此表： 图层编组1图层编组可以整合管理，并具有多种统一属性。 选中要加入组的图层，按住Shift键，点击创建新组按钮，即可将选择的图层加入到组中。 创建空白组1选择【图层】--&gt;【新建】--&gt;【组】，弹出【创建组】对话框。 123名称：可根据需求随意填写。颜色：组在图层栏里面的颜色标记。模式：默认为穿透模式，一般不需要更改。 从图层创建组1选择【图层】--&gt;【新建】--&gt;【从图层创建组】，弹出【从图层创建组】对话框。 快捷键12常用的编组快捷键操作：Ctrl + G取消编组：Ctrl + Shift + G 图层拼合1Ctrl + E，Ctrl + Alt + E，图层合并命令简介。 盖印图层12345所有可见图层拼合效果的新图层。快捷键：Ctrl + Shift + Alt + E盖印选择图层快捷键：Ctrl + Alt + E 图层复合1保存当前图层的位置，可见性，样式信息。 图层剪贴蒙版123上方图层进入下方图层形状。快捷键：Ctrl + Alt + G","categories":[{"name":"Photoshop","slug":"Photoshop","permalink":"https://imqinhao.cn/categories/Photoshop/"}],"tags":[]},{"title":"centOS 7搭建Bitwarden密码服务器","slug":"bitwarden","date":"2020-03-31T05:04:14.000Z","updated":"2021-07-17T02:35:19.118Z","comments":true,"path":"2020/03/31/bitwarden/","link":"","permalink":"https://imqinhao.cn/2020/03/31/bitwarden/","excerpt":"您可以在Windows，macOS和Linux发行版上使用Docker容器部署Bitwarden。使用提供的PowerShell和Bash脚本快速入门。在Docker Hub上找到所有Bitwarden映像。","text":"您可以在Windows，macOS和Linux发行版上使用Docker容器部署Bitwarden。使用提供的PowerShell和Bash脚本快速入门。在Docker Hub上找到所有Bitwarden映像。 安装Docker 安装所需的软件包。yum-utils提供了yum-config-manager 效用，并device-mapper-persistent-data和lvm2由需要 devicemapper存储驱动程序。 123$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 2.使用以下命令来设置稳定的存储库。 123$ sudo yum-config-manager \\ --add-repo \\ https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo 3.安装最新版本的Docker Engine-Community和containerd，或者转到下一步安装特定版本： 1$ sudo yum install docker-ce docker-ce-cli containerd.io 如果提示您接受GPG密钥，请验证指纹是否匹配 060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35，如果是，则接受它。 4.启动Docker。 1$ sudo systemctl start docker 5.设置开机自启动。 1$ sudo systemctl enable docker 安装Docker Compose1.运行以下命令以下载Docker Compose的当前稳定版本： 1sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.25.4&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose 2.将可执行权限应用于二进制文件： 1sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose 注意：如果命令docker-compose在安装后失败，请检查路径。您也可以创建指向/usr/bin或路径中任何其他目录的符号链接。 例如： 1sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose &#x2F;usr&#x2F;bin&#x2F;docker-compose 3.测试安装： 12$ docker-compose --versiondocker-compose version 1.25.4, build 1110ad01 安装Bitwarden12345curl -s -o bitwarden.sh \\ https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;bitwarden&#x2F;server&#x2F;master&#x2F;scripts&#x2F;bitwarden.sh \\ &amp;&amp; chmod +x bitwarden.sh.&#x2F;bitwarden.sh install.&#x2F;bitwarden.sh start","categories":[{"name":"Linux","slug":"Linux","permalink":"https://imqinhao.cn/categories/Linux/"}],"tags":[]},{"title":"GRE over IPSec VPN配置练习","slug":"GRE-over-IPSec","date":"2020-03-30T08:30:11.000Z","updated":"2021-07-17T02:40:31.755Z","comments":true,"path":"2020/03/30/GRE-over-IPSec/","link":"","permalink":"https://imqinhao.cn/2020/03/30/GRE-over-IPSec/","excerpt":"GRE over IPSec VPN配置练习 软件：Cisco Packet Tracer","text":"GRE over IPSec VPN配置练习 软件：Cisco Packet Tracer 实验网络拓扑图如图所示，在总公司和分公司的边界路由器上做GRE over IPSec VPN，实现两地内部网络私有地址之间可以安全通信。1、基础配置如下： (1)按图中所示配置总公司和分公司中各计算机、服务器、路由器对应端口的IP地址相关信息； (2)在Router0和Router1上配置一条默认路由，实现Internet间互通 (3) 测试Router0和Router1的公网地址间的互通性2、在总公司与分公司之间配置GRE隧道技术（1）在Router0和Router1上配置 GRE VPN （tunnel号为1，地址分别为10.1.1.1/30和10.1.1.2/30）（2）测试tunnel地址之间的互通性3、在总公司与分公司之间配置IPsec VPN，对GRE tunnel数据进行加密。（1） 配置 IKE（ISAKMP）策略：策略序号为1，加密算法为aes，Hash 算法为MD5，密钥算法（Diffie-Hellman）为group 2，认证方式（Authentication）为pre-share。（2）定义认证标识：预共享密码为tx18（3）配置 IPsec transform：定义transform set命名为tx18set，加密算法为esp-3des， HMAC 算法为esp-MD5-HMAC（4）定义感兴趣流量：用扩展acl 180来定义通过 VPN 传输的流量（5）创建 crypto map：定义transform set命名为tx18map，将之前定义的 ACL，加密数据发往的对端，以及 IPsec transform 结合在 crypto map中（6）将 crypto map 应用于对应接口在Router0和Router1上配置动态路由rip协议，实现总公司和分公司私网路由4、在Router0和Router1上配置动态路由ospf协议（进程号１，area 0），实现总公司和分公司私网路由5、测试PC0能否ping通PC5，为什么？6、分析GRE over IPSec VPN数据包，了解GRE over IPSec VPN数据封装格式7、选做：在公司边界路由器上做PAT，实现总公司和分公司的PC可以ping通公网PC 基础配置Router 0配置IP地址12345678910R0&gt; enableR0# config terminalR0(config)# interface fastEthernet 0&#x2F;0R0(config-if)# ip address 192.168.107.254 255.255.255.0R0(config-if)# no shutdown R0(config-if)# exitR0(config)# interface serial 0&#x2F;3&#x2F;0R0(config-if)# ip address 58.1.1.1 255.255.255.252R0(config-if)# no shutdown R0(config-if)# exit Router 1配置IP地址12345678910R1&gt; enableR1# config terminalR1(config)# interface fastEthernet 0&#x2F;0R1(config-if)# ip address 192.168.143.254 255.255.255.0R1(config-if)# no shutdown R1(config-if)# exitR1(config)# interface serial 0&#x2F;3&#x2F;0R1(config-if)# ip address 210.28.144.2 255.255.255.252R1(config-if)# no shutdown R1(config-if)# exit Router 2配置IP地址1234567891011R2&gt; enableR2# configure terminal R2(config)# interface serial 0&#x2F;1&#x2F;0R2(config-if)# ip address 58.1.1.2 255.255.255.252R2(config-if)# exitR2(config)# interface serial 0&#x2F;0&#x2F;0R2(config-if)# ip address 210.28.144.1 255.255.255.252R2(config-if)# exitR2(config)# interface fastEthernet 0&#x2F;0R2(config-if)# ip address 61.1.1.1 255.255.255.0R2(config-if)# exit Router 0配置默认路由1R0(config)# ip route 0.0.0.0 0.0.0.0 58.1.1.2 Router 1配置默认路由1R1(config)# ip route 0.0.0.0 0.0.0.0 210.28.144.1 Router 0和Router 1的公网地址互通性测试 GRE隧道配置Router 0配置GRE VPN1234R0(config)# interface tunnel 1R0(config-if)# ip address 10.1.1.1 255.255.255.252R0(config-if)# tunnel source serial 0&#x2F;3&#x2F;0R0(config-if)# tunnel destination 210.28.144.2 Router 1配置GRE VPN1234R1(config)# interface tunnel 1R1(config-if)# ip address 10.1.1.2 255.255.255.252R1(config-if)# tunnel source serial 0&#x2F;3&#x2F;0R1(config-if)# tunnel destination 58.1.1.1 测试tunnel间的互通性 IPSec配置Router 0配置IPSec123456789101112131415161718R0(config)#crypto isakmp policy 1R0(config-isakmp)#encryption aes R0(config-isakmp)#hash md5 R0(config-isakmp)#authentication pre-share R0(config-isakmp)#group 2R0(config-isakmp)#lifetime 86400R0(config-isakmp)#exitR0(config)#crypto isakmp key tx18 address 210.28.144.2R0(config)#crypto ipsec transform-set tx18set esp-3des esp-md5-hmac R0(config)#access-list 180 permit gre host 58.1.1.1 host 210.28.144.2R0(config)#crypto map tx18map 1 ipsec-isakmp R0(config-crypto-map)#match address 180R0(config-crypto-map)#set peer 210.28.144.2R0(config-crypto-map)#set transform-set tx18setR0(config-crypto-map)#exitR0(config)#interface serial 0&#x2F;3&#x2F;0R0(config-if)#crypto map tx18mapR0(config-if)#exit Router 1配置IPSec123456789101112131415161718R1(config)#crypto isakmp policy 1R1(config-isakmp)#encryption aes R1(config-isakmp)#hash md5 R1(config-isakmp)#authentication pre-share R1(config-isakmp)#group 2R1(config-isakmp)#lifetime 86400R1(config-isakmp)#exitR1(config)#crypto isakmp key tx18 address 58.1.1.1R1(config)#crypto ipsec transform-set tx18set esp-3des esp-md5-hmac R1(config)#access-list 180 permit gre host 210.28.144.2 host 58.1.1.1R1(config)#crypto map tx18map 1 ipsec-isakmp R1(config-crypto-map)#match address 180R1(config-crypto-map)#set peer 58.1.1.1R1(config-crypto-map)#set transform-set tx18set R1(config-crypto-map)#exitR1(config)#interface serial 0&#x2F;3&#x2F;0R1(config-if)#crypto map tx18mapR1(config-if)#exit Router 0配置OSPF协议1234R0(config)#router ospf 1R0(config-router)#network 192.168.107.10 0.0.0.255 area 0R0(config-router)#network 10.1.1.1 0.0.0.3 area 0R0(config-router)#exit Router 1配置OSPF协议1234R1(config)#router ospf 1R1(config-router)#network 192.168.107.0 0.0.0.255 area 0R1(config-router)#network 10.1.1.1 0.0.0.3 area 0R0(config-router)#exit PC 0 ping PC 5测试 1PC 0可以ping通PC 5，因为我们已经配置完成了GRE over IPSec VPN，包括OSPF和静态路由都已经配置完成，总公司和分公司的流量会通过隧道进行传输，所以PC 0可以ping通PC 5。 PAT配置Router 0配置PAT123456789R0(config)# interface FastEthernet0&#x2F;0R0(config-if)# ip nat insideR0(config-if)# exitR0(config)# interface Serial0&#x2F;3&#x2F;0R0(config-if)# ip nat outsideR0(config-if)# exitR0(config)# access-list 1 permit 192.168.107.0 0.0.0.255R0(config)# ip nat pool mypool 58.1.1.1 58.1.1.1 netmask 255.255.255.0R0(config)# ip nat inside source list 1 pool mypool overload Router 1配置PAT123456789R1(config)# interface FastEthernet0&#x2F;0R1(config-if)# ip nat insideR1(config-if)# exitR1(config)# interface Serial0&#x2F;3&#x2F;0R1(config-if)# ip nat outsideR1(config-if)# exitR1(config)#access-list 1 permit 192.168.143.0 0.0.0.255R1(config)#ip nat pool mypool 210.28.144.2 210.28.144.2 netmask 255.255.255.0R1(config)#ip nat inside source list 1 pool mypool overload 分析GRE over IPSec VPN数据包分析GRE over IPSec VPN数据包，了解GRE over IPSec VPN数据封装格式 ？ 1解析：我们用PC 0 ping PC5，观察Router 0的PDU，观察入站PDU可以看到，源IP地址为192.168.107.10，目的IP地址为192.168.143.10。观察出站PDU发现，最开始源IP地址和目的IP地址并未发生变化，通过GRE封装之后，加了IP头部，源IP地址为58.1.1.1，目的IP地址为210.28.144.2。然后经过了IPSec的加密，加了IP头部，源IP地址为58.1.1.1，目的地址为210.28.144.2。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://imqinhao.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"Photoshop修复工具的使用","slug":"FixedTools","date":"2020-03-29T06:37:11.000Z","updated":"2021-07-17T02:39:56.164Z","comments":true,"path":"2020/03/29/FixedTools/","link":"","permalink":"https://imqinhao.cn/2020/03/29/FixedTools/","excerpt":"模糊工具 图章工具 修复画笔工具 红眼工具","text":"模糊工具 图章工具 修复画笔工具 红眼工具 模糊工具12345模糊工具的主要功能就是把图像变得模糊。使用模糊工具可以把图像拉开空间、距离感。模糊工具是对所画目标区域进行模糊处理。模糊处理后容易营造出画面的空间、层次感。 模式1在对图像进行模糊的同时还可以通过模式改变对象颜色。 强度1强度值越大，模糊效果越大，反之越小。 对所有图层取样123对所有图层取样指的是可对所有可见图层进行模糊处理。勾选：&quot;对所有图层取样&quot;操作都会作用于目标图层上。 拓展1滤镜也可以制作模糊效果。 锐化1锐化工具作用与模糊工具对立，它可使图像变得锐利清晰。 保护细节1勾选“保护细节”可保护图像微小像素防止画面失真。 注意123使用模糊工具后会改变、损失很多原有像素信息，是无法通过锐化工具进行还原的。锐化工具是在图像现有像素基础上进行锐化的。 涂抹工具1涂抹工具和画笔工具用法一样：直接在画面上画就可以。 强度1涂抹强度值越高，涂抹效果越强。 手指绘画1勾选“手指绘画”可以绘制前景色，快捷键为Alt 减淡工具保护色调1保护色调可以保护图像在使用减淡时色调方面失真。 海绵工具1作用：局部增加饱和度或降低饱和度。 饱和度1简单理解就是：色彩的鲜艳程度。 降低饱和度1降低饱和度最终可使图像接近黑白。 仿制图章工具1234567锁定透明像素：禁止对透明区域进行操作。按住Alt键，光标变成靶心形状后代表可以寻找仿制源了。取样后就可以按照画笔用法来涂抹出仿制对象了。把仿制源文档删除后，仿制源也就不会存在了。 对齐12345“对齐”保证鼠标每次操作都与源点对齐且画出整片图像。勾选“对齐”可以松开鼠标，然后继续画。不勾选“对齐”每次松开鼠标之后会重新开始画。 样本12345当前图层：在本图层上点选仿制源，然后在本图层上进行仿制的操作。当前和下方图层：定义仿制源时只能选择当前图层以及下方图层图像为源。所有图层：可以定义画面上所有图像。 切换仿制源面板1234567891011121314151617通过仿制源面板可以对仿制源进行更多深层次的编辑。还可以在这里定义多个仿制源（最多5个）。“位移”参数记录仿制源位移的位置。设置宽(W)、高(H)参数可以仿制出放大缩小的仿制源图像。同理：设置角度也可以仿制出旋转一定角度后的图像。显示叠加：勾选会出现预览效果。已剪切：勾选状态下只能看到画笔区域里面的预览。 取消勾选会看到要仿制的整个画面的预览。 反向：勾选反向显示叠加里面就会以反向的形式出现。自动隐藏：勾选自动隐藏，仿制时就可以隐藏掉显示叠加的部分。 图案图章工具1图案图章工具用法就是直接在画面上画图案。 印象派效果1勾选“印象派效果”命令，就会绘画出印象派效果。 修复画笔工具1234567用法和仿制图章工具基本上是相同的。使用修复画笔工具后，边缘会有融合的效果。快捷键是J工具组里进行切换是Shift + J 源12取样：仿制图章工具。图案：图案图标，可以选择图案进行修补图案。 仿制图章工具与修复画笔工具的区别1234仿制图章可以跨文档继续进行。仿制图章进行的仿制是很严格的，画成什么样边缘就是怎么样。修复画笔有一定的智能性，可以和周围环境进行融合。 污点修复画笔工具1使用污点修复画笔工具在污点上点击、绘画就可以清除污点。 类型123近似匹配：计算较为简单，就近取样覆盖污点。创建纹理：在擦除污点同时创建出和周围相似的纹理效果。内容识别：是一种智能的识别方式，一般都会选择它。 修补工具1修补工具可以快速地对画面进行修复。 内容感知移动工具1内容感知移动工具比修补工具更加智能和简单。 模式12移动：代表的是移走拓展：代表的是复制 适应1在适应选项里决定了融合边缘程度的不同。 红眼工具123眼睛在补光灯作用下会扩张，而毛细血管就会呈现出红色。框选红眼区域，红眼就自动消失了。","categories":[{"name":"Photoshop","slug":"Photoshop","permalink":"https://imqinhao.cn/categories/Photoshop/"}],"tags":[]},{"title":"IPSec VPN配置练习","slug":"IPSec_VPN","date":"2020-03-25T04:30:11.000Z","updated":"2021-07-17T02:41:55.655Z","comments":true,"path":"2020/03/25/IPSec_VPN/","link":"","permalink":"https://imqinhao.cn/2020/03/25/IPSec_VPN/","excerpt":"IPSec VPN配置 软件：Cisco Packet Tracer","text":"IPSec VPN配置 软件：Cisco Packet Tracer 题目要求实验网络拓扑图如图所示 1、基础配置如下： (1)按图中所示配置总公司和分公司中各计算机、服务器、路由器对应端口的IP地址相关信息； (2)在Router0和Router1上配置一条默认路由，实现Internet间互通 (3) 测试Router0和Router1的公网地址间的互通性2、在总公司与分公司之间配置IPsec VPN，实现两地私有地址的内部网络之间可以实现相互通信。（1） 配置 IKE（ISAKMP）策略：策略序号为1，加密算法为aes，Hash 算法为MD5，密钥算法（Diffie-Hellman）为group 2，认证方式（Authentication）为pre-share。（2）定义认证标识：预共享密码为tx18（3）配置 IPsec transform：定义transform set命名为tx18set，加密算法为esp-3des， HMAC 算法为esp-MD5-HMAC（4）定义感兴趣流量：用扩展acl 180来定义通过 VPN 传输的流量（5）创建 crypto map：定义transform set命名为tx18map，将之前定义的 ACL，加密数据发往的对端，以及 IPsec transform 结合在 crypto map中（6）将 crypto map 应用于对应接口3、测试PC0能否ping通PC5，为什么？4、分析IPSec VPN数据包，了解IPSec VPN数据封装格式5、选做：在公司边界路由器上做NAT（数据自选），实现总公司和分公司的PC可以ping通公网PC 配置Router 0端口地址12345678910R0&gt; enable #进入特权模式R0# config terminal #进入全局模式R0(config)# interface FastEthernet 0&#x2F;0 #进入Fa0&#x2F;0端口R0(config-if)# ip address 192.168.123.254 255.255.255.0 #配置IP地址和子网掩码R0(config-if)# no shutdown #启用端口R0(config-if)# exit #退出Fa0&#x2F;0端口R0(config)# interface Serial 0&#x2F;3&#x2F;0 #进入Se0&#x2F;3&#x2F;0端口R0(config-if)# ip address 58.1.1.1 255.255.255.252 #配置IP地址和子网掩码R0(config-if)# no shutdown #启用端口R0(config-if)# exit #退出Se0&#x2F;3&#x2F;0端口 配置Router 1端口地址12345678910R1&gt; enable #进入特权模式R1# config terminal #进入全局模式R1(config)# interface FastEthernet 0&#x2F;0 #进入Fa0&#x2F;0端口R1(config-if)# ip address 192.168.100.254 255.255.255.0 #配置IP地址和子网掩码R1(config-if)# no shutdown #启用端口R1(config-if)# exit #退出Fa0&#x2F;0端口R1(config)# interface Serial 0&#x2F;3&#x2F;0 #进入Se0&#x2F;3&#x2F;0端口R1(config-if)# ip address 210.28.144.2 255.255.255.252 #配置IP地址和子网掩码R1(config-if)# no shutdown #启用端口R1(config-if)# exit #退出Se0&#x2F;3&#x2F;0端口 配置Router 2端口地址12345678910111213R2&gt; enable #进入特权模式R2# config terminal #进入全局模式R2(config)# interface FastEthernet 0&#x2F;0 #进入Fa0&#x2F;0端口R2(config-if)# ip address 63.1.1.1 255.255.255.0 #配置IP地址和子网掩码R2(config-if)# no shutdown #启用端口R2(config-if)# exit #退出Fa0&#x2F;0端口R2(config)# interface Serial 0&#x2F;1&#x2F;0 #进入Se0&#x2F;1&#x2F;0端口R2(config-if)# ip address 58.1.1.2 255.255.255.252 #配置IP地址和子网掩码R2(config-if)# exit #退出Se0&#x2F;1&#x2F;0端口R2(config)# interface Serial 0&#x2F;0&#x2F;0 #进入Se0&#x2F;0&#x2F;0端口R2(config-if)# ip address 210.28.144.1 255.255.255.252 #配置IP地址和子网掩码R2(config-if)# no shutdown #启用端口R2(config-if)# exit #退出Se0&#x2F;0&#x2F;0端口 Router 0配置静态路由1R0(config)# ip route 0.0.0.0 0.0.0.0 58.1.1.2 #配置静态路由 Router 1配置静态路由1R0(config)# ip route 0.0.0.0 0.0.0.0 210.28.144.1 #配置静态路由 Router 0和Router 1公网间互通性 1Router 0和Router 1公网地址间可以互通。 Router 0配置IPsec VPN（1） 配置 IKE（ISAKMP）策略 策略序号为1，加密算法为aes，Hash 算法为MD5，密钥算法（Diffie-Hellman）为group 2，认证方式（Authentication）为pre-share。 12345R0(config)# crypto isakmp policy 1 #建立IKE策略，优先级为1R0(config-isakmp)# encryption aes #使用AES加密方式 R0(config-isakmp)# hash md5 #指定Hash算法为MD5R0(config-isakmp)# authentication pre-share #使用预共享的密码进行身份验证R0(config-isakmp)# group 2 #指定秘钥位数，group2安全性更高 （2）定义认证标识：预共享密码为tx18 12R0(config)# crypto isakmp key tx18 address 210.28.144.2 #设置要使用的预共享秘钥和指定VPN对端路由器的IP地址。 （3）配置 IPsec transform：定义transform set命名为tx18set，加密算法为esp-3des， HMAC 算法为esp-MD5-HMAC 12R0(config)# crypto ipsec transform-set tx18set esp-3des esp-md5-hmac #配置IPSec交换集，名称为tx18set，两端的名字可以不一样，但其它参数必须一致。 （4）定义感兴趣流量：用扩展acl 180来定义通过 VPN 传输的流量 1R0(config)# access-list 180 permit ip 192.168.123.0 0.0.0.255 192.168.100.0 0.0.0.255 #定义感兴趣数据，IPSec VPN地址为双方内网地址。 （5）创建 crypto map：定义transform set命名为tx18map，将之前定义的 ACL，加密数据发往的对端，以及 IPsec transform 结合在 crypto map中 1234R0(config)# crypto map tx18map 1 ipsec-isakmp #创建加密图 R0(config-crypto-map)# set peer 210.28.144.2 #标识对方路由器IP地址R0(config-crypto-map)# set transform-set tx18set #指定加密图使用的IPSec交换集R0(config-crypto-map)# match address 180 #用ACL定义加密的通信 （6）将 crypto map 应用于对应接口 12R0(config)# interface Serial 0&#x2F;3&#x2F;0 #进入Se0&#x2F;3&#x2F;0端口R0(config-if)# crypto map tx18map #应用加密图到接口 Router 1配置IPsec VPN（1） 配置 IKE（ISAKMP）策略 策略序号为1，加密算法为aes，Hash 算法为MD5，密钥算法（Diffie-Hellman）为group 2，认证方式（Authentication）为pre-share。 12345R0(config)# crypto isakmp policy 1 #建立IKE策略，优先级为1R0(config-isakmp)# encryption aes #使用AES加密方式 R0(config-isakmp)# hash md5 #指定Hash算法为MD5R0(config-isakmp)# authentication pre-share #使用预共享的密码进行身份验证R0(config-isakmp)# group 2 #指定秘钥位数，group2安全性更高 （2）定义认证标识：预共享密码为tx18 1R0(config)# crypto isakmp key tx18 address 58.1.1.1 #定义预共享密码 （3）配置 IPsec transform：定义transform set命名为tx18set，加密算法为esp-3des， HMAC 算法为esp-MD5-HMAC 1R0(config)# crypto ipsec transform-set tx18set esp-3des esp-md5-hmac #配置IPSec交换集，名称为tx18set，两端的名字可以不一样，但其它参数必须一致。 （4）定义感兴趣流量：用扩展acl 180来定义通过 VPN 传输的流量 1R0(config)# access-list 180 permit ip 192.168.100.0 0.0.0.255 192.168.123.0 0.0.0.255 #定义感兴趣数据，IPSec VPN地址为双方内网地址。 （5）创建 crypto map：定义transform set命名为tx18map，将之前定义的 ACL，加密数据发往的对端，以及 IPsec transform 结合在 crypto map中 1234R0(config)# crypto map tx18map 1 ipsec-isakmp #创建加密图R0(config-crypto-map)# set peer 58.1.1.1 #标识对方路由器IP地址 R0(config-crypto-map)# set transform-set tx18set #指定加密图使用的IPSec交换集R0(config-crypto-map)# match address 180 #用ACL定义加密的通信 （6）将 crypto map 应用于对应接口 12R0(config)# interface Serial 0&#x2F;3&#x2F;0 #进入Se0&#x2F;3&#x2F;0端口R0(config-if)# crypto map tx18map #应用加密图到接口 测试PC0能否ping通PC5，为什么？ 1解析：PC 0可以ping通PC 5，因为此时我们配置了IPSec VPN，分公司之间的访问会通过IPSec VPN隧道进行访问。 分析IPSec VPN数据包，了解IPSec VPN数据封装格式进入仿真模式，用PC0 ping PC5，并单步运行，直到面板上出现Last Device为Switch 0，At Device为Router 0的数据包为止，查看该数据包的Inbound PDU Details和 OurBound PDU Details。 1观察第一张图可知：封装前的数据包源IP地址为192.168.123.10，目的IP地址为192.168.100.20。观察第二张图可知：封装后在原始IP头之前增加了新的IP头和ESP头，在新的IP头中源IP地址为58.1.1.1，目的地址为210.28.144.2，IPSec封装已经完成。ESP头中的信息如下：ESP SPI为1469921110，ESP序号为0，ESP的加密方式为3DES，ESP认证方式为MD5。 Router 0边界配置NAT12345678R0(config)# interface FastEthernet 0&#x2F;0R0(config-if)# ip nat insideR0(config-if)# exitR0(config)# interface Serial 0&#x2F;3&#x2F;0R0(config-if)# ip nat outsideR0(config-if)# exitR0(config)# ip nat pool natpool 100.1.1.1 100.1.1.2 netmask 255.255.255.252R0(config)# ip nat inside source list 101 pool natpool overload Router 1边界配置NAT12345678R1(config)# interface FastEthernet 0&#x2F;0R1(config-if)# ip nat insideR1(config-if)# exitR1(config)# interface Serial 0&#x2F;3&#x2F;0R1(config-if)# ip nat outsideR1(config-if)# exitR1(config)# ip nat pool natpool 200.1.1.1 200.1.1.3 netmask 255.255.255.248R1(config)# ip nat inside source list 101 pool natpool overload 出现新问题 1配置了NAT之后我们发现：PC0 不能ping通PC 5了。这是因为IPSec与NAT发生了冲突，路由器对数据包的处理流程是先进行NAT转换，然后进行IPSec封装。所以要对进行IPSec封装的数据流进行一些相关设置，使该数据流不被NAT转换，这样才能成功进行IPSec通信。 解决问题Router 0添加配置12R0(config)# access-list 101 deny ip 192.168.123.0 0.0.0.255 192.168.100.0 0.0.0.255R0(config)# access-list 101 permit ip 192.168.123.0 0.0.0.255 any Router 1添加配置12R1(config)# access-list 101 deny ip 192.168.100.0 0.0.0.255 192.168.123.0 0.0.0.255R1(config)# access-list 101 permit ip 192.168.100.0 0.0.0.255 any 测试结果 1我们发现总公司和分公司的PC可以ping通公网PC，且解决了上面出现的配置NAT之后内网间无法互相访问的问题。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://imqinhao.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"GRE VPN练习","slug":"GRE-VPN","date":"2020-03-21T03:30:11.000Z","updated":"2021-07-17T02:40:42.445Z","comments":true,"path":"2020/03/21/GRE-VPN/","link":"","permalink":"https://imqinhao.cn/2020/03/21/GRE-VPN/","excerpt":"GRE VPN配置练习 软件：Cisco Packet Tracer","text":"GRE VPN配置练习 软件：Cisco Packet Tracer 题目要求 1234567891、基础配置如下： 按图中所示配置总公司和分公司中各计算机、服务器、路由器对应端口的IP地址相关信息；2、在总公司与分公司之间配置GRE隧道技术，实现两地私有地址的内部网络之间可以实现相互通信。 （1）在Router0和Router1上配置一条默认路由，实现Internet间互通总公司和分公司 测试Router0和Router1的公网地址间的互通性 （2）在Router0和Router1上配置 GRE VPN （tunnel号为1，地址分别为10.1.1.1&#x2F;30和10.1.1.2&#x2F;30） （3）在Router0和Router1上配置动态路由rip协议，实现总公司和分公司私网路由3、测试PC0能否ping通PC5，为什么？4、分析GRE数据包，了解GRE数据封装格式 Router 0配置IP地址123456789R0&gt; enableR0# config terminalR0(config)# interface fastEthernet 0&#x2F;0R0(config-if)# ip address 192.168.75.254 255.255.255.0R0(config-if)# no shutdownR0(config-if)# exitR0(config)# interface serial 0&#x2F;3&#x2F;0R0(config-if)# ip address 58.1.1.1 255.255.255.252R0(config-if)# exit Router 1配置IP地址12345678910R1&gt; enableR1# config terminalR1(config)# interface serial 0&#x2F;3&#x2F;0R1(config-if)# ip address 210.28.144.2 255.255.255.252R1(config-if)# no shutdownR1(config-if)# exitR1(config-if)# interface fastEthernet 0&#x2F;0R1(config-if)# ip address 192.168.210.254 255.255.255.0R1(config-if)# no shutdownR1(config-if)# exit Router 2配置IP地址1234567891011R2&gt; enable R2# config terminalR2(config)# interface serial 0&#x2F;1&#x2F;0R2(config-if)# ip address 58.1.1.2 255.255.255.252R2(config-if)# exitR2(config)# interface fastEthernet 0&#x2F;0R2(config-if)# ip address 63.1.1.1 255.255.255.0R2(config-if)# exitR2(config)# interface serial 0&#x2F;0&#x2F;0R2(config-if)# ip address 210.28.144.1 255.255.255.252R2(config-if)# no shutdown Router 0配置静态路由1R0(config)# ip route 0.0.0.0 0.0.0.0 58.1.1.2 Router 1配置静态路由1R1(config)# ip route 0.0.0.0 0.0.0.0 210.28.144.1 测试Router 0和Router 1的公网地址互通性 Router 0配置GRE VPN12345R0(config)# interface tunnel 1R0(config-if)# ip address 10.1.1.1 255.255.255.252R0(config-if)# tunnel source serial 0&#x2F;3&#x2F;0R0(config-if)# tunnel destination 210.28.144.2 R0(config-if)# exit Router 1配置GRE VPN12345R1(config)# interface tunnel 1R1(config-if)# ip address 10.1.1.2 255.255.255.252R1(config-if)# tunnel source serial 0&#x2F;3&#x2F;0R1(config-if)# tunnel destination 58.1.1.1 R1(config-if)# exit Router 0配置rip12345R0(config)# router rip R0(config-router)# version 2R0(config-router)# no auto-summary R0(config-router)# network 192.168.75.0 R0(config-router)# network 10.1.1.1 Router 1配置rip1234R1(config)# router rip R1(config-router)# version 2R1(config-router)# network 192.168.210.0R1(config-router)# network 10.1.1.2 测试PC0能否ping通PC5，为什么？ 1解析：PC0可以ping通PC5。因为我们已经配置了隧道，且配置了rip路由，内网地址会通过隧道进行传输，而不会直接从公网进行传输。 分析GRE数据包，了解GRE数据封装格式 1解析：当tunnel口收到来自网络层的数据包后，网络层的GRE模块会在原IP包之前加上GRE头部，然后在GRE头部前加上新的IP头部。最后，路由器根据新IP头部进行路由。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://imqinhao.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"Python基础知识(1)","slug":"Python_basic_(1)","date":"2020-03-11T11:04:14.000Z","updated":"2021-07-17T02:48:10.374Z","comments":true,"path":"2020/03/11/Python_basic_(1)/","link":"","permalink":"https://imqinhao.cn/2020/03/11/Python_basic_(1)/","excerpt":"Python学习基础部分笔记","text":"Python学习基础部分笔记 第一行代码尝试输入 1 + 1 Python会自动运算出结果。 12&gt;&gt;&gt; 1 + 12 我们再输入点其他的代码 12&gt;&gt;&gt; print(\"Hello World!\")Hello World 注意： 编程中需要输入英文符号，输入中文符号会报错。 观察如下代码： 1234&gt;&gt;&gt; print(1 + 1)2&gt;&gt;&gt; print(\"1 + 1\")1 + 1 用引号引起来的内容，我们称之为字符串。将内容放进引号内，会将内容原样输出。 注意：引号可以是单引号，也可以是双引号，但是必须前后对应。 打印多行文本 1234567&gt;&gt;&gt; print('''··· 我就吃两个··· 其他的都给你··· ''')我就吃两个其他的都给你 如果想打印多行文本，我们可以使用三个引号。 数据类型Python 的数据类型有 int(整数)、float(浮点数)、字符串、布尔值、None、列表、元组、字典、集合等。 int - 整数1数学意义上的证整数，可以是正整数或负整数，不带小数点。 float - 浮点数1浮点数，就是小数。在计算机中，所有数据都会被转换为二进制数值进行处理，处理完成后再转换成你想要的信息。转换过程可能造成精度的损失。 尝试输入 1.1 + 2.2 ，观察结果 12&gt;&gt;&gt; 1.1 + 2.23.3000000000000003 结果并不是3.3，而是3.3000000000000003。 布尔值布尔值只有True和False两种取值，需区分大小写。 12345678&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse&gt;&gt;&gt; 1 &lt; 2True&gt;&gt;&gt; 1 &gt; 2False NoneNone表示“无”，什么都没有。它与0有区别，0是一个整数，而“无”表示什么都没有。 变量把常用的数据放在里面，起一个好记的名字，下次用到的时候可以快速找到它。比如在游戏中我们可能会用到[血量、攻击力、防御力]等数据，这些数据需要用名字存储起来。 定义这些变量的代码如下： 123&gt;&gt;&gt; Level = 1&gt;&gt;&gt; ATK = 5&gt;&gt;&gt; HP = 100 左边是变量名，右边是数据，=代表的是赋值符。 变量的数据，除了可以是整数，还可以是一段文字。 123&gt;&gt;&gt; word = \"Hello World!\"&gt;&gt;&gt; print(word)Hello World! 右边的数据，也可以是变量。 123&gt;&gt;&gt; words &#x3D; word&gt;&gt;&gt; print(words)Hello World! Input()函数获取用户输入，比如我们需要用户输入姓名和年龄，然后将它们打印出来，代码如下： 123456&gt;&gt;&gt; name = input(\"请输入你的姓名：\")请输入你的姓名：浩哥 #此处输入你的名字，然后回车，我们就完成了将你的名字赋值给name变量&gt;&gt;&gt; age = input(\"请输入你的年龄：\")请输入你的年龄：18 #同上，浩哥永远18岁&gt;&gt;&gt; print(\"你的姓名是\" + name + \",你的年龄是：\" + age)你的姓名是浩哥，你的年龄是18 字符串用引号包起来的就是字符串。如果字符串里面有引号，则应该使用转义符” \\ “。 1print(\"He said \\\"It\\'s mime\\\"”) 索引我们定义一个变量name，赋值haoge，我们可以取出第一个字母。需要注意的是，索引是从0开始的，并不是从1开始。 12345&gt;&gt;&gt; name = \"haoge\"&gt;&gt;&gt; print(name[0])q&gt;&gt;&gt; print(name[1])i format()format()是专门用来格式化的函数。 借用上面Input()的例子，我想要打印“你的姓名是xx，你的年龄是xx”，除了上面的方式，我们可以用format()函数来实现。 123456&gt;&gt;&gt; name = input(\"请输入你的姓名：\")请输入你的姓名：浩哥&gt;&gt;&gt; age = input(\"请输入你的年龄：\")请输入你的年龄：18&gt;&gt;&gt; print(\"你的姓名是&#123;0&#125;,你的年龄是&#123;1&#125;\".format(name,age))你的姓名是浩哥，你的年龄是18 下图会让你有更好的理解 数字格式化假设3.1415926我们只想保留到小数点后两位，我们可以这样写： 12&gt;&gt;&gt; print(\"&#123;:.2f&#125;\".format(3.1415926))3.14 注释注释可以帮助他人和自己阅读，理解，编写代码。注释不会被执行。单行注释常用#表示。 1# 单行注释 运算符 运算符 名称 描述 + 加 两个对象相加 - 减 得到负数或是一个数减去另一个数 * 乘 两个数相乘或是返回一个被重复若干次的字符串 / 除 x 除以 y % 取模 返回除法的余数 ** 幂 返回 x 的 y 次幂 // 取整数 返回商的整数部分（向下取整） 比较运算符 运算符 描述 == 等于：比较对象是否相等 != 不等于：比较两个对象是否不相等 &gt; 大于：返回 x 是否大于 y &lt; 小于：返回 x 是否小于 y &gt;= 大于等于：返回 x 是否大于等于 y &lt;= 小于等于：返回 x 是否小于等于 y 赋值运算符 运算符 描述 实例 = 赋值运算符 c = a + b ：将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a ：等效于 c = c + a -= 减法赋值运算符 c -= a ：等效于 c = c - a *= 乘法赋值运算符 c *= a ：等效于 c = c * a /= 除法赋值运算符 c /= a ：等效于 c = c / a %= 取模赋值运算符 c %= a ：等效于 c = c % a **= 幂赋值运算符 c = a ：等效于 c = c a //= 取整除赋值运算符 c //= a ：等效于 c = c // a 逻辑运算符 运算符 逻辑表达式 结果 and（逻辑与） a and b 当 a、b 都为 True 时，返回 True；否则返回 False or（逻辑或） a or b 当 a、b 任意一个为 True，就返回 True not（逻辑非） not a 当 a 为 True 时，返回 False；反之亦然 总结","categories":[{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"}],"tags":[]},{"title":"Linux常用操作","slug":"Linux_often_use","date":"2020-03-11T05:04:14.000Z","updated":"2021-07-17T02:43:17.653Z","comments":true,"path":"2020/03/11/Linux_often_use/","link":"","permalink":"https://imqinhao.cn/2020/03/11/Linux_often_use/","excerpt":"Linux基础操作命令","text":"Linux基础操作命令 创建文件夹1mkdir 文件夹名称 创建多级目录1mkdir -p 一级目录/二级目录/三级目录 创建文件1touch 文件名 复制文件1cp 文件名 目录 复制目录1cp -r 目录名 目标目录名 删除文件1rm 文件名 删除目录和目录下所有文件1rm -r 目录名 移动文件1mv 文件名 目录名 重命名文件1mv 原文件名 目标文件名 查看文件内容1cat 文件名 带行号查看文件内容1cat -n 文件名 总结","categories":[{"name":"Linux","slug":"Linux","permalink":"https://imqinhao.cn/categories/Linux/"}],"tags":[]},{"title":"光传输网络基础","slug":"optical_transport_network_basic","date":"2020-03-07T08:30:00.000Z","updated":"2021-07-17T02:47:47.559Z","comments":true,"path":"2020/03/07/optical_transport_network_basic/","link":"","permalink":"https://imqinhao.cn/2020/03/07/optical_transport_network_basic/","excerpt":"光传输网络基础学习笔记","text":"光传输网络基础学习笔记 OTN1Optical Transport Network，光传送网。 OTN的优势123451.透明传送能力；2.支持多种客户信号的封装传送；3.交叉连接的可升级性；4.强大的带外前向纠错功能（FEC）；5.串连监控（Tandem Connection Monitoring)。 OTN网络结构 123按照OTN技术的网络分层，可分为光通道层、光复用段层和光传送段层三个层面。另外，为了解决客户信号的数字监视问题，光通道层又分为光通路净荷单元（OPU）、光通道数据单元（ODU)和光通道传送单元（OUT）三个子层。 OPU1光通道净荷单元，提供客户信号的映射功能； ODU1光通道数据单元，提供客户信号的数字包封、OTN的保护倒换、提供踪迹监测、通用通信处理等功能； OTU1光通道传输单元、提供OTN成帧、FEC处理、通信处理等功能波分设备中的发送OTU单板完成了信号从客户接口到OCC的变化；波分设备中的接收OTU单板完成了信号从OCC到客户接口的变化。 常用单板 光转发单板1234主要功能：1.提供线路侧光模块，内有激光器，发出特定稳定的，符合波分系统标准的波长的光2.将客户侧接收的信息封装到对应的OTN帧中，送到线路侧输出。3.提供客户侧光模块，连接PTN&#x2F;路由器&#x2F;交换机等设备。 合波/分波单板12345光合波板OMU位于发送端业务单板与光放大器之间。主要功能：将从各业务单板接收到的各个特定波长的光复用在一起，从出口输出。光分波板ODU位于接收端光放大器和业务单板之间。主要功能：将从光放大器收到的多路业务在光层上解复用为多个单路光送给业务单板的线路口。 光放大板1234567光放大板主要功能是将光功率放大到合理的范围。发送端OBA（功率放大板）位于OMU单板之后，用于将合波信号放大后发出。接收端OPA（前置放大板）位于ODU单板之前，将合波信号放大后送到ODU解复用。OLA（光线路放大板），用于OLA站点放大光功率。 电交叉子系统12345OTN电交叉子系统以时隙电路交换为核心，通过电路交叉配置功能，支持各类大颗粒用户业务的接入和承载，实现波长和子波长级别的灵活调度。同时继承OTN网络监测、保护等各类技术，支持毫秒级的业务保护倒换。电交叉子系统的核心是交叉板，主要是根据管理配置实现业务的自由调度，完成基于ODUK颗粒的业务调度。电交叉需要采用O&#x2F;E&#x2F;O转换。","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"IP承载网理论基础","slug":"IP_Bearer_Network_basic","date":"2020-03-07T08:00:00.000Z","updated":"2021-07-17T02:41:45.287Z","comments":true,"path":"2020/03/07/IP_Bearer_Network_basic/","link":"","permalink":"https://imqinhao.cn/2020/03/07/IP_Bearer_Network_basic/","excerpt":"IP承载网理论基础学习笔记","text":"IP承载网理论基础学习笔记 IP地址1互联网协议地址（Internet Protocol Address），缩写为IP地址。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。 子网掩码 1前缀表示：为了进一步简化子网掩码的表达，还可以用“&#x2F;”加上网络位的位数来代表子网掩码，叫做前缀长度。比如，255.255.0.0，可以表示成“&#x2F;16”，255.255.255.0可表示为“&#x2F;24”。 IP地址计算 特殊的IP地址 以太网交换机工作模型1二层以太网交换机处理以太网数据帧，根据数据帧头的源MAC和目的MAC指导报文转发。 认识MAC地址 VLAN原理 划分VLAN的好处12交换机划分VLAN后减小了广播域范围，可以有效地控制网络广播风暴。同时，可以控制VLAN间通信问题，有效地提升网络安全。 什么是路由1路由是指导IP报文转发的路径信息。 路由的种类缺省路由12345缺省路由是一种特殊的路由，它的目的地址和掩码为全0，表示“0.0.0.0”，它可以匹配任意的目的地址。缺省路由并不一定都是手工配置的静态路由，有时也可以由动态路由协议产生。缺省路由一般配置在网络的出口设备中。 直连路由1链路层协议发现的路由开销小，配置简单，无需人工维护。只能发现本接口所属网段的路由。 静态路由1静态路由是网络管理员手工配置的路由。静态路由配置简单，适合于小型网络。静态路由配置项不随设备及链路的状态而变化。 动态路由123动态路由协议发现的路由开销大，配置复杂，无需人工维护，适合复杂拓朴结构的网络。动态路由指路由器在配置了动态路由协议之后，通过路由信息的交换，经过计算，自动生成的路由。 路由优先级1从优先级最高的协议获取的路由最先被优先选择加入路由表中。 路由优选原则12345678问：越“高级”的路由协议发现的路由越优先?答：最长匹配优先问：无销值越小的路由越优先？答：不同的路由协议发现的路由开销值没有比较意义问：在路由器A上被优选的路由，路由器B上也一定优选？答：路由选优完全是“单机行为” 动态路由的优势1231. 自动生成2. 路径冗余3. 故障检测 动态路由的缺点121.需要占用较多系统和带宽资源；2.安全性存在问题。 OSPF12341. 邻居关系2. 宣告网络3. 宣告路由4. 引进路由","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"NB-IoT技术架构","slug":"NB-IoT","date":"2020-03-07T07:00:00.000Z","updated":"2021-07-17T02:46:03.418Z","comments":true,"path":"2020/03/07/NB-IoT/","link":"","permalink":"https://imqinhao.cn/2020/03/07/NB-IoT/","excerpt":"NB-IoT技术学习笔记","text":"NB-IoT技术学习笔记 5G的发展方向123高速率，高带宽： LTE、LTE-A低速率、低成本、低功耗、广覆盖：物联网 频谱应用1主流的FDD频段都支持NB-IoT：900MHz、1800MHz、800MHz NB-IoT网络架构 NB-IoT数据传输方案NB-IoT主要用于传送低速率的小数据包，从传输数据格式来看，可以传输三种数据类型：IP，Non-IP，SMS（短消息）。 NB-IoT是从LTE系统演进而来，为提升小数据的传输效率，NB-loT系统支持两种优化的传输方案，包括控制面优化传输方案（简称CP方案）和用户面优化传输方案（简称UP方案）。3GPP 5G NR协议标准 5G频率范围 5GNR常见的帧结构配置1以u&#x3D;1,子载波间隔为30KHz为例，单个时隙长度为0.5ms SS Block组成123一个SS block 包含PSS&#x2F;SSS&#x2F;PBCH,用于下行同步信号和广播信号的发送。小区搜索是UE接入网络，为用户提供各种业务的基础 物理信号与天线端口上行链路的天线端口： 天线端口0（起始号）用于PUSCH的DM-RS 天线端口1000（起始号）用于SRS 天线端口2000（起始号）用于PUCCH的DM-RS 天线端口4000用于PRACH。 下行链路的天线端口： 天线端口1000（起始号）用于PDSCH的DM-RS 天线端口2000（起始号）用于PDCCH的DM-RS 天线端口3000（起始号）用于CSI-RS 天线端口4000（起始号）用于SS/PBCH","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"LTE信道及协议栈分析","slug":"wireless_radio","date":"2020-03-07T05:00:00.000Z","updated":"2021-07-17T02:52:33.450Z","comments":true,"path":"2020/03/07/wireless_radio/","link":"","permalink":"https://imqinhao.cn/2020/03/07/wireless_radio/","excerpt":"LTE信道及协议栈分析学习笔记","text":"LTE信道及协议栈分析学习笔记 无线帧结构-FDD制式1234567891个无线帧Tf&#x3D;207200Ts&#x3D;10ms每个10ms无线帧被分为10个子帧每个子帧包含两个时隙，每时隙长0.5msTs&#x3D;1&#x2F;（15000*2048)是基本时间单元任何一个子帧即可以作为上行，也可以作为下行 无线帧结构-TDD制式1234567891个无线帧Tf&#x3D;307200Ts&#x3D;10ms每个10ms无线帧包括2个长度为5ms的半帧，每个半帧由4个数据子帧和1个特殊子帧组成特殊子帧包括3个特殊时隙：DWPTS，GP和UpPTS，总长度为1ms支持5ms和10ms上下行切换点子帧0、5和DWPTS总是用于下行发送 LTE信道及协议栈分析(物理层)RE1最小的资源单位，时域上为1个符号，频域上为1个子载波用（k,l）标记 RB1业务信道的资源单位，时域上为1个时隙，频域上为12个子载波 PCM的主要步骤1抽样、量化、编码","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"LTE系统概述","slug":"LTE","date":"2020-03-07T04:25:00.000Z","updated":"2021-07-17T02:43:28.539Z","comments":true,"path":"2020/03/07/LTE/","link":"","permalink":"https://imqinhao.cn/2020/03/07/LTE/","excerpt":"4G系统概述学习笔记","text":"4G系统概述学习笔记 LTE网络架构LTE通过大容量、快速响应、高速率和更好的Qos提升用户体验。 1234567891011E-UTRAN中只有一种网元—eNode B全IP化演进分组核心网------EPC媒体面控制面分离演进分组系统—EPS与传统网络互通 12345678UE与eNode B之间的接口是Uu接口eNode B与MME之间的接口是S1-MME接口eNode B与S-GW之间的接口是S1-UeNode B与eNode B之间的接口是X2MME与HSS之间的接口是S6aMME与S-GW之间的接口是S11S-GW与P-GW之间的接口是S5&#x2F;S8PCRF与P-GW之间的接口是Gx 1Uu口也叫X1口，X2口相当于3G的Iur接口。 LTE网元功能eNodeB1（Mobility Management Entity,移动管理实体）无线资源管理，IP头压缩和用户数据流加密，UE附着时的MME选择，用户面数据向S-GW的路由，寻呼消息和广播信息的调度和发送，移动性测量和测量报告的配置。 MME1（Mobility Management Entity,移动管理实体）MME为控制面功能实体，临时存缝用户数据的服务器，负责管理和存储UE相关信息，比如UE用户标识、移动性管理状来用户安全参数，为用户分配临时标识。当UE驻扎在该跟踪区域或者该网络时负责对该用户进行鉴权，处理MME和UE之间的所有非接入层消息。 SGW1（Serving Gateway,服务网关）SGW为用户面实体，负责用户面数据路由处理，终结处于空闲状态的UE（用户终端设备）的下行数据，管理和存储UE的承载信息，比如IP承载业务参数和网络内部路由信息。 PGW1（PDN Gateway,分组数据网网关）PGW负责UE接入PDN的网关，分配用户IP地址，同时是3GPP和非3GPP接入系统的移动性锚点。用户在同一时刻能够接入多个PDN GW。 HSS1（Home Subscriber Server,归属用户服务器）HSS存储并管理用户签约数据，包括用户鉴权信息、位置信息及路由信息。 PCRF1（Policy and Charging Rule Functionality,策略和计费规则功能实体）PCRF功能实体主要根据业务信息和用户签约信息以及运营商的配置信息产生控制用户数据传递的QoS（Quality of Service，服务质量）规则以及计费规则。该功能实体也可以控制接入网中承载的建立和释放。 LTE接口与协议 ​ LTE主要网络标识 PLMN ID1PLMN ID是PLMN的全局唯一标识，由MCC+MNC两部分组成。 IMSI IMEI MSISDN GUTI TAI ECGI LTE关键技术-多址技术1LTE系统下行多址方式为正交频分多址（OFDMA），上行为基于正交频分复用（OFDM）传输技术的单载波频分多址（SC-FDMA）。 OFDMA特点12345最大支持64 QAM通过CP解决多径干扰兼容MIMO SC-FDMA特点12345最大支持64 QAM单载波调制降低峰均比（PAPR）FDMA可通过FFT实现 LTE关键技术-MIMO LTE关键技术-多阶调制技术123LTE支持BPSK，QPSK，16QAM，64QAM，256QAM。当前上行支持64QAM，下行支持256QAM。 LTE关键技术- 链路自适应技术速率控制1234567AMC：- 时域AMC- 频域AMC- 空域AMC 功率控制1功率控制可以很好的避免小区内用户间的干扰。 LTE关键技术-干扰消除技术功率控制123小区间功率控制：一种通过告知其它小区本小区loT信息，控制本小区loT的方法。小区内功率控制：补偿路损和阴影衰落，节省终端的发射功率，尽量降低对其他小区的干扰，使得loT保持在一定的水平之下。 LTE关键技术-载波聚合12345载波聚合是指基站根据UE能力将2个或更多载波进行聚合每一聚合的载波称为分量载波协议设计最多支持5个的载波聚合在一起以支持更大的传输带宽（最大为100MHz)。","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"3G系统概述","slug":"3G","date":"2020-03-07T03:25:00.000Z","updated":"2021-07-17T02:30:50.272Z","comments":true,"path":"2020/03/07/3G/","link":"","permalink":"https://imqinhao.cn/2020/03/07/3G/","excerpt":"3G系统概述学习笔记","text":"3G系统概述学习笔记 什么是3G13G是第三代移动通信技术，是指支持高速数据传输的蜂窝移动通讯技术。 3G的主要特点12345- 全球普及和全球无缝漫游- 具有支持多媒体业务的能力，特别是支持Internet的能力- 便于过渡和演进- 高频谱利用率- 能够传送高达2Mbit&#x2F;s的高质量图象 3G的三大主流标准比较 WCDMA cdma2000 TD-SCDMA 最小带宽需求 5MHz 3*1.25MHz 1.6MHz 双工方式 FDD/TDD FDD TDD 信道间隔 5MHz 1.25/5MHz 1.6MHz 码片速率 3.84Mcps 1.2288/3.6864Mcps 1.28Mcps 帧长 10ms 20ms 10ms 基站间同步 异步（不需GPS） 同步（需GPS） 同步(主从同步) 调制方式 QPSK/BPSK QPSK/BPSK QPSK/8PSK WCDMA的组成1WCDMA由核心网（CN）、UMTS陆地无线接入网（UTRAN）、用户设备（UE)三大部分组成 WCDMA关键网元 RNC1无线网络控制器（RNC）用于控制RAN的无线资源，主要功能有移动性管理、呼叫处理、链接管理、切换机制；逻辑位置上对应GSM网络中的基站控制器（BSC）。 Node B1Node B是WCDMA的基站（即无线收发信机），主要功能是扩频、调制、信道编码及解扩、解调、信道解码、还包括基带信号和射频信号的转化。 UE13G网络中，用户终端就叫做UE，包含手机、智能终端、多媒体设备、流媒体设备等。 Iur接口1是连接RNC之间的开放标准接口，用于对RAN中移动台的移动管理，支持软切换。 WCDMA切换 软切换1不同基站之间的切换先连接，再断开。 更软切换1可看做是软切换的特例，与软切换的区别是更软切换是同一个基站不同小区之间的切换。在更软切换区，同时和UE保持联系的两个小区属于同一NodeB。不需要RNC参与。 硬切换1234567先断开，再切换。硬切换过程，在切换区，UE先中断和原服务小区的无线连接，再建立和新小区的连接。注意在切换过程中，首先建立RNC到NodeB2的链路，然后先断开UE和NodeB1小区的连接（此时NodeB1到RNC的链路保留）再建立NodeB2小区到UE的连接，连接成功后，再断开NodeB1到RNC的连接。在硬切换过程中，同一时刻，只有一个小区的UE连接。","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"GSM系统概述","slug":"GSM","date":"2020-03-07T02:00:00.000Z","updated":"2021-07-17T02:40:55.618Z","comments":true,"path":"2020/03/07/GSM/","link":"","permalink":"https://imqinhao.cn/2020/03/07/GSM/","excerpt":"2G系统概述学习笔记","text":"2G系统概述学习笔记 什么是GSM1234567GSM(Global System for Mobile Communication) ，全球移动通信系统。GSM分GSM900、DCS1800和PCN1900三个频段。GSM900&#x2F;1800分别工作在890~960MHz&#x2F;1710~1880MHz频段。频段越高，波长越短，直射和绕射的能力越弱。 GSM频段分配GSM90012345678910111213上行频率：890--915MHZ（MS发射，BTS接收）下行频率：935—-960MHZ（BTS发射，MS接收）共分为124对双工载频，载频间隔为200KHZ。每载频共分8个时隙，即为8个信道。总信道数为124×8&#x3D;992个信道。中国移动频点（1-94），中国联通频点（96-124）。该频段适合用于实现信号覆盖。 DCS18001234567891011上行：1710-1785MHz下行：1805-1880MHz共分为374对双工载频，载频间隔为200KHZ。总信道数为374×8&#x3D;2992个信道。1800频段的信号带宽资源充足，多用于吸收室内的话务。中国移动频点512-636，中国联通频点638-736。 基站子系统(BSS)和移动台(MS))) BSC基站控制器1234567① 进行无线信道、参数、资源管理② 实施呼叫和通信链路的建立和拆除③ 控制完成移动台的定位、切换及寻呼等④ 接口管理⑤ 无线链路测量⑥ 话务量统计⑦ 操作与维护 BTS基站收发信站123① 无线传输② 无线与有线的转换③ 无线分集、无线信道加密、调频等 MS移动台1包括终端设备和SIM卡。 移动交换子系统(NSS) AUC 鉴权中心1是向HLR提供出于安全原因而使用的鉴权参数和密钥。现网中是和HLR一个物理实体。 EIR设备识别寄存器1对接入系统的移动台的设备进行识别。 MSC 移动业务交换中心12345- 交换功能：包括呼叫的建立、路由选择、呼叫监视、呼叫释放等。- 计费功能- 移动性管理：位置更新、鉴权、加密等。 VLR拜访位置寄存器12345- 动态数据库- 本交换区用户参数，该参数是从LR中获得的。- 本交换区用户的位置信息：MS的LAI。 HLR归属位置寄存器12345- 静态数据库- 永久性参数：用户号码、接入的优先等级、预定的业务类型等；- 临时性参数：寄存用户的鉴约信息和位置信息，如补充业务、鉴权参数，MS的位置信息等。","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"移动通信术语","slug":"wireless_word","date":"2020-03-06T07:00:00.000Z","updated":"2021-07-17T02:52:43.323Z","comments":true,"path":"2020/03/06/wireless_word/","link":"","permalink":"https://imqinhao.cn/2020/03/06/wireless_word/","excerpt":"记录了一些无线侧和核心侧的一些术语","text":"记录了一些无线侧和核心侧的一些术语 无线侧术语频谱1一个时域的信号在频域下表示方式 频段1频谱中的某一区间 载频1载波或者载频(载波频率）是一个物理概念，其实就是一个特定频率的无线电波，单位Hz。在无线通信技术上我们使用载波传递信息，将数字信号调制到一个高频载波上然后再在空中发射和接收 速率单位1234561B &#x3D; 1024bt1KB &#x3D; 1024B1MB &#x3D; 1024KB1GB &#x3D; 1024MB1Mbps &#x3D; 1024Kbps &#x3D; 128KBps1Gbps &#x3D; 1024Mbps &#x3D; 128MBps 带宽12在模拟信号系统又叫频宽，是指在固定的时间可传输的资料数量，亦即在传输管道中可以传递数据的能力。通常以每秒传送周期或赫兹（Hz)来表示。1GHz &#x3D; 1000MHz &#x3D; 1000 000KHz &#x3D; 1000 000 000Hz 基站1无线电台站的一种形式，是指在一定的无线电覆盖区中，通过移动通信交换中心，与移动电话终端之间进行信息传递的无线电收发信电台 小区1在蜂窝移动通信系统中，其中的一个基站或基站的一部分（扇形天线）所覆盖的区域，在这个区域内移动台可以通过无线信道可靠地与基站进行通信 跟踪区域（TA）1LTE&#x2F;SAE系统为UE的位置管理新设立的概念。其被定义为UE不需要更新服务的自由移动区域。TA功能为实现对终端位置的管理，可分为寻呼管理和位置更新管理。UE通过跟踪区注册告知EPC自己的跟踪区TA 物理小区标识PCl1LTE中终端以此区分不同小区的无线信号。LTE系统提供504个PCI,网管配置时，为小区配置0~503之间的一个号码。LTE小区搜索流程中通过检索主同步序列(PSS，共有3种可能性）、辅同步序列（SSS，共有168种可能性），二者相结合来确定具体的小区ID 参考信号功率1是在某个符号内承载参考信号的所有RE（资源粒子）上接收到的信号功率的平均值，也就是子载波功率 载波聚合1为了满足单用户峰值速率和系统容量提升的要求，一种最直接的办法就是增加系统传输带宽。因此LTE-Advanced系统引入一项增加传输带宽的技术，也就是CA（Carrier Aggregation，载波聚合） 核心侧术语国家码MCC1移动国家码，MCC的资源由国际电联（ITU)统一分配和管理，唯一识别移动用户所属的国家，共3位，中国为460 网络码MNC1移动网络码，共2位，中国移动TD系统使用00，中国联通GSM系统使用01，中国移动GSM系统使用02，中国电信CDMA系统使用03 APN1一种网络接入技术，是通过手机上网时必须配置的一个参数，它决定了手机通过哪种接入方式来访问网络 QCI1用于衡量特定的提供给SDF（服务数据流)的包转发行为（如丢包率，包延迟预算），它同时应用于GBR和Non-GBR承载，用于指定访问节点内定义的控制承载级分组转发方式（如调度权重、接纳门限、队列管理门限、链路层协议配置等），这些都由运营商预先配置到接入网节点中 国际移动用户识别码（lMSl）1国际上为唯一识别一个移动用户所分配的号码，IMSI共有15位，其结构如下：MCC+MNC+MSIN，（MNC+MSIN&#x3D;NMSI) Kl(Key identifier)1SIM卡与运营商之间加密数据传递的密钥，主要作用在于系统为确认手机用户所进行的身份验证功能 MSISDN1主叫用户为呼叫GSM PLMN中的一个移动用户所需拨的号码，作用于固定网PSTN号码；是在公共电话网交换网络编号计划中，唯一能识别移动用户的号码 其它术语单工1数据传输只支持数据在一个方向上传输；在同一时间只有一方能接受或发送信息，不能实现双向通信，举例：电视，广播 半双工1数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；在同一时间只可以有一方接受或发送信息，可以实现双向通信。举例：对讲机 双工1数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力；在同一时间可以同时接受和发送信息，实现双向通信，举例：电话通信 时分复用（TDD）1是在帧周期的下行线路操作中及时区分无线信道以及继续上行线路操作的一种技术，也是移动通信技术使用的双工技术之一 频分复用（FDD）1移动通信系统中使用的全双工通信技术的一种，与TDD相对应。FDD采用两个独立的信道分别进行向下传送和向上传送信息的技术。为了防止邻近的发射机和接收机之间产生相互干扰，在两个信道之间存在一个保护频段。","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"移动网络发展与技术笔记","slug":"mobile_communication","date":"2020-03-06T05:30:11.000Z","updated":"2021-07-17T02:44:17.596Z","comments":true,"path":"2020/03/06/mobile_communication/","link":"","permalink":"https://imqinhao.cn/2020/03/06/mobile_communication/","excerpt":"移动通信基础的学习笔记","text":"移动通信基础的学习笔记 第一代移动通信（1G)采用模拟技术的语言移动通信，提供9.6Kbit/s的通信带宽，接入技术采用FDMA。 缺点12345- 频谱利用率低- 系统容量有限- 抗干扰能力差- 标准不统一，跨国漫游困难- 没有数字业务，不能与综合业务数字网(ISDN)兼容。 第二代移动通信（2G）采用数字技术的移动通信，以语音为主，低速数据传输。提供9.6Kbit/s~28.8Kbit/s的传输速率，接入技术是TDMA，CDMA。 优点1相比1G具有保密性强，频谱利用率高，标准化程度高的特点。 缺点123- 系统带宽有限，限制了数据业务的发展- 无法实现多媒体业务- 各国标准不统一，无法实现全球漫游。 2G代表系统123TDMA体制：欧洲的全球移动通信系统（GSM）等CDMA体制：美国的CDMA系统 第三代移动通信（3G）采用CDMA技术和分组交换技术。提供9.6Kbit/s~2Mbit/s的接入速率。 优点1相对2G频谱利用率高，性能更好；提供移动多媒体业务；3G支持漫游。 3G代表系统12345美国：CDMA2000欧洲和日本：WCDMA中国：TD-SCDMA 2009年1月中国“信息产业部”发下了3张3G牌照，将3G的三大标准分别分配给： 12345中国移动：TD-SCDMA中国联通：WCDMA中国电信：CDMA 2000 第四代移动通信（4G）提供2~20Mbit/s。 提高传输速率的主要技术：1234567OFDM：正交频分复用SA：智能天线技术MIMO：多输入多输出技术SDR：软件无线电 第五代移动通信（5G）三大目标场景：12345- 增强移动带宽：eMBB- 海量机器通信：mMTC- 超高可靠低时延通信：URLLC 通信的概念1指人与人或人与自然之间通过某种行为或媒介进行的信息交流与传递，从广义上指需要信息的双方或多方在不违背各自意愿的情况下采用任意方法，任意媒介，将信息从某方准确安全地传送到另方。 123graph LRA[信源] --&gt;B(发送设备) --&gt;C(信道) --&gt; D(接收设备) --&gt; E(信宿) F(噪声源) --&gt; C 123456信源：把各种信息转换成原始电信号。信源分为数字信源和模拟信源。发送设备：产生适合于在信道中传输的信号。信道：将来自发送端的信号传送到接收端的物理媒介。可分为有线信道和无线信道两大类。噪声源：集中表示分布于通信系统中各处的噪声。接收设备：将受到减损的接收信号中正确恢复出原始电信号。信宿：将原始电信号还原成相应的消息。 信源模拟信号与数字信号123模拟信号：模拟信号是连续的信号。数字信号：时间上离散的信号，通过电压脉冲的变化来表示要传输的数据 数字信号的优点123456（1） 抗干扰能力强，且噪声不积累（2） 传输差错可控（3） 便于处理、变换、存储（4） 便于将来自不同信源的信号综合到一起传输（5） 易于集成（6） 易于加密处理，且保密性好 数字信号的缺点12（1） 需要较大的传输带宽（2） 对同步要求高 发射设备调制1调制的目的是把要传输的模拟信号或数字信号变换成适合信道传输的信号。该信号称为已调信号。调制过程用于发送端。 解调1在接收端将已调信号还原成要传输的原始信号，该过程称为解调。解调过程用于接收端。 模拟调制1利用输入的模拟信号直接调制载波的振幅、频率或相位，从而得到调幅（AM）、调频（FM）或调相（PM）信号。 数字调制1利用数字信号来控制载波的振幅、频率或相位。 常用的数字调制12FSK：频移键控PSK：相移键控 信道1将来自发送设备的信号传送到接收端的物理媒介。分为有线信道和无线信道。 信道的基本特征123(1) 带宽有限，它取决于可使用的频率资源和信道的传播特性。(2) 干扰和噪声大，这主要是移动通信工作的电磁环境所决定。(3) 存在多径衰落。 针对信道的特点，已调信号应具有高的频谱利用率和较强的抗干扰、抗衰落的特点。 噪声与干扰1除有用信号以外的一切无用信号，一般把系统内部产生的无用信号称作噪声，系统外部引入的无用信号称作干扰。 信号损耗无线链路损耗典型：自由空间传输损耗 Lfs=32.44+20lgd(D)+20lgf(F) Lfs：传输损耗 F：频率（MHz） D：距离（KM） 脉冲编码调制（PCM）抽样1对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号，抽样必须遵循奈奎斯特抽样定理。该模拟信号经过抽样后还应当包含原信号中所有信息，也就是说能无失真的恢复原模拟信号。它的抽样速率的下限是由抽样定理确定的。抽样速率采用8KHZ。 量化1把经过抽样得到的瞬时值将其幅度离散，即用一组规定的电平，把瞬时抽样值用最接近的电平值来表示,通常是用二进制表示。 编码1用一组二进制码组来表示每一个有固定电平的量化值。然而，实际上量化是在编码过程中同时完成的，故编码过程也称为模&#x2F;数变换，可记作A&#x2F;D。 调制技术BPSK1二进制相移键控(Binary Phase Shift Keying，BPSK)是把模拟信号转换成数据值的转换方式之一，利用偏离相位的复数波浪组合来表现信息键控移相方式。BPSK使用了基准的正弦波和相位反转的波浪，使一方为0，另一方为1，从而可以同时传送接受2值(1比特)的信息。 QPSK1正交相移键控（Quadrature Phase Shift Keying，QPSK）是一种数字调制方式。它分为绝对相移和相对相移两种。由于绝对相移方式存在相位模糊问题，所以在实际中主要采用相对移相方式DQPSK。 8PSK18PSK (8 Phase Shift Keying 8移相键控) 是一种相位调制算法。相位调制（调相）是频率调制（调频）的一种演变，载波的相位被调整用于把数字信息的比特编码到每一次相位改变（相移）。 16QAM116QAM全称正交幅度调制是英文Quadrature Amplitude Modulation的缩略语简称，意思是正交幅度调制，是一种数字调制方式。产生的方法有正交调幅法和复合相移法 64QAM164QAM，Quadrature Amplitude Modulation，指的是相正交振幅调制。 多址技术频分多址1频分复用（FDM）是指载波带宽被划分为多种不同频带的子信道，每个子信道可以并行传送一路信号的一种技术。频分复用技术下，多个用户可以共享一个物理通信信道，该过程即为频分多址复用（FDMA）。FDMA 模拟传输是效率最低的网络，这主要体现在模拟信道每次只能供一个用户使用，使得带宽得不到充分利用。 时分多址1允许多个用户在不同的时间片（时隙）来使用相同的频率。用户迅速的传输，一个接一个，每个用户使用他们自己的时间片。 码分多址1码分多址(CDMA)的基本思想是靠不同的地址码来区分的地址。每个配有不同的地址码，用户所发射的载波(为同一载波)既受基带数字信号调制，又受地址码调制，接收时，只有确知其配给地址码的接收机，才能解调出相应的基带信号，而其他接收机因地址码不同，无法解调出信号。 正交频分复用1将信道分成若干正交子信道，将高速数据信号转换成并行的低速子数据流，调制到在每个子信道上进行传输。正交信号可以通过在接收端采用相关技术来分开，这样可以减少子信道之间的相互干扰 ICI。每个子信道上的信号带宽小于信道的相关带宽，因此每个子信道上的可以看成平坦性衰落，从而可以消除符号间干扰。 多天线技术SISO单发单收 SIMO分集接收 Beanforming波束赋形 MIMO多进多出（STC，SM）","categories":[{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"ACL配置练习","slug":"acl","date":"2020-03-04T04:30:11.000Z","updated":"2021-07-17T02:31:33.169Z","comments":true,"path":"2020/03/04/acl/","link":"","permalink":"https://imqinhao.cn/2020/03/04/acl/","excerpt":"为了增强网络的安全性，可以通过防火墙禁止未经授权或可能存在危险的访问进入网络。ACL包过滤技术就是一种被广泛应用于防火墙的网络安全技术。","text":"为了增强网络的安全性，可以通过防火墙禁止未经授权或可能存在危险的访问进入网络。ACL包过滤技术就是一种被广泛应用于防火墙的网络安全技术。 任务基础配置任务12（1）按图中所示配置各计算机、服务器、路由器对应端口的IP地址相关信息；（2）在路由器R0、R1、R2上启动rip v2协议，使得全网互通。 ACL配置任务12（1）禁止PC0 ping通外网，允许PC2 ping通外网；（标准acl，序号1）（2）禁止PC2访问服务器Server0的web服务，但可以ping通服务器Server0。（扩展acl，序号101） 实现步骤11、如图所示，全网由内网1、内网2及ISP（运营商网络：模拟互联网）组成，首先配置各计算机、服务器、路由器对应端口的IP地址相关信息，使用show ip route、ping命令测试网络并记录输出信息。 设备名称 接口 IP地址 网关 R0 Fa0/0 192.168.22.254/24 R0 Se0/3/0 58.1.1.1/30 R1 Fa0/0 192.168.18.254/24 R1 Se0/3/0 210.28.144.2/30 R2 Se0/1/0 58.1.1.2/30 R2 Se0/0/0 210.28.144.1/30 Server0 192.168.18.250/24 192.168.18.254/24 PC0 192.168.22.10/24 192.168.22.254/24 PC2 192.168.22.20/24 192.168.22.254/24 PC3 192.168.18.10/24 192.168.18.254/24 PC5 192.168.18.20/24 192.168.18.254/24 基础配置Router0配置Fa0/0端口123456R0&gt; enable #进入特权模式R0# config terminal #进入全局模式R0(config)# interface fastEthernet 0&#x2F;0 #进入Fa0&#x2F;0端口R0(config-if)# ip address 192.168.22.254 255.255.255.0 #配置IP和子网掩码R0(config-if)# no shutdown #开启端口R0(config-if)# exit #退回Fa0&#x2F;0端口 Router0配置Se0/3/0端口12R0(config)# interface serial 0&#x2F;3&#x2F;0 #配置se0&#x2F;3&#x2F;0端口R0(config-if)# ip address 58.1.1.1 255.255.255.252 #配置IP和子网掩码 Router2配置Se0/1/0端口123456R2&gt; enable #进入特权模式R2# config terminal #进入全局模式R2(config)# interface serial 0&#x2F;1&#x2F;0 #进入se0&#x2F;1&#x2F;0端口R2(config-if)# ip address 58.1.1.2 255.255.255.252 #配置IP和子网掩码R2(config-if)# no shutdown #开启端口R2(config-if)# exit #退出se0&#x2F;1&#x2F;0端口 Router2配置Se0/0/0端口1234R2(config)# interface serial 0&#x2F;0&#x2F;0 #进入se0&#x2F;0&#x2F;0端口R2(config-if)# ip address 210.28.144.1 255.255.255.252 #配置IP和子网掩码R2(config-if)# no shutdown #开启端口R2(config-if)# exit #退出se0&#x2F;0&#x2F;0端口 Router1配置Se0/3/0端口123456R1&gt; enable #进入特权模式R1# config terminal #进入全局模式R1(config)# interface serial 0&#x2F;3&#x2F;0 #进入se0&#x2F;3&#x2F;0端口R1(config-if)# ip address 210.28.144.2 255.255.255.252 #配置IP和子网掩码R1(config-if)# no shutdown #配置IP和子网掩码R1(config-if)# exit #退出se0&#x2F;3&#x2F;0端口 Router1配置Fa0/0端口123R1(config)# interface fastEthernet 0&#x2F;0 #进入Fa0&#x2F;0端口R1(config-if)# ip address 192.168.18.254 255.255.255.0 #配置IP和子网掩码R1(config-if)# no shutdown #配置IP和子网掩码 Router0路由表 Router1路由表 Router2路由表 PC0 ping PC5 全网互通（RIP配置)R0:RIP 2配置123456R0(config)# router rip #启动rip协议R0(config-router)# version 2 #指定rip v2版本R0(config-router)# no auto-summary #关闭路由器自动汇总功能R0(config-router)# network 192.168.22.0 #宣告自己的网段R0(config-router)# network 58.1.1.1 #宣告自己的网段R0(config-router)# exit #退出rip配置模式 R1:RIP 2配置123456R1(config)# router rip #启动rip协议R1(config-router)# version 2 #指定rip v2版本R1(config-router)# no auto-summary #关闭路由器自动汇总功能R1(config-router)# network 192.168.18.0 #宣告自己的网段R1(config-router)# network 210.28.144.2 #宣告自己的网段R1(config-router)# exit #退出rip配置模式 R2:RIP 2配置123456R1(config)# router rip #启动rip协议R1(config-router)# version 2 #指定rip v2版本R1(config-router)# no auto-summary #关闭路由器自动汇总功能R1(config-router)# network 58.1.1.2 #宣告自己的网段R1(config-router)# network 210.28.144.1 #宣告自己的网段R1(config-router)# exit #退出rip配置模式 Router0路由表 Router1路由表 Router2路由表 PC0 ping PC5 R0配置标准ACL1在R0上配置标准ACL，禁止PC0 ping PC5,允许PC2 ping PC5,请思考需采用几条ACL，应用于R0那个端口、什么方向;配置完毕后，PC0 ping PC5显示什么信息？ 配置ACL12R0(config)# access-list 1 permit host 192.168.22.20 #允许主机192.168.22.20的数据包R0(config)# access-list 1 deny any #拒绝其他所有的数据包 接口及方向12R0(config)# interface serial 0&#x2F;3&#x2F;0 #进入接口se0&#x2F;3&#x2F;0端口R0(config-if)# ip access-group 1 out #将指定的访问列表应用到se0&#x2F;3&#x2F;0接口的入方向 PC0 ping PC5 PC0 PING PC3能通吗，为什么？1解析：PC0 不能ping通PC3，因为我们配置了标准acl，在R0的进方向就已经将PC0发出的数据包拒绝了，我们设置了在192.168.22.0&#x2F;24中只允许192.168.22.20发出的数据，其他主机无法向外网发送数据。 PC2 ping PC5 能通吗，为什么？1PC2可以ping通PC5.因为我们写的acl配置就是运行主机PC2访问外网，而且由于之前我们写了RIP，保证了全网互通，所以PC2可以ping通PC5。 R0配置拓展ACL1在R0上配置扩展ACL，禁止PC2访问服务器WEB服务，但是可以ping通服务器，请思考需采用几条ACL，应用于R0那个端口、什么方向;配置完毕后，PC0访问服务器WEB服务显示什么信息？ 配置ACL12R0(config)# access-list 101 deny tcp host 192.168.22.20 0.0.0.0 192.168.18.250 eq www #拒绝主机192.168.22.20向主机192.168.18.250的www请求R0(config)# access-list 101 permit ip any any #允许访问列表101的任意IP通过控制列表 端口及方向1234R0(config)# interface fastEthernet 0&#x2F;0 #进入Fa0&#x2F;0端口R0(config-if)# ip access-group 101 in #将指定的访问列表应用到Fa0&#x2F;0接口的入方向--------------------------------------------------------------------------------------解析：根据ACL的放置原则，拓展ACL应放置在尽可能靠近需要过滤的流量源的位置上，所以应该选择接口R0的Fa0&#x2F;0接口。由于要检查的数据流是从接口Fa0&#x2F;0流入的，所以检查方向为“in”。 PC0访问服务器WEB服务 思考题对于标准型ACL，应该放在网络什么位置；而对于扩展型ACL，又应该放在网络什么位置？ 12标准ACL不指定目的地址，所以其位置应该尽可能靠近目的地。根据ACL的放置原则，拓展ACL应放置在尽可能靠近需要过滤的流量源的位置上。 在IP访问列表中，如果到最后也没有找到匹配，则传输数据包将如何处理？（以cisco为例） 1如果都不匹配，那么一定匹配最后的隐含拒绝条目，思科默认拒绝。 你该如何安排访问列表中条目顺序？ 1234①最小特权原则。只给受控对象完成任务所必需的最小的权限，因为总规则是各个规则的交集，只满足部分条件的是不容许通过的。②最靠近受控对象原则。检查规则时是采用自上向下的形式在ACL中逐条检测的，只要发现符合条件的就立刻转发，不再继续检测后面的ACL语句。③默认丢弃原则。如果都不匹配，那么一定匹配最后的隐含拒绝条目，思科默认拒绝。④拓展ACL中具体的判别条目放在前面，标准ACL按照主机、网络、any排序。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://imqinhao.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"计算机网络基础知识","slug":"computer_network_basics","date":"2020-02-27T05:14:20.000Z","updated":"2021-07-17T02:38:37.024Z","comments":true,"path":"2020/02/27/computer_network_basics/","link":"","permalink":"https://imqinhao.cn/2020/02/27/computer_network_basics/","excerpt":"计算机网络基础知识，简单介绍了IP地址，TCP与UDP，路由器以及VPN等相关知识。","text":"计算机网络基础知识，简单介绍了IP地址，TCP与UDP，路由器以及VPN等相关知识。 1IPv4中的v是英文version的缩写，表示版本。 1IP地址一共有32位，用点分十进制表示。 私有地址：123A类： 10.0.0.0&#x2F;8B类： 172.16.0.0&#x2F;12C类： 192.168.0.0&#x2F;16 广播地址1网络位不变，主机位全1 Windows查看ip地址1ipconfig Linux查看ip地址1ifconfig 专业术语123456Cable：线缆Physical Layer：物理层Data Link Layer：数据链路层Network Layer：网络层Transport Layer：传输层Application Layer：应用层 组播地址1组播IP地址以224段开头。 TCP与UDP1234567TCP&#x2F;UDP工作在传输层。TCP特点：传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。UDP特点：无连接、不可靠、快速传输TCP提供可靠的传输，UDP提供不可靠的传输。 Windows常用命令解析1234ping：利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。trace：TRACE和TRACK是用来调试web服务器连接的HTTP方式。ICMP：在主机与路由器之间传递控制信息，是网络层的协议。IGMP：主要用于主机和多播路由器的请求和探询。 单模光纤与多模光纤123单模光纤：传输距离远，色散小，造价高。一般单模光纤跳线用黄色表示。多模光纤：传输距离短，带宽大，造价低。一般多模光纤跳线用橙红色，灰色等颜色表示。 光纤常见类型1SC，ST，LC，FC。 什么是路由？1路由的概念就是将多个不同子网的IP，进行转发通信。选择一个将数据包发往某个目标网段或主机的路径就是路由的过程。 路由器的概念1用来表示逻辑源和逻辑目的地址的是IP地址，因此我们认为路由的过程是将不同IP地址网段的IP包进行转发。实现这一功能的设备我们称之为路由器。 数据包路由过程1在路由的过程中，三层地址不变，二层地址随着下跳的改变而改变。 如何进行路径选择？12路径选择依据：根据信宿地址确定下一个站点是谁路径选择方法：查看邮局各自去往信宿的路由表 路由必须要有回指路由，保证有去有回。 策略路由1策略路由，是一种比基于目标网络进行路由更加灵活的数据包路由转发机制。路由器将通过路由图决定如何对需要路由的数据包进行处理，路由图决定了一个数据包的下一跳转发路由器。它分为目的地址路由，源地址路由。 VPN概念1虚拟专用网技术，顾名思义，虚拟专用网不是真的专用网络，但却能够实现专用网络的功能。 ISP与NSP123ISP：Internet服务提供商。NSP：网络服务提供商。 VPN按应用类型分布Access VPN（远程访问虚拟网）1Access VPN最适用于公司内部经常有流动人员远程办公的情况。 Intranet VPN（企业内部虚拟网）1Intranet VPN通过公网网络进行企业内部的互联，是传统专网或其它企业网的扩展或替代形式。 Extranet VPN（企业拓展虚拟网）1Extranet利用VPN将企业网延伸至供应商、合作伙伴与客户处，在具有共同利益的不同企业间通过公网构筑VPN，使部分资源能够在不同VPN用户间共享。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://imqinhao.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"MySQL 8数据库基础","slug":"MySQL8_basics","date":"2020-02-27T04:50:11.000Z","updated":"2021-07-17T02:45:37.495Z","comments":true,"path":"2020/02/27/MySQL8_basics/","link":"","permalink":"https://imqinhao.cn/2020/02/27/MySQL8_basics/","excerpt":"MySQL基础语法，学习时做的笔记。","text":"MySQL基础语法，学习时做的笔记。 常用数据库命令1234create database 数据库名称; &#x2F;&#x2F;创建数据库drop database 数据库名称; &#x2F;&#x2F;删除数据库show databases; &#x2F;&#x2F;查看数据库use 数据库名; &#x2F;&#x2F;使用数据库 更改加密方式123ALTER USER&#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER;ALTER USER&#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;FLUSH PRIVILEGES; 创建学生表123456CREATE TABLE 表名称( 列表名1 数据类型 [约束], 列表名2 数据类型 [约束], ... 列表名n 数据类型 [约束]); 添加一列1ALTER TABLE 表名称 ADD 列表名 数据类型; 修改一个表的字段类型1alter table 表名称 modify 修改的列表名 数据类型(长度); 查看表结构1desc 表名称; 修改表名称1RENAME TABLE 原始表名称 TO 要修改成的表名称; 修改字符集1ALTER TABLE 表名称 CHARACTER SET 字符集名称; 修改表的列名1ALTER TABLE 表名称 CHANGE 原始列名 新列名 数据类型; 注释1# 查看表的字段信息1desc 表名称; 删除一列：1ALTER TABLE 表名称 DROP 字段名称; 删除表1DROP TABLE 表名称;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://imqinhao.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"OLT基础命令","slug":"OLT_command","date":"2020-02-27T04:13:14.000Z","updated":"2021-07-17T02:47:37.348Z","comments":true,"path":"2020/02/27/OLT_command/","link":"","permalink":"https://imqinhao.cn/2020/02/27/OLT_command/","excerpt":"适用于华为OLT的基础命令，这是当时学习时做的笔记。","text":"适用于华为OLT的基础命令，这是当时学习时做的笔记。 1、基础命令模式功能及特性列表 命令模式 功能 模式提示符实例 命令 普通用户模式 查看系统基本信息 huawei&gt; 登录后进入 特权模式 进行系统基本配置 huawei# enable 全局配置模式 配置系统设备及全局性参数 huawei(config)# config 2、基础命令 查看ONU相关信息 123命令语法：display onu nat information命令功能：用于查询通过OLT代理管理的ONU设备相关信息，包括ONU的公网IP地址，管理通道的VLAN ID以及ONU上行SNMP报文的优先级；以及ONU私网IP地址池的起始IP地址和范围。 配置ONU管理通道的VLAN 123456命令语法：onu nat vlan vlanid命令功能：配置VLAN ID的前提是OLT通过NAT代理管理ONU功能为使能状态。配置的目的是用于xPON单板根据此VLAN ID抓取ONU报文。参数说明：vlanid：设置ONU所属的代理管理通道的VLAN ID。其取值为数值类型，范围：2-4093。 对以太网接口进行配置 123456命令语法：interface eth frameid&#x2F;slotid命令功能：此命令用于从全局配置模式进入到ETH模式。当需要在ETH模式下配置以太网口时，使用此命令。参数说明：frameid&#x2F;slotid：用于标识机框号&#x2F;槽位号。“&#x2F;”需原样输入。当需要对某一指定槽位下发命令时使用此参数。 对GPON端口进行配置 123456命令语法：interface gpon frameid&#x2F;slotid命令功能：此命令用于从全局配置模式进入到GPON模式。当需要在GPON模式下对GPON端口进行配置时，使用此命令。参数说明：frameid&#x2F;slotid：用于标识机框号&#x2F;槽位号。“&#x2F;”需原样输入。当需要对某一指定槽位下发命令时使用此参数。 对管理网口进行配置 123456命令语法：interface meth number命令功能：此命令用于从全局配置模式进入到METH模式。进入METH模式后，可以配置维护网口的IP地址、Firewall以及接口的速率和双工状态等参数。参数说明：number：维护网口的编号，固定为0。number取数值类型，取值范围：0。 创建VLANIF接口并进入VLANIF模式 123456命令语法：interface vlanif vlan-id命令功能：interface vlanif命令用于从全局配置模式创建VLANIF接口并进入VLANIF模式。在VLANIF模式下，可以对虚拟的三层接口进行DHCP、防火墙、IP地址、MPLS、DHCP server、ARP等相关配置。参数说明：vlan-id：VLAN ID，输入的VLAN ID必须已经存在。取值类型为数值类型，取值范围：1-4093。 删除VLANIF接口 123456命令语法：undo interface vlanif vlan-id命令功能：undo interface vlanif命令用于删除指定的VLANIF接口。当系统中没有创建VLANIF接口时，无法执行此命令。参数说明：undo interface vlanif：命令的执行交互界面中仅显示已经创建VLANIF接口的VLAN ID。 回退至前一级模式 123命令语法：quit命令功能：从当前模式（除Rsa-public-key模式、Rsa-key-code模式外的任何模式）退回到前一级模式或者退出配置环境。 一次性退回特权模式 123命令语法：return命令功能：从当前模式（除普通用户模式、特权模式、Rsa-public-key模式、Rsa-key-code模式、Security模式之外的任何模式）“一次性”退回到特权模式。 设置OLT通过NAT代理管理ONU设备功能的状态 123命令语法：onu nat &#123; enable | disable &#125;命令功能：此命令用于设置OLT通过NAT代理管理ONU设备功能的状态。当该功能为使能状态时，可以通过OLT代理管理ONU设备；当该功能为去使能状态时，不能通过OLT代理管理ONU设备，并且该功能去使能以后会终止业务引发用户配置信息会丢失，下次开关使能后需要重新配置UDP端口号等分配信息。 设置网络侧UDP起始端口号 123456命令语法：onu nat base-port port-number命令功能：此命令用于在ONU代理模式下，设置网络侧的UDP起始端口号。参数说明：port-number：UDP起始端口号。数值类型，取值范围：0-30720。缺省值：10000。 配置ONU的公网IP地址 123456命令语法：onu nat ip ip-addr 命令功能：此命令用于在使能OLT通过NAT代理管理ONU设备的功能时，配置ONU的公网IP地址。由于网管对ONU设备的查询和设置是基于公网IP地址的，在采取了OLT代理管理ONU设备的方式以后，网管看不到ONU的私网IP地址。因而，需要给ONU设备设置公网IP地址，便于实现网管通过ONU公网IP地址查询ONU的信息。参数说明：ip ip-addr：配置全局IP地址，点分十进制形式，且配置以后不许改变。此IP地址是单播IP地址。IP地址采用点分十进制，取值范围：0.0.0.0-255.255.255.255。缺省值：10.10.10.10 配置ONU的私网IP地址池的起始IP地址和范围 1234567命令语法：onu nat ip-pool &#123; start-address ip-addr scope scope-value &#125; 命令功能：此命令用于在去使能OLT通过NAT代理管理ONU设备的功能时，配置ONU的私网IP地址池的起始IP地址和范围，支持用户根据实际情况配置ONU的私网IP地址和IP地址的个数。参数说明：start-address ip-addr ：配置ONU私网IP地址池的起始IP地址，点分十进制形式。此IP地址是单播IP地址。IP地址采用点分十进制，取值范围：0.0.0.0-255.255.255.255。缺省值：10.0.0.0。scope scope-value ：配置ONU私网IP地址池的范围，也就是用户指定的IP的个数。数值类型，取值范围：1024-5120。缺省值：5120。 设置ONU上行SNMP报文的优先级。 123456命令语法：onu nat priority priority-value命令功能：onu nat priority命令用于使能OLT通过NAT代理管理ONU功能时，配置ONU上行SNMP报文的优先级。参数说明：priority priority-value ：设置ONU上行SNMP报文的优先级。数值类型，取值范围：0-7。默认值：7 配置ONU管理通道的VLAN ID 123456命令语法：onu nat vlan命令功能：此命令用于使能OLT通过NAT代理管理ONU功能时，配置ONU管理通道的VLAN ID。配置ONU管理通道的VLAN ID主要用于xPON单板通过VLANID抓取ONU报文。参数说明：vlan vlanid ：设置ONU所属的代理管理通道的VLAN ID。数值类型，取值范围：2-4093。","categories":[{"name":"交换机","slug":"交换机","permalink":"https://imqinhao.cn/categories/%E4%BA%A4%E6%8D%A2%E6%9C%BA/"}],"tags":[]},{"title":"交换机端口安全配置练习","slug":"switchport-security","date":"2020-02-27T03:11:11.000Z","updated":"2021-07-17T02:50:28.706Z","comments":true,"path":"2020/02/27/switchport-security/","link":"","permalink":"https://imqinhao.cn/2020/02/27/switchport-security/","excerpt":"实验用到的知识点： 启用端口安全功能配置 端口安全mac地址配置 端口安全mac地址数目配置 端口安全违规处理方式配置","text":"实验用到的知识点： 启用端口安全功能配置 端口安全mac地址配置 端口安全mac地址数目配置 端口安全违规处理方式配置 任务 VLAN及VLAN间路由配置； 端口安全应用配置：左边网络中只允许PC0接入C1，右边网络允许两个终端用户接入C1； 实现步骤 如图所示，二层结构构建的本地网络包括一个核心交换机和两个接入交换机，按图示要求为S1、S2划分VLAN及成员。 记录表格： 设备名 接口 IP地址/掩码 网关地址 备注 C1 vlan 1 10.35.1.254/24 C1 vlan 2 10.35.2.254/24 S1 Fa0/1 vlan 1 S1 Fa0/2 vlan 2 S1 Fa0/3 mac: 0001.96ce.1e03 S2 Fa0/1 vlan 1 S2 Fa0/2 vlan 2 S2 Fa0/3 mac: 00e0.b086.8803 PC0 10.35.1.1/24 10.35.1.254/24 mac: 0060.7020.93BB PC1 10.35.2.1/24 10.35.2.254/24 mac: 0090.2150.050B PC2 10.35.1.2/24 10.35.1.254/24 mac: 0004.9A58.D178 PC3 10.35.2.2/24 10.35.2.254/24 mac: 0002.17B3.896B 配置VLAN间路由 在S1、S2、C1进行设置，最终实现PC间的互Ping，各PC均可ssh C1 S1: 中继接口123456789S1(config)# vlan 2 #创建vlan2S1(config-vlan)# exit #回到全局模式S1(config)# interface fastEthernet 0&#x2F;2 #进入2号接口S1(config-if)# switchport mode access #定义端口工作模式为accessS1(config-if)# switchport access vlan 2 #将端口加入到vlan 2S1(config-if)# exit #回到全局模式S1(config)# interface fastEthernet 0&#x2F;3 #进入3号接口S1(config-if)# switchport mode trunk #定义端口工作模式为trunkS1(config-if)# exit #回到全局模式 S2: 中继接口123456789S2(config)# vlan 2 #创建vlan2S2(config-vlan)# exit #回到全局模式S2(config)# interface fastEthernet 0&#x2F;2 #进入2号接口S2(config-if)# switchport mode access #定义端口工作模式为accessS2(config-if)# switchport access vlan 2 #将端口加入到vlan 2S2(config-if)# exit #回到全局模式S2(config)# interface fastEthernet 0&#x2F;3 #进入3号接口S2(config-if)# switchport mode trunk #定义端口工作模式为trunkS2(config-if)# exit #回到全局模式 C1：SSH 主机名C1、域名wtctx、用户名、密码均为txXX、enable不加密密码tx18XX（XX为学号最后2位） 12345678910C1(config)# hostname C1 #设置主机名为C1C1(config)# ip domain-name wtctx #设置域名为wtctxC1(config)# crypto key generate rsa #生成rsa秘钥C1(config)# line vty 0 15 #进vty接口，最多15人同时在线C1(config-line)# transport input ssh #启用SSH登录C1(config-line)# privilege level 15 #设置用户操作等级为最高级C1(config-line)# login local #使用本地验证C1(config-line)# exit #回退到全局模式C1(config)# username tx11 password tx11 #创建用户tx11，密码为tx11C1(config)# enable password tx1811 #设置enable明文密码 C1：中继接口1234C1(config)# interface range fastEthernet 0&#x2F;1-2 #进入0&#x2F;1和0&#x2F;2端口C1(config-if)# switchport trunk encapsulation dot1q #封装vlan帧C1(config-if)# switchport mode trunk #定义接口工作模式C1(config-if)# exit #退出端口 C1：开启路由功能1C1(config)# ip routing #开启路由功能 C1：设置各VLAN网关地址 地址为该网段最大主机地址（注意VLAN接口默认关闭且手工打开） 123456789C1(config)# vlan 2 #创建vlan 2C1(config-vlan)# exit #退回到全局模式C1(config)# interface vlan 1 #进入vlan1接口C1(config-if)# ip address 10.35.1.254 255.255.255.0 #配置IP和子网掩码C1(config-if)# no shutdown #接口启用C1(config-if)# exit #退出vlan1接口C1(config)# interface vlan 2 #进入vlan2接口C1(config-if)# ip address 10.35.2.254 255.255.255.0 #配置IP和子网掩码C1(config-if)# exit #退出vlan2接口 记录结果 为各PC设置网关地址，设置完毕PC0 分别ping PC1 和PC2，记录结果。 端口安全配置。C1：fa0/1开启安全端口功能 配置时建议关闭端口，关闭端口可清空mac地址表 123C1(config)# interface fastEthernet 0&#x2F;1 #进入Fa0&#x2F;1接口C1(config-if)# shutdown #关闭端口C1(config-if)# switchport port-security #开启安全端口功能 C1：fa0/1安全端口禁用DTP1C1(config-if)# switchport nonegotiate #禁用DTP C1：fa0/1安全端口允许最大地址数123C1(config-if)# switchport port-security maximum 3 #设置允许最大地址数------------------------------------------------------------------------解析：C1从Fa0&#x2F;1学习地址时会优先学习与之直连的接口地址（即S1交换机的Fa0&#x2F;3端口），C1上有两个VLAN对应两条，加上静态指定的共有三条； C1：fa0/1安全端口指定允许接入的地址1C1(config-if)# switchport port-security mac-address 0060.7020.93BB C1：fa0/1安全端口指定违规处理行为 建议使用protected，思考为什么 123C1(config-if)# switchport port-security violation protect------------------------------------------------------------------------解析：违规方式采用protect是为了确保网络能为合规的数据提供继续的服务，若采用默认方式，违规后端口将自动关闭，从而导致网络不可用。 C1：fa0/2开启安全端口功能 配置时建议关闭端口，关闭端口可清空mac地址表 12345C1(config-if)# no shutdown #开启Fa0&#x2F;1端口C1(config-if)# exit #退出Fa0&#x2F;1端口C1(config)# interface fastEthernet 0&#x2F;2 #进入Fa0&#x2F;2端口C1(config-if)# shutdown #关闭Fa0&#x2F;2端口C1(config-if)# switchport port-security #开启安全端口功能 C1：fa0/2安全端口禁用DTP1C1(config-if)# switchport nonegotiate #禁用DTP C1：fa0/2安全端口允许最大地址数 思考数值设置多少合理，依据是什么 123C1(config-if)# switchport port-security maximum 5 #设置允许最大地址数------------------------------------------------------------------------解析：C1会粘滞5个来自Fa0&#x2F;2的mac地址记录，分别是从Fa0&#x2F;1学习地址时会优先学习与之直连的接口地址（即S1交换机的Fa0&#x2F;3端口），vlan1和vlan2接口的mac地址，PC2和PC3的mac地址。 C1：fa0/2安全端口采用地址粘滞功能1C1(config-if)# switchport port-security mac-address sticky C1：fa0/2安全端口指定违规处理行为 建议使用protected，思考为什么 123C1(config-if)# switchport port-security violation protect------------------------------------------------------------------------解析：违规方式采用protect是为了确保网络能为合规的数据提供继续的服务，若采用默认方式，违规后端口将自动关闭，从而导致网络不可用。 记录结果 设置完毕PC0 分别ping PC1 和PC2，记录结果，思考原因 1解析：虽然已经做到了全网互通，但是由于PC1没有设置允许它接入，且设置了保护模式为protect，所以PC1的数据流量对于交换机来说是违规的，端口对PC1的数据进行丢弃，所以PC0的数据无法发送给PC1。 思考 1解析：此时mac地址表会出现共5个来自Fa0&#x2F;2的mac地址记录，分别是从Fa0&#x2F;1学习地址时会优先学习与之直连的接口地址（即S1交换机的Fa0&#x2F;3端口），vlan1和vlan2接口的mac地址，PC2和PC3的mac地址。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://imqinhao.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"思科交换机开启ssh远程","slug":"ssh","date":"2020-02-24T09:52:30.000Z","updated":"2021-07-17T02:49:43.869Z","comments":true,"path":"2020/02/24/ssh/","link":"","permalink":"https://imqinhao.cn/2020/02/24/ssh/","excerpt":"由于传统的telnet方式使用明文的方式进行密码和数据的传送，对于安全性我们无法得到保障，那么接下来介绍一下通过ssh方式远程，ssh方式使用了加密的方式进行密码和数据的传输，提高了网络设备的安全性。","text":"由于传统的telnet方式使用明文的方式进行密码和数据的传送，对于安全性我们无法得到保障，那么接下来介绍一下通过ssh方式远程，ssh方式使用了加密的方式进行密码和数据的传输，提高了网络设备的安全性。 配置IPSwitch&gt; enable #进入管理员模式 Switch# config terminal #进入全局模式 Switch(config)# interface vlan 1 #进入vlan1接口 Switch(config)# ip address 192.168.0.1 255.255.255.0 #配置IP地址和子网掩码 Switch(config)# no shutdown #启用vlan 1接口修改主机名Switch(config)# hostname MS1 #修改交换机的主机名，后期配置域名的主机名配置域名MS1(config)# ip domain-name qinhao.com #配置域名生成rsa秘钥MS1(config)# crypto key generate rsa #生成rsa秘钥，默认长度为512，建议修改为1024定义ssh远程的线路MS1(config)# line vty 0 15 #进入vty端口模式 MS1(config)# transport input ssh MS1(config)# privilege level 15 MS1(config)# login local创建本地用户MS1(config)# username qinhao password zyy520设置enable登录密码MS1(config)# enable secret 123456 #进入管理员模式需要的密码PC0通过ssh远程连接MS1pc&gt; ssh -l qinhao 192.168.0.1 #ssh用法：ssh -l 用户名 IP地址 open #会提示我们开启 Password: zyy520 #输入ssh用户的密码","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://imqinhao.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"Web站点数字证书(5)","slug":"Web_site_SSL","date":"2020-02-15T11:29:30.000Z","updated":"2021-07-17T02:51:40.814Z","comments":true,"path":"2020/02/15/Web_site_SSL/","link":"","permalink":"https://imqinhao.cn/2020/02/15/Web_site_SSL/","excerpt":"内容： Web站点数字证书难度： ★★★★☆","text":"内容： Web站点数字证书难度： ★★★★☆ Web站点数字证书的申请和安装包括3个部分：申请数字证书、下载数字证书、安装数字证书。 申请数字证书1.添加CA证书服务。 【开始】—&gt;【管理工具】—&gt;【服务器管理器】—&gt;【角色】—&gt;【添加角色】—&gt;勾选【Active Directory证书服务】。 开始–&gt; 管理工具 –&gt; 服务器管理器 角色 –&gt; 添加角色 下一步 勾选【Active Directory证书服务】，点击【下一步】 点击【下一步】 勾选【证书颁发机构】和【证书颁发机构Web注册】，点击下一步。 点击【下一步】 选择【根CA】，点击下一步。 选择【新建秘钥】，点击【下一步】 点击【下一步】 点击【下一步】 点击【下一步】 点击【下一步】 检查无误，点击【安装】 等待安装完成 点击【关闭】 2.创建证书申请 选择【角色】–&gt;【Web服务器(IIS)】–&gt;【Internet信息服务】–&gt;右侧主机–&gt;【服务器证书】 选择到期日期为5年之后的，点击右侧【创建证书申请】 通用名称须填写网站绑定的IP，其他可随意填写，填写完成点击【下一步】 点击【下一步】 选择路径并设置文件名，点击【完成】 完成后会回到此界面 下载数字证书1.申请证书 浏览器地址栏输入localhost/certsrv 点击【申请证书】 点击【高级证书申请】 找到之前下载的文件，打开并复制所有内容 在【保存的申请】文本框将复制的内容粘贴，点击【提交】 提示证书正在挂起，以及ID 2.颁发证书 【角色】–&gt;【Active Directory 证书服务】–&gt;【Win …】–&gt;【挂起的申请】 找到刚刚对应的ID，右键，【所有任务】—&gt;【颁发】 点击左侧【颁发的证书】，查看对应的ID证书是否已颁发 3.下载证书 浏览器地址栏输入localhost/certsrv，点击【查看挂起的证书申请的状态】 点击【保存的申请证书】 点击【下载证书】 安装数字证书1.安装数字证书 找到刚刚下载证书的文件 选择【Web服务器(IIS)】–&gt;【Internet信息服务(IIS)】–&gt;【Win…】–&gt;【服务器证书】 选择到期时间为5年后的，点击【完成证书申请】 选择刚刚浏览器下载的证书文件，输入名称，点击【确定】 在服务器证书列表查看新证书是否出现在列表 2.绑定网站类型为HTTPS 选择自己的网站，点击右侧【绑定】 点击【添加】 类型为HTTPS，IP为网站绑定IP，选择SSL证书，点击【确定】 3.启用SSL 选择【SSL设置】 勾选【要求SSL】，将客服证书设置为【接受】，点击【应用】 最终效果 接下来就可以用https访问网站啦","categories":[{"name":"服务器","slug":"服务器","permalink":"https://imqinhao.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[]},{"title":"一台服务器创建多个Web站点(4)","slug":"a_server_build_many_webs","date":"2020-02-15T08:45:30.000Z","updated":"2021-07-17T02:31:21.001Z","comments":true,"path":"2020/02/15/a_server_build_many_webs/","link":"","permalink":"https://imqinhao.cn/2020/02/15/a_server_build_many_webs/","excerpt":"内容： 一台服务器创建多个Web站点难度： ★★★☆☆","text":"内容： 一台服务器创建多个Web站点难度： ★★★☆☆ 实现虚拟主机一般有3种方式： 使用不同的IP 使用相同的IP，不同的TCP端口 使用相同的IP和TCP端口，不同的主机头（域名） 使用不同的IP1.新建一个网站 现在实验的是使用不同的IP，所以新建网站绑定的IP地址要选择与之前新建网站的IP地址不能相同 2. 将网页文件放进网站根目录 3.网站不同IP访问 现在我们就可以通过不同的IP地址进行访问qh：192.168.74.128:80qh2 : 192.168.74.129:80 使用相同的IP，不同的TCP端口1.新建一个网站 现在实验的是使用相同的IP，但是使用不同的TCP端口，所以我们选择与之前的网站IP地址相同。 2.将网页文件放进网站根目录 3.通过相同IP不同端口访问 现在我们就可以通过相同的IP，不同的端口进行访问qh：192.168.74.128:80qh3:192.168.74.128:8080 使用相同的IP和TCP端口，不同的主机名（域名）1.新建一个网站 2.将另一个网站绑定域名 3.更改host实现本地域名解析 由于我们现在并没有使用DNS来进行域名解析，我们本地实验所有这里就以更改host文件来实现本地域名解析 4.找到记事本，以管理员身份运行。 5.点击【文件】—&gt;【打开】 6.选择host文件并打开 路径：【C:\\Windows\\System32\\drivers\\etc】，找到host文件，如果没有则在右下角选择展示所有文件。 7.添加域名解析 在host文件最下面加上：192.168.74.128 www.qinhao.com192.168.74.128 tsg.qinhao.com 8.浏览器访问www.qinhao.com 9.浏览器访问tsg.qinhao.com 10.注意事项 本方法只能使用域名对网站进行访问，不可以通过IP对网站进行访问。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://imqinhao.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[]},{"title":"Windows  Web服务器常用功能(3)","slug":"Windows_Web_often_use","date":"2020-02-15T06:23:30.000Z","updated":"2021-07-17T02:52:13.088Z","comments":true,"path":"2020/02/15/Windows_Web_often_use/","link":"","permalink":"https://imqinhao.cn/2020/02/15/Windows_Web_often_use/","excerpt":"内容： Windows Web服务器常用功能难度： ★★★☆☆","text":"内容： Windows Web服务器常用功能难度： ★★★☆☆ 给网站绑定IP地址 双击自己的网站名称，点击右侧【绑定】。 点击左边列表中的绑定，点击【编辑】。 默认的是HTTP类型，我们不可以进行更改。IP地址分为未分配和单独IP地址，IP地址的内容我们在上一篇文章已经提到了，所以不再叙述。端口号我们可以自行设置。默认是80端口，使用80端口我们就可以直接通过IP地址就可以访问，使用其它端口则需要在IP后面添加端口号，例：192.168.74.128:8080。 选择好IP地址和端口号后，点击【确定】。 更换自己的网站为默认页 首先我们可以点击右侧【浏览】，进入到网站的主目录。 将自己的网页文件放置到网站主目录。 我们可以打开浏览器输入你自己网站绑定的IP地址，我的是192.168.74.128，端口号是80，那么我们直接在浏览器输入192.168.74.128,当然，输入192.168.74.128:80也会在浏览器自动显示为192.168.74.128。 修改默认网页文件 我们可以先查看一下IIS给我们设置的默认访问文件，我们双击自己的网站名，然后找到【IIS】栏里面的【默认文档】。 下面列出来的这些就是默认访问文件，也就是我们放在根目录只要是这些文件名都将会设置为首页。如果根目录有多个下面列表的名称的文件，那么会根据列表的顺序进行访问，例如我们根目录同时有Default.htm和index.html，由于Default.htm是在index.html之前的，所以我们打开网页会显示Default.htm的内容。 将index.html设置为优先级最高的文件。点击【index.html】，然后点击右侧【上移】，移到顶部。 假如我们需要设置首页的网页是hello.html，而不是index.html。此时我们可以点击右侧【添加】。 此时会弹出【添加默认文档】对话框，输入我们需要设置主页的文件，如:hello.html，点击【确定】。 检查添加的网页文件名称是否置顶。可以看到我们新增的网站条目类型为【本地】，一般【本地】的优先级比【继承】高。 刷新浏览器，可以看到我们的已经将主页文件改成了hello.html。 设置网站访问需要验证。 验证方式常用的有： Windows身份验证 基本身份验证 匿名身份验证 摘要式身份验证。 匿名身份验证：允许匿名访问，则不需要验证用户。 基本身份验证：访问网站需要用户输入账户名及密码。但由于采用不加密的Base64编码传输，故传输并不安全。 摘要式身份验证：访问网站也需要用户输入账户名及密码，但采用了MD5的加密方式进行传输，故安全性比基本身份验证高。 Windows身份验证：希望客户端使用 NTLM 或 Kerberos 协议进行身份验证，则使用 Windows 身份验证。 默认开启的是匿名身份验证，如果同时开启了匿名身份验证和其他身份验证，会优先匿名身份认证。 安全性比较： Windows身份验证 &gt; 摘要式身份验证 &gt; 基本身份验证 &gt; 匿名身份验证 双击【IIS】栏里面的【身份验证】。 例如我们要将身份验证方式改为基本身份验证，我们首先需要关闭匿名身份验证。点击【匿名身份验证】，点击右侧【禁用】。 然后点击【基本身份验证】，点击右侧【启用】。 然后我们去浏览器刷新网页，此时会提醒我们验证身份，输入用户名和密码就可以正常访问，验证失败则会返回401错误。 设置IP地址和域限制。 设置IP地址和域限制可以限制IP或网段不允许访问网站。 双击【IIS】栏的【IP地址和域限制】。 拒绝IP或IP网段进行访问，则点击【添加拒绝条目】。 可以限制IP地址或者IP地址范围。 也可以拒绝任何人进行访问，直接点击右侧的【编辑功能设置】。 将【未指定的客户端的访问权】设置为拒绝，点击确定，此时任何IP都不可以进行网站的访问了。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://imqinhao.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[]},{"title":"Windows  Web服务器创建网站(2)","slug":"Windows_Web_build_website","date":"2020-02-14T14:22:22.000Z","updated":"2021-07-17T02:52:03.185Z","comments":true,"path":"2020/02/14/Windows_Web_build_website/","link":"","permalink":"https://imqinhao.cn/2020/02/14/Windows_Web_build_website/","excerpt":"创建一个新的网站，并将一些知识点标记了出来，学会创建一个新的网站，并且知道参数的作用是本次的目的。","text":"创建一个新的网站，并将一些知识点标记了出来，学会创建一个新的网站，并且知道参数的作用是本次的目的。 IIS新增一个网站 双击网站，点击右侧添加网站。 此时会出现添加网站的对话框。网站名称和物理路径按需求填写和选择即可。 此时我们来到绑定栏，找到类型复选框。 HTTP：默认端口80，以明文的方式进行传输，对于一般博客类网站可能会没有什么很大的问题，但是不适用于对安全性要求较高的场合，例如涉及金融，网购的一些涉及个人隐私的网站就不适用于HTTP了，现在很多网站都会使用HTTPS协议进行传输以确保数据安全。如果发现有使用HTTP方式进行传输的网站，千万不要输入银行卡等重要隐私数据以防泄露。 HTTPS: 默认端口443，以加密的方式进行传输，使用HTTPS协议需要申请CA证书，常见的有SSL证书。通过HTTPS传输的网站最大的特点便是安全，为用户的隐私提供了保障。 找到IP地址复选框。 全部未分配：如果电脑有多张网卡，则可以通过多张网卡的任何一个IP地址进行新增网站的访问。 如果选择了其中任何一个IP，则表示只能通过选择的IP访问新增的网站。 主机名，此时不用填写： 这里我们配置与否都没有任何作用，因为目前还没有搭建DNS服务器，所有域名无法解析，暂时不用填。 填写完成后点击确定。 左侧如果有你刚刚新建的网站名，表明新建成功。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://imqinhao.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[]},{"title":"Windows  Web服务器环境搭建(1)","slug":"Windows_Web_build_environment","date":"2020-02-14T13:21:21.000Z","updated":"2021-07-17T02:51:51.626Z","comments":true,"path":"2020/02/14/Windows_Web_build_environment/","link":"","permalink":"https://imqinhao.cn/2020/02/14/Windows_Web_build_environment/","excerpt":"IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。","text":"IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。 Windows Web服务器配置 我们需要安装IIS工具才能搭建网站。我们依次点击开始 —&gt; 管理工具 —&gt; 服务器管理器。 进入服务器管理器界面后，我们点击角色。 点击添加角色。 此时我们会进入添加角色向导，如果不想每次提醒的话可以勾选下面的默认情况下将跳过此页，点击下一步。 此时我们进入到选择服务器角色，勾选Web服务器(IIS)，点击下一步。 此时会出现Web服务器的简介和注意事项，我们直接点击下一步。 选择需要安装的服务，这里我就直接全部勾选，全部安装了（建议将FTP也勾选上），点击下一步。 确认信息，确保无误之后我们就可以点击安装。 等待安装。 安装完成以后，点击关闭。 如果在角色摘要里面看到了Web服务器(IIS)就表明我们安装成功。 点击角色前面的“+”号将其展开，找到Web服务器(IIS)将其展开，点击Internet信息服务(IIS)。 将标记处依次展开，站到网站，展开找到Default Web Site。 双击Default Web Site，点击右侧浏览 *:80 （http）即可查看IIS提供的默认界面。 预览结果。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://imqinhao.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[]},{"title":"Red Hat6.5虚拟机安装过程","slug":"RedHat_setup_script","date":"2020-02-14T12:13:14.000Z","updated":"2021-07-17T02:49:30.900Z","comments":true,"path":"2020/02/14/RedHat_setup_script/","link":"","permalink":"https://imqinhao.cn/2020/02/14/RedHat_setup_script/","excerpt":"系统： RedHat 6.5镜像： https://access.redhat.com/downloads/难度： ★★☆☆☆","text":"系统： RedHat 6.5镜像： https://access.redhat.com/downloads/难度： ★★☆☆☆ 选择Install or upgrade an existing system，进入安装步骤。 使用→选择Skip，按回车确定。 点击Next。 选择中文，点击next 默认即可，点击next 选择基本存储设别，点击下一步 选择“是，忽略所有数据” 输入用户名，点击下一步 选择时区（默认即可），点击下一步。 设置密码，输入密码后点击下一步。 提示我们密码过于简单，点击“无论如何都使用”。 选择安装的类型，我们选择“使用所有空间”，点击下一步。 提示我们“将存储配置写入磁盘”，我们选择“将修改写入磁盘”。 选择安装安装方式为基本服务器，点击下一步。 提示安装开始，等待即可。 安装过程，等待即可。 安装完成之后点击重新引导，此时会重启系统，表明系统已经安装成功。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://imqinhao.cn/categories/Linux/"}],"tags":[]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://imqinhao.cn/categories/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://imqinhao.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"C语言","slug":"C语言","permalink":"https://imqinhao.cn/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"算法基础","slug":"算法基础","permalink":"https://imqinhao.cn/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"Python","slug":"Python","permalink":"https://imqinhao.cn/categories/Python/"},{"name":"网络安全","slug":"网络安全","permalink":"https://imqinhao.cn/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://imqinhao.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"通信技术","slug":"通信技术","permalink":"https://imqinhao.cn/categories/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"},{"name":"Linux","slug":"Linux","permalink":"https://imqinhao.cn/categories/Linux/"},{"name":"小技巧","slug":"小技巧","permalink":"https://imqinhao.cn/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"华为认证","slug":"华为认证","permalink":"https://imqinhao.cn/categories/%E5%8D%8E%E4%B8%BA%E8%AE%A4%E8%AF%81/"},{"name":"软件破解","slug":"软件破解","permalink":"https://imqinhao.cn/categories/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/"},{"name":"计算机三级","slug":"计算机三级","permalink":"https://imqinhao.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/"},{"name":"Photoshop","slug":"Photoshop","permalink":"https://imqinhao.cn/categories/Photoshop/"},{"name":"交换机","slug":"交换机","permalink":"https://imqinhao.cn/categories/%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"name":"服务器","slug":"服务器","permalink":"https://imqinhao.cn/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[]}